/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/deepslate/dist/deepslate.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/deepslate/dist/deepslate.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlendedNoise": () => (/* binding */ z),
/* harmony export */   "BlockColors": () => (/* binding */ st),
/* harmony export */   "BlockDefinition": () => (/* binding */ ot),
/* harmony export */   "BlockModel": () => (/* binding */ ut),
/* harmony export */   "BlockPos": () => (/* binding */ o),
/* harmony export */   "BlockState": () => (/* binding */ B),
/* harmony export */   "Chunk": () => (/* binding */ C),
/* harmony export */   "ChunkPos": () => (/* binding */ k),
/* harmony export */   "ChunkSection": () => (/* binding */ E),
/* harmony export */   "Climate": () => (/* binding */ Pt),
/* harmony export */   "Direction": () => (/* binding */ n),
/* harmony export */   "FixedBiome": () => (/* binding */ yt),
/* harmony export */   "ImprovedNoise": () => (/* binding */ L),
/* harmony export */   "MultiNoise": () => (/* binding */ St),
/* harmony export */   "NbtReader": () => (/* binding */ l),
/* harmony export */   "NbtWriter": () => (/* binding */ c),
/* harmony export */   "NoiseChunkGenerator": () => (/* binding */ Et),
/* harmony export */   "NoiseInterpolator": () => (/* binding */ Bt),
/* harmony export */   "NoiseSampler": () => (/* binding */ At),
/* harmony export */   "NormalNoise": () => (/* binding */ Y),
/* harmony export */   "PerlinNoise": () => (/* binding */ V),
/* harmony export */   "PerlinSimplexNoise": () => (/* binding */ X),
/* harmony export */   "Random": () => (/* binding */ H),
/* harmony export */   "SimplexNoise": () => (/* binding */ O),
/* harmony export */   "Spline": () => (/* binding */ Z),
/* harmony export */   "Structure": () => (/* binding */ I),
/* harmony export */   "StructureRenderer": () => (/* binding */ vt),
/* harmony export */   "TerrainShaper": () => (/* binding */ xt),
/* harmony export */   "TextureAtlas": () => (/* binding */ bt),
/* harmony export */   "WorldgenRandom": () => (/* binding */ W),
/* harmony export */   "binarySearch": () => (/* binding */ D),
/* harmony export */   "clamp": () => (/* binding */ F),
/* harmony export */   "clampedLerp": () => (/* binding */ _),
/* harmony export */   "getListTag": () => (/* binding */ A),
/* harmony export */   "getOptional": () => (/* binding */ S),
/* harmony export */   "getTag": () => (/* binding */ y),
/* harmony export */   "lerp": () => (/* binding */ M),
/* harmony export */   "lerp2": () => (/* binding */ T),
/* harmony export */   "lerp3": () => (/* binding */ N),
/* harmony export */   "read": () => (/* binding */ f),
/* harmony export */   "readChunk": () => (/* binding */ p),
/* harmony export */   "readCompressed": () => (/* binding */ d),
/* harmony export */   "readRegion": () => (/* binding */ g),
/* harmony export */   "readUncompressed": () => (/* binding */ u),
/* harmony export */   "smoothstep": () => (/* binding */ U),
/* harmony export */   "square": () => (/* binding */ R),
/* harmony export */   "tagNames": () => (/* binding */ h),
/* harmony export */   "tagTypes": () => (/* binding */ a),
/* harmony export */   "write": () => (/* binding */ w),
/* harmony export */   "writeChunk": () => (/* binding */ P),
/* harmony export */   "writeCompressed": () => (/* binding */ v),
/* harmony export */   "writeRegion": () => (/* binding */ b),
/* harmony export */   "writeUncompressed": () => (/* binding */ m)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/common.js");
var n;!function(t){t.UP="up",t.DOWN="down",t.NORTH="north",t.EAST="east",t.SOUTH="south",t.WEST="west"}(n||(n={}));const r={[n.UP]:[0,1,0],[n.DOWN]:[0,-1,0],[n.NORTH]:[0,0,-1],[n.EAST]:[1,0,0],[n.SOUTH]:[0,0,1],[n.WEST]:[-1,0,0]};var o;!function(t){t.ALL=[t.UP,t.DOWN,t.NORTH,t.EAST,t.SOUTH,t.WEST],t.normal=function(t){return r[t]}}(n||(n={})),function(t){t.create=function(t,e,s){return[t,e,s]},t.offset=function(t,e,s,i){return[t[0]+e,t[1]+s,t[2]+i]},t.towards=function(e,s){return t.offset(e,...n.normal(s))}}(o||(o={}));const a={end:0,byte:1,short:2,int:3,long:4,float:5,double:6,byteArray:7,string:8,list:9,compound:10,intArray:11,longArray:12},h=["end","byte","short","int","long","float","double","byteArray","string","list","compound","intArray","longArray"];class l{constructor(t,e=!1){this.byte=this.readNum.bind(this,"getInt8",1),this.short=this.readNum.bind(this,"getInt16",2),this.int=this.readNum.bind(this,"getInt32",4),this.float=this.readNum.bind(this,"getFloat32",4),this.double=this.readNum.bind(this,"getFloat64",8),this.offset=0,this.littleEndian=e,this.arrayView=t,this.dataView=new DataView(t.buffer,t.byteOffset)}end(){return null}readNum(t,e){const s=this.dataView[t](this.offset,this.littleEndian);return this.offset+=e,s}long(){return[this.int(),this.int()]}byteArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.byte());return e}intArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.int());return e}longArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.long());return e}string(){const t=this.short(),e=this.arrayView.slice(this.offset,this.offset+t);return this.offset+=t,function(t){var e,s=[];for(e=0;e<t.length;e++)0==(128&t[e])?s.push(127&t[e]):e+1<t.length&&192==(224&t[e])&&128==(192&t[e+1])?s.push((31&t[e])<<6|63&t[e+1]):e+2<t.length&&224==(240&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])?s.push((15&t[e])<<12|(63&t[e+1])<<6|63&t[e+2]):e+3<t.length&&240==(248&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])&&128==(192&t[e+3])&&s.push((7&t[e])<<18|(63&t[e+1])<<12|(63&t[e+2])<<6|63&t[e+3]);return String.fromCharCode.apply(null,s)}(e)}list(){const t=h[this.byte()],e=this.int(),s=[];for(let i=0;i<e;i++)s.push(this[t]());return{type:t,value:s}}compound(){const t={};for(;;){const e=h[this.byte()];if("end"===e)break;const s=this.string(),i=this[e]();t[s]={type:e,value:i}}return t}}class c{constructor(t=!1){this.byte=this.writeNum.bind(this,"setInt8",1),this.short=this.writeNum.bind(this,"setInt16",2),this.int=this.writeNum.bind(this,"setInt32",4),this.float=this.writeNum.bind(this,"setFloat32",4),this.double=this.writeNum.bind(this,"setFloat64",8),this.offset=0,this.littleEndian=t,this.buffer=new ArrayBuffer(1024),this.arrayView=new Uint8Array(this.buffer),this.dataView=new DataView(this.buffer)}accommodate(t){const e=this.offset+t;if(this.buffer.byteLength>=e)return;let s=this.buffer.byteLength;for(;s<e;)s*=2;const i=new ArrayBuffer(s),n=new Uint8Array(i);n.set(this.arrayView),this.offset>this.buffer.byteLength&&n.fill(0,this.buffer.byteLength,this.offset),this.buffer=i,this.dataView=new DataView(i),this.arrayView=n}getData(){return this.accommodate(0),this.arrayView.slice(0,this.offset)}end(t){}writeNum(t,e,s){this.accommodate(e),this.dataView[t](this.offset,s,this.littleEndian),this.offset+=e}long(t){this.int(t[0]),this.int(t[1])}byteArray(t){this.int(t.length),this.accommodate(t.length),this.arrayView.set(t,this.offset),this.offset+=t.length}intArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.int(t[e])}longArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.long(t[e])}string(t){const e=function(t){var e,s,i=[];for(e=0;e<t.length;e++)(s=t.charCodeAt(e))<128?i.push(s):s<2048?(i.push(192|s>>6),i.push(128|63&s)):s<65536?(i.push(224|s>>12),i.push(128|s>>6&63),i.push(128|63&s)):(i.push(240|s>>18&7),i.push(128|s>>12&63),i.push(128|s>>6&63),i.push(128|63&s));return i}(t);this.short(e.length),this.accommodate(e.length),this.arrayView.set(e,this.offset),this.offset+=e.length}list(t){this.byte(a[t.type]),this.int(t.value.length),t.value;for(let e=0;e<t.value.length;e++)this[t.type](t.value[e])}compound(t){for(const e in t)this.byte(a[t[e].type]),this.string(e),this[t[e].type](t[e].value);this.byte(a.end)}}function u(t,e){const s=new l(t,e);if(s.byte()!==a.compound)throw new Error("Top tag should be a compound");return{name:s.string(),value:s.compound()}}function d(e,s){return u(pako__WEBPACK_IMPORTED_MODULE_0__["default"].inflate(e),s)}function f(t,e){return 2===(s=new Uint8Array(t.slice(0,2))).length&&31===s[0]&&139===s[1]?{compressed:!0,result:d(t,e)}:{compressed:!1,result:u(t,e)};var s}function g(t){const e=[];for(let s=0;s<32;s+=1)for(let i=0;i<32;i+=1){const n=4*((31&s)+32*(31&i));if(0===t[n+3])continue;const r=(t[n]<<16)+(t[n+1]<<8)+t[n+2],o=(t[n+4096]<<24)+(t[n+4097]<<16)+(t[n+4098]<<8)+t[n+4099],a=4096*r,h=(t[a]<<24)+(t[a+1]<<16)+(t[a+2]<<8)+t[a+3],l=t[a+4],c=t.slice(a+5,a+4+h);e.push({x:s,z:i,timestamp:o,compression:l,data:c})}return e}function p(t,e,s){const i=x(t,e,s);switch(i.compression){case 1:case 2:i.nbt=d(i.data);break;case 3:i.nbt=u(i.data);break;default:throw new Error(`Invalid compression mode ${i.compression}`)}return i}function m(t,e){const s=new c(e);return s.byte(a.compound),s.string(t.name),s.compound(t.value),s.getData()}function v(e,s,i){const n=m(e,s);return pako__WEBPACK_IMPORTED_MODULE_0__["default"][i?"deflate":"gzip"](n)}function w(t,e,s){return e?v(t,s):m(t,s)}function b(t){let e=0;for(const s of t)e+=Math.ceil(s.data.length/4096);const s=new Uint8Array(8192+4096*e),i=new DataView(s.buffer);let n=2;for(const e of t){const t=4*((31&e.x)+32*(31&e.z)),r=Math.ceil(e.data.length/4096);i.setInt8(t,n>>16),i.setInt16(t+1,65535&n),i.setInt8(t+3,r),i.setInt32(t+4096,e.timestamp);const o=4096*n;i.setInt32(o,e.data.length+1),i.setInt8(o+4,e.compression),s.set(e.data,o+5),n+=r}return s}function P(t,e,s,i){const n=x(t,e,s);switch(n.compression){case 1:n.data=v(i);break;case 2:n.data=v(i,!1,!0);break;case 3:n.data=m(i);break;default:throw new Error(`Invalid compression mode ${n.compression}`)}return n}function x(t,e,s){const i=t.find((t=>t.x===e&&t.z===s));if(void 0===i)throw new Error(`Cannot find chunk [${e}, ${s}]`);return i}function y(t,e,s){if(!t[e])throw new Error(`Missing ${e} tag`);if(t[e].type!==s)throw new Error(`Expected ${e} to be of type ${s}, but found ${t[e].type}`);return t[e].value}function A(t,e,s,i){const n=y(t,e,"list");if(n.type!==s)throw new Error(`Expected ${e} to be a list of ${s}s, but found ${n.type}s`);if(i&&n.value.length!==i)throw new Error(`Expected ${e} to be a list of length ${i}, but found length ${n.value.length}`);return n.value}function S(t,e){try{return t()}catch(t){return e}}class B{constructor(t,e={}){this.name=t,this.properties=e}getName(){return this.name}getProperties(){return this.properties}getProperty(t){return this.properties[t]}isFluid(){return"minecraft:water"===this.name||"minecraft:lava"===this.name}equals(t){return this.name===t.name&&Object.keys(this.properties).every((e=>t.properties[e]===this.properties[e]))}toString(){return 0===Object.keys(this.properties).length?this.name:`${this.name}[${Object.entries(this.properties).map((([t,e])=>t+"="+e)).join(",")}]`}static fromNbt(t){const e=y(t.value,"Name","string"),s=S((()=>y(t.value,"Properties","compound")),{}),i=Object.keys(s).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:y(s,e,"string")})),{});return new B(e,i)}}B.AIR=new B("minecraft:air");class E{constructor(t){this.minY=t,this.storage=Array(E.SIZE),this.palette=[B.AIR]}get minBlockY(){return this.minY<<4}index(t,e,s){return(t<<8)+(e<<4)+s}getBlockState(t,e,s){var i;const n=this.storage[this.index(t,e,s)];return null!==(i=this.palette[n])&&void 0!==i?i:B.AIR}setBlockState(t,e,s,i){let n=this.palette.findIndex((t=>t.equals(i)));-1===n&&(n=this.palette.length,this.palette.push(i)),this.storage[this.index(t,e,s)]=n}}E.WIDTH=16,E.SIZE=E.WIDTH*E.WIDTH*E.WIDTH;class C{constructor(t,e,s){this.minY=t,this.height=e,this.pos=s,this.sections=Array(this.sectionsCount).fill(null)}get maxY(){return this.minY+this.height}get minSection(){return this.minY>>4}get maxSection(){return 1+(this.maxY-1>>4)}get sectionsCount(){return this.maxSection-this.minSection}getSectionIndex(t){return(t>>4)-this.minSection}getBlockState(t){var e;const[s,i,n]=t,r=this.sections[this.getSectionIndex(i)];return null!==(e=null==r?void 0:r.getBlockState(15&s,15&i,15&n))&&void 0!==e?e:B.AIR}setBlockState(t,e){const[s,i,n]=t,r=this.getSectionIndex(i);let o=this.sections[r];if(null===o){if(e.equals(B.AIR))return;o=this.getOrCreateSection(r)}o.setBlockState(15&s,15&i,15&n,e)}getOrCreateSection(t){return null==this.sections[t]&&(this.sections[t]=new E(this.minSection+t)),this.sections[t]}}var k;!function(t){t.create=function(t,e){return[t,e]},t.fromBlockPos=function(t){return[t[0]>>4,t[2]>>4]},t.fromLong=function(t){return[4294967295&Number(t),Number(t>>BigInt(32))]},t.minBlockX=function(t){return t[0]<<4},t.minBlockZ=function(t){return t[1]<<4},t.maxBlockX=function(t){return t[0]<<19},t.maxBlockZ=function(t){return t[1]<<19}}(k||(k={}));class I{constructor(t,e=[],s=[]){this.size=t,this.palette=e,this.blocks=s,this.blocksMap=[],s.forEach((e=>{if(!this.isInside(e.pos))throw new Error(`Found block at ${e.pos} which is outside the structure bounds ${this.size}`);this.blocksMap[e.pos[0]*t[1]*t[2]+e.pos[1]*t[2]+e.pos[2]]=e}))}getSize(){return this.size}addBlock(t,e,s,i){if(!this.isInside(t))throw new Error(`Cannot add block at ${t} outside the structure bounds ${this.size}`);const n=new B(e,s);let r=this.palette.findIndex((t=>t.equals(n)));return-1===r&&(r=this.palette.length,this.palette.push(n)),this.blocks.push({pos:t,state:r,nbt:i}),this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]]={pos:t,state:r,nbt:i},this}getBlocks(){return this.blocks.map((t=>({pos:t.pos,state:this.palette[t.state],nbt:t.nbt})))}getBlock(t){if(!this.isInside(t))return null;const e=this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]];if(!e)return null;return{pos:e.pos,state:this.palette[e.state],nbt:e.nbt}}isInside(t){return t[0]>=0&&t[0]<this.size[0]&&t[1]>=0&&t[1]<this.size[1]&&t[2]>=0&&t[2]<this.size[2]}static fromNbt(t){const e=A(t.value,"size","int",3),s=A(t.value,"palette","compound").map((t=>B.fromNbt({name:"",value:t}))),i=A(t.value,"blocks","compound").map((t=>({pos:A(t,"pos","int",3),state:y(t,"state","int"),nbt:S((()=>y(t,"nbt","compound")),void 0)})));return new I(e,s,i)}}function R(t){return t*t}function F(t,e,s){return Math.max(e,Math.min(s,t))}function M(t,e,s){return e+t*(s-e)}function T(t,e,s,i,n,r){return M(e,M(t,s,i),M(t,n,r))}function N(t,e,s,i,n,r,o,a,h,l,c){return M(s,T(t,e,i,n,r,o),T(t,e,a,h,l,c))}function _(t,e,s){return s<0?t:s>1?e:M(s,t,e)}function U(t){return t*t*t*(t*(6*t-15)+10)}function D(t,e,s){let i=e-t;for(;i>0;){const e=Math.floor(i/2),n=t+e;s(n)?i=e:(t=n+1,i-=e+1)}return t}class O{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample2D(t,e){let s,i,n;const r=(t+e)*O.F2,o=Math.floor(t+r),a=t-(o-(s=(o+(i=Math.floor(e+r)))*O.G2));let h,l;a>(n=e-(i-s))?(h=1,l=0):(h=0,l=1);const c=a-h+O.G2,u=n-l+O.G2,d=a-1+2*O.G2,f=n-1+2*O.G2,g=255&o,p=255&i,m=this.P(g+this.P(p))%12,v=this.P(g+h+this.P(p+l))%12,w=this.P(g+1+this.P(p+1))%12;return 70*(this.getCornerNoise3D(m,a,n,0,.5)+this.getCornerNoise3D(v,c,u,0,.5)+this.getCornerNoise3D(w,d,f,0,.5))}sample(t,e,s){const i=.3333333333333333*(t+e+s),n=Math.floor(t+i),r=Math.floor(e+i),o=Math.floor(s+i),a=.16666666666666666*(n+r+o),h=t-(n-a),l=e-(r-a),c=s-(o-a);let u,d,f,g,p,m;h>=l?l>=c?(u=1,d=0,f=0,g=1,p=1,m=0):h>=c?(u=1,d=0,f=0,g=1,p=0,m=1):(u=0,d=0,f=1,g=1,p=0,m=1):l<c?(u=0,d=0,f=1,g=0,p=1,m=1):h<c?(u=0,d=1,f=0,g=0,p=1,m=1):(u=0,d=1,f=0,g=1,p=1,m=0);const v=h-u+.16666666666666666,w=l-d+.16666666666666666,b=c-f+.16666666666666666,P=h-g+.3333333333333333,x=l-p+.3333333333333333,y=c-m+.3333333333333333,A=h-.5,S=l-.5,B=c-.5,E=255&n,C=255&r,k=255&o,I=this.P(E+this.P(C+this.P(k)))%12,R=this.P(E+u+this.P(C+d+this.P(k+f)))%12,F=this.P(E+g+this.P(C+p+this.P(k+m)))%12,M=this.P(E+1+this.P(C+1+this.P(k+1)))%12;return 32*(this.getCornerNoise3D(I,h,l,c,.6)+this.getCornerNoise3D(R,v,w,b,.6)+this.getCornerNoise3D(F,P,x,y,.6)+this.getCornerNoise3D(M,A,S,B,.6))}P(t){return this.p[255&t]}getCornerNoise3D(t,e,s,i,n){let r,o=n-e*e-s*s-i*i;return o<0?r=0:(o*=o,r=o*o*O.gradDot(t,e,s,i)),r}static gradDot(t,e,s,i){const n=O.GRADIENT[15&t];return n[0]*e+n[1]*s+n[2]*i}}O.GRADIENT=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1],[1,1,0],[0,-1,1],[-1,1,0],[0,-1,-1]],O.F2=.5*(Math.sqrt(3)-1),O.G2=(3-Math.sqrt(3))/6;class L{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t>127?t-256:t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample(t,e,s,i=0,n=0){const r=t+this.xo,o=e+this.yo,a=s+this.zo,h=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=r-h,d=o-l,f=a-c;let g=0;if(0!==i){const t=n>=0&&n<d?n:d;g=Math.floor(t/i+1e-7)*i}return this.sampleAndLerp(h,l,c,u,d-g,f,d)}sampleAndLerp(t,e,s,i,n,r,o){const a=this.P(t),h=this.P(t+1),l=this.P(a+e),c=this.P(a+e+1),u=this.P(h+e),d=this.P(h+e+1),f=O.gradDot(this.P(l+s),i,n,r),g=O.gradDot(this.P(u+s),i-1,n,r),p=O.gradDot(this.P(c+s),i,n-1,r),m=O.gradDot(this.P(d+s),i-1,n-1,r),v=O.gradDot(this.P(l+s+1),i,n,r-1),w=O.gradDot(this.P(u+s+1),i-1,n,r-1),b=O.gradDot(this.P(c+s+1),i,n-1,r-1),P=O.gradDot(this.P(d+s+1),i-1,n-1,r-1);return N(U(i),U(o),U(r),f,g,p,m,v,w,b,P)}P(t){return 255&this.p[255&t]}}class V{constructor(t,e,s){if(1-e<s.length)throw new Error("Positive octaves are not allowed");this.noiseLevels=Array(s.length);for(let i=-e;i>=0;i-=1)i<s.length&&0!==s[i]?this.noiseLevels[i]=new L(t):t.consume(262);this.amplitudes=s,this.lowestFreqInputFactor=Math.pow(2,e),this.lowestFreqValueFactor=Math.pow(2,s.length-1)/(Math.pow(2,s.length)-1)}sample(t,e,s,i=0,n=0,r=!1){let o=0,a=this.lowestFreqInputFactor,h=this.lowestFreqValueFactor;for(let l=0;l<this.noiseLevels.length;l+=1){const c=this.noiseLevels[l];c&&(o+=this.amplitudes[l]*h*c.sample(V.wrap(t*a),r?-c.yo:V.wrap(e*a),V.wrap(s*a),i*a,n*a)),a*=2,h/=2}return o}getOctaveNoise(t){return this.noiseLevels[this.noiseLevels.length-1-t]}static wrap(t){return t-33554432*Math.floor(t/33554432+.5)}}class z{constructor(t){this.minLimitNoise=new V(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.maxLimitNoise=new V(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.mainNoise=new V(t,-7,[1,1,1,1,1,0,0,0])}sample(t,e,s,i,n,r,o){let a,h=0,l=1;for(let i=0;i<8;i+=1){if(a=this.mainNoise.getOctaveNoise(i),a){const i=r*l,n=o*l,c=V.wrap(t*i),u=V.wrap(e*n),d=V.wrap(s*i);h+=a.sample(c,u,d,n,e*n)/l}l/=2}h=(h/10+1)/2,l=1;let c=0,u=0;for(let r=0;r<16;r+=1){const o=i*l,d=n*l,f=V.wrap(t*o),g=V.wrap(e*d),p=V.wrap(s*o);h<1&&(a=this.minLimitNoise.getOctaveNoise(r))&&(c+=a.sample(f,g,p,d,e*d)/l),h>0&&(a=this.maxLimitNoise.getOctaveNoise(r))&&(u+=a.sample(f,g,p,d,e*d)/l),l/=2}return _(c/512,u/512,h)}}class Y{constructor(t,e,s){this.first=new V(t,e,s),this.second=new V(t,e,s);let i=1/0,n=-1/0;for(let t=0;t<s.length;t+=1)0!==s[t]&&(i=Math.min(i,t),n=Math.max(n,t));const r=.1*(1+1/(n-i+1));this.valueFactor=1/6/r}sample(t,e,s){const i=t*Y.INPUT_FACTOR,n=e*Y.INPUT_FACTOR,r=s*Y.INPUT_FACTOR;return(this.first.sample(t,e,s)+this.second.sample(i,n,r))*this.valueFactor}}Y.INPUT_FACTOR=1.0181268882175227;class X{constructor(t,e){const s=e[e.length-1],i=-e[0]+s+1,n=new Set(e),r=new O(t);this.noiseLevels=Array(i),s>=0&&s<i&&n.has(0)&&(this.noiseLevels[s]=r);for(let e=s+1;e<i;e+=1)e>=0&&n.has(s-e)?this.noiseLevels[e]=new O(t):t.consume(262);if(s>0)throw new Error("Positive octaves are not allowed");this.highestFreqInputFactor=Math.pow(2,s),this.highestFreqValueFactor=1/(Math.pow(2,i)-1)}sample(t,e,s){let i=0,n=this.highestFreqInputFactor,r=this.highestFreqValueFactor;for(let o=0;o<this.noiseLevels.length;o+=1){const a=this.noiseLevels[o];a&&(i+=r*a.sample2D(t*n+(s?a.xo:0),e*n+(s?a.yo:0))),n/=2,r*=2}return i}}class H{constructor(t){this.seed=BigInt(0),this.setSeed(t)}setSeed(t){this.seed=t^H.MULTIPLIER&H.MODULUS_MASK}advance(){this.seed=this.seed*H.MULTIPLIER+H.INCREMENT&H.MODULUS_MASK}consume(t){for(let e=0;e<t;e+=1)this.advance()}next(t){this.advance();const e=Number(this.seed>>BigInt(H.MODULUS_BITS-t));return e>2147483647?e-4294967296:e}nextInt(t){if(void 0===t)return this.next(32);if(0==(t&t-1))return Number(BigInt(t)*BigInt(this.next(31))>>BigInt(31));let e,s;for(;(e=this.next(31))-(s=e%t)+(t-1)<0;);return s}nextFloat(){return this.next(24)*H.FLOAT_MULTIPLIER}nextDouble(){const t=this.next(30);return this.advance(),t*H.DOUBLE_MULTIPLIER}}H.MODULUS_BITS=48,H.MODULUS_MASK=BigInt("281474976710655"),H.MULTIPLIER=BigInt("25214903917"),H.INCREMENT=BigInt("11"),H.FLOAT_MULTIPLIER=1/Math.pow(2,24),H.DOUBLE_MULTIPLIER=1/Math.pow(2,30);class W extends H{constructor(){super(...arguments),this.count=0}getCount(){return this.count}next(t){return this.count+=1,super.next(t)}}class Z{constructor(t,e,s=[],i=[],n=[]){this.name=t,this.coordinate=e,this.locations=s,this.values=i,this.derivatives=n}apply(t){const e=this.coordinate(t),s=D(0,this.locations.length,(t=>e<this.locations[t]))-1,i=this.locations.length-1;if(s<0)return this.values[0](t)+this.derivatives[0]*(e-this.locations[0]);if(s===i)return this.values[i](t)+this.derivatives[i]*(e-this.locations[i]);const n=this.locations[s],r=this.locations[s+1],o=this.derivatives[s],a=this.derivatives[s+1],h=(e-n)/(r-n),l=this.values[s](t),c=this.values[s+1](t),u=o*(r-n)-(c-l),d=-a*(r-n)+(c-l);return M(h,l,c)+h*(1-h)*M(h,u,d)}addPoint(t,e,s=0){return this.locations.push(t),this.values.push("number"==typeof e?()=>e:e.apply.bind(e)),this.derivatives.push(s),this}}new Z("a",(()=>1),[],[],[]);const j=t=>[(t>>16&255)/256,(t>>8&255)/256,(255&t)/256],$=[124/256,189/256,107/256],G=j(6396257),q=j(8431445),K=j(4764952),J=j(4159204),Q=j(8431445),tt=j(2129968),et=t=>[t/8,1-t/32,64*t],st={large_fern:()=>$,tall_grass:()=>$,grass_block:()=>$,fern:()=>$,grass:()=>$,potted_fern:()=>$,spruce_leaves:()=>G,birch_leaves:()=>q,oak_leaves:()=>K,jungle_leaves:()=>K,acacia_leaves:()=>K,dark_oak_leaves:()=>K,vine:()=>K,water:()=>J,bubble_column:()=>J,cauldron:()=>J,redstone_wire:t=>{var e;return(t=>{const e=t/15;return[.6*e+(e>0?.4:.3),F(e*e*.7-.5,0,1),F(e*e*.6-.7,0,1)]})(parseInt(null!==(e=t.power)&&void 0!==e?e:"0"))},sugar_cane:()=>$,attached_melon_stem:()=>Q,attached_pumpkin_stem:()=>Q,melon_stem:t=>{var e;return et(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},pumpkin_stem:t=>{var e;return et(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},lily_pad:()=>tt};var it;function nt(...t){let e=0;for(const s of t)e+=s.length;const s=new Float32Array(e);let i=0;for(const e of t)s.set(e,i),i+=e.length;return s}function rt(t,s){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();for(let n=0;n<t.length;n+=3)i[0]=t[n],i[1]=t[n+1],i[2]=t[n+2],gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transformMat4(i,i,s),t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2]}!function(t){t.rotate=function(t,e,s){let{up:i,down:n,north:r,east:o,south:a,west:h}=t;switch(s){case 90:[r,o,a,h]=[o,a,h,r];break;case 180:[r,o,a,h]=[a,h,r,o];break;case 270:[r,o,a,h]=[h,r,o,a]}switch(e){case 90:[i,r,n,a]=[r,n,a,i];break;case 180:[i,r,n,a]=[n,a,i,r];break;case 270:[i,r,n,a]=[a,i,r,n]}return{up:i,down:n,north:r,east:o,south:a,west:h}}}(it||(it={}));class ot{constructor(t,e,s){this.id=t,this.variants=e,this.multipart=s,this.variants=e}getModelVariants(t){if(this.variants){const e=Object.keys(this.variants).filter((e=>this.matchesVariant(e,t)));if(0===e.length)return[];const s=this.variants[e[0]];return[Array.isArray(s)?s[0]:s]}if(this.multipart){return this.multipart.filter((e=>!e.when||this.matchesCase(e.when,t))).map((t=>Array.isArray(t.apply)?t.apply[0]:t.apply))}return[]}getBuffers(t,e,n,r,o,a){var h,l,c,u;const d=this.getModelVariants(e),f=[],g=[],p=[],m=[];for(const v of d){const d=it.rotate(a,null!==(h=v.x)&&void 0!==h?h:0,null!==(l=v.y)&&void 0!==l?l:0),w=r.getBlockModel(v.model).getBuffers(t,e,n,o,d);if(v.x||v.y){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[8,8,8]),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateY(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(c=v.y)&&void 0!==c?c:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateX(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(u=v.x)&&void 0!==u?u:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[-8,-8,-8]),rt(w.position,t)}f.push(w.position),g.push(...w.texCoord),p.push(...w.tintColor),m.push(...w.index),o+=w.texCoord.length/2}const v=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(v),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(v,v,[.0625,.0625,.0625]);const w=nt(...f);return rt(w,v),{position:w,texCoord:g,tintColor:p,index:m}}matchesVariant(t,e){return t.split(",").every((t=>{const[s,i]=t.split("=");return e[s]===i}))}matchesCase(t,e){if(Array.isArray(t.OR))return t.OR.some((t=>this.matchesCase(t,e)));const s=t;return Object.keys(s).every((t=>s[t].split("|").includes(e[t])))}static fromJson(t,e){return new ot(t,e.variants,e.multipart)}}const at={0:[0,3,2,3,2,1,0,1],90:[2,3,2,1,0,1,0,3],180:[2,1,0,1,0,3,2,3],270:[0,1,0,3,2,3,2,1]},ht={x:[1,0,0],y:[0,1,0],z:[0,0,1]},lt=1.41421356237,ct={x:[1,lt,lt],y:[lt,1,lt],z:[lt,lt,1]};class ut{constructor(t,e,s,i){this.id=t,this.parent=e,this.textures=s,this.elements=i,this.flattened=!1}getBuffers(t,e,s,i,n){var r;const o=[],a=[],h=[],l=[];for(const c of null!==(r=this.elements)&&void 0!==r?r:[]){const r=this.getElementBuffers(t,e,c,i,s,n);o.push(r.position),a.push(...r.texCoord),h.push(...r.tintColor),l.push(...r.index),i+=r.texCoord.length/2}return{position:nt(...o),texCoord:a,tintColor:h,index:l}}getElementBuffers(t,n,r,o,a,h){var l,c,u,d,f,g,p,m,v,w,b,P;const x=r.from[0],y=r.from[1],A=r.from[2],S=r.to[0],B=r.to[1],E=r.to[2],C=[],k=[],I=[],R=[],F=(e,s,i)=>{var r,h,l,c,u,d,f,g,p,m,v,w;const[b,P,x,y]=a.getTextureUV(this.getTexture(e.texture)),A=(x-b)/16,S=(y-P)/16,B=A/16,E=S/16;s[0]=(null!==(h=null===(r=e.uv)||void 0===r?void 0:r[0])&&void 0!==h?h:s[0])*A+B,s[1]=(null!==(c=null===(l=e.uv)||void 0===l?void 0:l[1])&&void 0!==c?c:s[1])*S+E,s[2]=(null!==(d=null===(u=e.uv)||void 0===u?void 0:u[2])&&void 0!==d?d:s[2])*A-B,s[3]=(null!==(g=null===(f=e.uv)||void 0===f?void 0:f[3])&&void 0!==g?g:s[3])*S-E;const F=at[null!==(p=e.rotation)&&void 0!==p?p:0];k.push(b+s[F[0]],P+s[F[1]],b+s[F[2]],P+s[F[3]],b+s[F[4]],P+s[F[5]],b+s[F[6]],P+s[F[7]]);const M=(null!==(m=e.tintindex)&&void 0!==m?m:-1)>=0&&null!==(w=null===(v=st[t.slice(10)])||void 0===v?void 0:v.call(st,n))&&void 0!==w?w:[1,1,1];I.push(...M,...M,...M,...M),C.push(...i),R.push(o,o+1,o+2,o,o+2,o+3),o+=4};!(null===(c=null===(l=r.faces)||void 0===l?void 0:l.up)||void 0===c?void 0:c.texture)||r.faces.up.cullface&&h[r.faces.up.cullface]||F(r.faces.up,[x,16-E,S,16-A],[x,B,E,S,B,E,S,B,A,x,B,A]),!(null===(d=null===(u=r.faces)||void 0===u?void 0:u.down)||void 0===d?void 0:d.texture)||r.faces.down.cullface&&h[r.faces.down.cullface]||F(r.faces.down,[16-E,16-S,16-A,16-x],[x,y,A,S,y,A,S,y,E,x,y,E]),!(null===(g=null===(f=r.faces)||void 0===f?void 0:f.south)||void 0===g?void 0:g.texture)||r.faces.south.cullface&&h[r.faces.south.cullface]||F(r.faces.south,[x,16-B,S,16-y],[x,y,E,S,y,E,S,B,E,x,B,E]),!(null===(m=null===(p=r.faces)||void 0===p?void 0:p.north)||void 0===m?void 0:m.texture)||r.faces.north.cullface&&h[r.faces.north.cullface]||F(r.faces.north,[16-S,16-B,16-x,16-y],[S,y,A,x,y,A,x,B,A,S,B,A]),!(null===(w=null===(v=r.faces)||void 0===v?void 0:v.east)||void 0===w?void 0:w.texture)||r.faces.east.cullface&&h[r.faces.east.cullface]||F(r.faces.east,[16-E,16-B,16-A,16-y],[S,y,E,S,y,A,S,B,A,S,B,E]),!(null===(P=null===(b=r.faces)||void 0===b?void 0:b.west)||void 0===P?void 0:P.texture)||r.faces.west.cullface&&h[r.faces.west.cullface]||F(r.faces.west,[A,16-B,E,16-y],[x,y,A,x,y,E,x,B,E,x,B,A]);const M=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();if(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(M),r.rotation){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(...r.rotation.origin);gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(M,M,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate(M,M,gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(r.rotation.angle),ht[r.rotation.axis]),r.rotation.rescale&&gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(M,M,ct[r.rotation.axis]),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.negate(t,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(M,M,t)}const T=new Float32Array(C);return rt(T,M),{position:T,texCoord:k,tintColor:I,index:R}}getTexture(t){for(var e,s;t.startsWith("#");)t=null!==(s=null===(e=this.textures)||void 0===e?void 0:e[t.slice(1)])&&void 0!==s?s:"";return t.startsWith("minecraft:")||(t="minecraft:"+t),t}flatten(t){var e;if(!this.flattened&&this.parent){const s=t.getBlockModel(this.parent);if(!s)return console.warn(`parent ${this.parent} does not exist!`),void(this.flattened=!0);s.flatten(t),this.elements||(this.elements=s.elements),this.textures||(this.textures={}),Object.keys(null!==(e=s.textures)&&void 0!==e?e:{}).forEach((t=>{this.textures[t]||(this.textures[t]=s.textures[t])})),this.flattened=!0}}static fromJson(t,e){let s=e.parent;return s&&!s.startsWith("minecraft:")&&(s="minecraft:"+s),new ut(t,s,e.textures,e.elements)}}class dt{constructor(t,e,s){this.gl=t,this.program=this.initShaderProgram(e,s)}getProgram(){return this.program}initShaderProgram(t,e){const s=this.loadShader(this.gl.VERTEX_SHADER,t),i=this.loadShader(this.gl.FRAGMENT_SHADER,e),n=this.gl.createProgram();if(this.gl.attachShader(n,s),this.gl.attachShader(n,i),this.gl.linkProgram(n),!this.gl.getProgramParameter(n,this.gl.LINK_STATUS))throw new Error(`Unable to link shader program: ${this.gl.getProgramInfoLog(n)}`);return n}loadShader(t,e){const s=this.gl.createShader(t);if(this.gl.shaderSource(s,e),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS)){const e=new Error(`Compiling ${t===this.gl.VERTEX_SHADER?"vertex":"fragment"} shader: ${this.gl.getShaderInfoLog(s)}`);throw this.gl.deleteShader(s),e}return s}}function ft(t,e,s,i,n){const r=new ot("",{"":{model:""}},void 0),o={getBlockModel:()=>n};return n.flatten(o),r.getBuffers(t,{},e,o,s,i)}function gt(t,e,s,i,r,o){const a=r.up?16:[14.2,12.5,10.5,9,7,5.3,3.7,1.9,16,16,16,16,16,16,16,16][s];return ft(`minecraft:${t}`,i,e,r,new ut("","",{still:`minecraft:block/${t}_still`,flow:`minecraft:block/${t}_flow`},[{from:[0,0,0],to:[16,a,16],faces:{up:{texture:"#still",tintindex:o,cullface:n.UP},down:{texture:"#still",tintindex:o,cullface:n.DOWN},north:{texture:"#flow",tintindex:o,cullface:n.NORTH},east:{texture:"#flow",tintindex:o,cullface:n.EAST},south:{texture:"#flow",tintindex:o,cullface:n.SOUTH},west:{texture:"#flow",tintindex:o,cullface:n.WEST}}}]))}const pt={"minecraft:water":(t,e,s,i)=>gt("water",t,parseInt(e.level),s,i,0),"minecraft:lava":(t,e,s,i)=>gt("lava",t,parseInt(e.level),s,i),"minecraft:chest":(t,e,s)=>function(t,e,s,i){return ft("minecraft:chest",i,t,{},new ut("","",{0:"minecraft:block/chest"},[{from:[1,0,1],to:[15,14,15],faces:{up:{texture:"#0"},down:{texture:"#0"},north:{texture:"#0"},east:{texture:"#0"},south:{texture:"#0"},west:{texture:"#0"}}}]))}(t,e.facing,e.type,s)},mt=new Set(Object.keys(pt));class vt{constructor(t,e,s,i){var n,r;this.gl=t,this.structure=e,this.resources=s,this.chunks=[],(null==i?void 0:i.facesPerBuffer)&&console.warn("webgl render warning: facesPerBuffer option has been removed in favor of chunkSize"),this.chunkSize=null!==(n=null==i?void 0:i.chunkSize)&&void 0!==n?n:16,this.useInvisibleBlockBuffer=null===(r=null==i?void 0:i.useInvisibleBlockBuffer)||void 0===r||r,this.shaderProgram=new dt(t,"\n  attribute vec4 vertPos;\n  attribute vec2 texCoord;\n  attribute vec3 tintColor;\n  attribute vec3 normal;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vTexCoord = texCoord;\n    vTintColor = tintColor;\n    vLighting = normal.y * 0.2 + abs(normal.z) * 0.1 + 0.8;\n  }\n","\n  precision highp float;\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  uniform sampler2D sampler;\n\n  void main(void) {\n    vec4 texColor = texture2D(sampler, vTexCoord);\n    if(texColor.a < 0.01) discard;\n    gl_FragColor = vec4(texColor.xyz * vTintColor * vLighting, texColor.a);\n  }\n").getProgram(),this.gridShaderProgram=new dt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 vertColor;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = vertColor;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.colorShaderProgram=new dt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 blockPos;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = blockPos / 256.0;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.outlineBuffers=this.getOutlineBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers(),this.atlasTexture=this.getBlockTexture(),this.projMatrix=this.getPerspective(),this.activeShader=this.shaderProgram,this.initialize()}setStructure(t){this.structure=t,this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers()}initialize(){this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK)}getBlockTexture(){const t=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.resources.getTextureAtlas()),this.gl.generateMipmap(this.gl.TEXTURE_2D),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),t}getPerspective(){const t=70*Math.PI/180,e=this.gl.canvas.clientWidth/this.gl.canvas.clientHeight,i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();return gl_matrix__WEBPACK_IMPORTED_MODULE_2__.perspective(i,t,e,.1,500),i}getChunk(t){const e=2*Math.abs(t[0])+(t[0]<0?1:0),s=2*Math.abs(t[1])+(t[1]<0?1:0),i=2*Math.abs(t[2])+(t[2]<0?1:0);return this.chunks[e]||(this.chunks[e]=[]),this.chunks[e][s]||(this.chunks[e][s]=[]),this.chunks[e][s][i]||(this.chunks[e][s][i]={positions:[],textureCoordinates:[],tintColors:[],blockPositions:[],normals:[],indices:[],indexOffset:0}),this.chunks[e][s][i]}updateStructureBuffers(t){var i;const r=(t,i,n)=>{const r=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(r,r,i),rt(t.position,r),n.positions.push(t.position),n.textureCoordinates.push(...t.texCoord),n.tintColors.push(...t.tintColor);for(let s=0;s<t.position.length;s+=12){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s],t.position[s+1],t.position[s+2]),r=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+3],t.position[s+4],t.position[s+5]),o=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+6],t.position[s+7],t.position[s+8]);gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(r,r,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(o,o,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(r,r,o),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(r,r),n.normals.push(...r,...r,...r,...r)}for(let e=0;e<t.texCoord.length/2;e+=1)n.blockPositions.push(...i);n.indices.push(...t.index),n.indexOffset+=t.texCoord.length/2},o=t=>{t.positions=[],t.textureCoordinates=[],t.tintColors=[],t.blockPositions=[],t.normals=[],t.indices=[],t.indexOffset=0},a=t=>{t.buffer?(this.updateBuffer(t.buffer.position,this.gl.ARRAY_BUFFER,nt(...t.positions)),this.updateBuffer(t.buffer.texCoord,this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),this.updateBuffer(t.buffer.tintColor,this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),this.updateBuffer(t.buffer.normal,this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),this.updateBuffer(t.buffer.blockPos,this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),this.updateBuffer(t.buffer.index,this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),t.buffer.length=t.indices.length):t.buffer={position:this.createBuffer(this.gl.ARRAY_BUFFER,nt(...t.positions)),texCoord:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),tintColor:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),blockPos:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),normal:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),index:this.createBuffer(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),length:t.indices.length}};let h;t?t.forEach((t=>{const e=this.getChunk(t);o(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{o(t)}))))));for(const s of this.structure.getBlocks()){const o=s.state.getName(),a=s.state.getProperties(),l=null!==(i=this.resources.getDefaultBlockProperties(o))&&void 0!==i?i:{};Object.entries(l).forEach((([t,e])=>{a[t]||(a[t]=e)}));const c=[Math.floor(s.pos[0]/this.chunkSize),Math.floor(s.pos[1]/this.chunkSize),Math.floor(s.pos[2]/this.chunkSize)];if(t&&!t.some((t=>gl_matrix__WEBPACK_IMPORTED_MODULE_1__.equals(t,c))))continue;const u=this.getChunk(c);try{const t=this.resources.getBlockDefinition(o),e={up:this.needsCull(s,n.UP),down:this.needsCull(s,n.DOWN),west:this.needsCull(s,n.WEST),east:this.needsCull(s,n.EAST),north:this.needsCull(s,n.NORTH),south:this.needsCull(s,n.SOUTH)};t&&(h=t.getBuffers(o,a,this.resources,this.resources,u.indexOffset,e),r(h,s.pos,u)),mt.has(o)&&(h=pt[o](u.indexOffset,a,this.resources,e),r(h,s.pos,u))}catch(t){console.error(`Error rendering block ${o}`,t)}}t?t.forEach((t=>{const e=this.getChunk(t);a(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{a(t)}))))))}needsCull(t,e){var s,i;const r=null===(s=this.structure.getBlock(o.towards(t.pos,e)))||void 0===s?void 0:s.state;return!!r&&((null===(i=this.resources.getBlockFlags(r.getName()))||void 0===i?void 0:i.opaque)?!(e===n.UP&&t.state.isFluid()):t.state.isFluid()&&r.isFluid())}getGridBuffers(){const[t,e,s]=this.structure.getSize(),i=[],n=[];i.push(0,0,0,t,0,0),n.push(1,0,0,1,0,0),i.push(0,0,0,0,0,s),n.push(0,0,1,0,0,1),i.push(0,0,0,0,e,0),i.push(t,0,0,t,e,0),i.push(0,0,s,0,e,s),i.push(t,0,s,t,e,s),i.push(0,e,0,0,e,s),i.push(t,e,0,t,e,s),i.push(0,e,0,t,e,0),i.push(0,e,s,t,e,s);for(let e=1;e<=t;e+=1)i.push(e,0,0,e,0,s);for(let e=1;e<=s;e+=1)i.push(0,0,e,t,0,e);for(let e=0;e<8+t+s;e+=1)n.push(.8,.8,.8,.8,.8,.8);return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(i)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(n)),length:i.length/3}}getOutlineBuffers(){const t=[],e=[];return this.addCube(t,e,[1,1,1],[0,0,0],[1,1,1]),{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),length:t.length/3}}getInvisibleBlockBuffers(){if(!this.useInvisibleBlockBuffer)return;const t=this.structure.getSize(),e=[],s=[];for(let i=0;i<t[0];i+=1)for(let n=0;n<t[1];n+=1)for(let r=0;r<t[2];r+=1){const t=this.structure.getBlock([i,n,r]);void 0!==t&&(null===t?this.addCube(e,s,[1,.25,.25],[i+.4375,n+.4375,r+.4375],[i+.5625,n+.5625,r+.5625]):"minecraft:air"===t.state.getName()?this.addCube(e,s,[.5,.5,1],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]):"minecraft:cave_air"===t.state.getName()&&this.addCube(e,s,[.5,1,.5],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]))}return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(s)),length:e.length/3}}addCube(t,e,s,i,n){t.push(i[0],i[1],i[2],i[0],i[1],n[2]),t.push(n[0],i[1],i[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],n[0],i[1],i[2]),t.push(i[0],i[1],n[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],i[0],n[1],i[2]),t.push(n[0],i[1],i[2],n[0],n[1],i[2]),t.push(i[0],i[1],n[2],i[0],n[1],n[2]),t.push(n[0],i[1],n[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],i[0],n[1],n[2]),t.push(n[0],n[1],i[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],n[0],n[1],i[2]),t.push(i[0],n[1],n[2],n[0],n[1],n[2]);for(let t=0;t<24;t+=1)e.push(...s)}createBuffer(t,e){const s=this.gl.createBuffer();return this.gl.bindBuffer(t,s),this.gl.bufferData(t,e,this.gl.DYNAMIC_DRAW),s}updateBuffer(t,e,s){this.gl.bindBuffer(e,t),this.gl.bufferData(e,s,this.gl.STATIC_DRAW)}drawGrid(t){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.gridBuffers.position),this.setVertexAttr("vertColor",3,this.gridBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.gridBuffers.length)}drawInvisibleBlocks(t){this.useInvisibleBlockBuffer&&(this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.invisibleBlockBuffers.position),this.setVertexAttr("vertColor",3,this.invisibleBlockBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.invisibleBlockBuffers.length))}drawStructure(t){this.setShader(this.shaderProgram),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.atlasTexture),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("texCoord",2,t.buffer.texCoord),this.setVertexAttr("tintColor",3,t.buffer.tintColor),this.setVertexAttr("normal",3,t.buffer.normal),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawColoredStructure(t){this.setShader(this.colorShaderProgram),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("blockPos",3,t.buffer.blockPos),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawOutline(t,e){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.outlineBuffers.position),this.setVertexAttr("vertColor",3,this.outlineBuffers.color);const i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.copy(i,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(i,i,e),this.setUniform("mView",i),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.outlineBuffers.length)}setViewport(t,e,s,i){this.gl.viewport(t,e,s,i),this.projMatrix=this.getPerspective()}setShader(t){this.gl.useProgram(t),this.activeShader=t}setVertexAttr(t,e,s){const i=this.gl.getAttribLocation(this.activeShader,t);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s),this.gl.vertexAttribPointer(i,e,this.gl.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(i)}setUniform(t,e){const s=this.gl.getUniformLocation(this.activeShader,t);this.gl.uniformMatrix4fv(s,!1,e)}}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function wt(t,e,s,i){return new(s||(s=Promise))((function(n,r){function o(t){try{h(i.next(t))}catch(t){r(t)}}function a(t){try{h(i.throw(t))}catch(t){r(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(o,a)}h((i=i.apply(t,e||[])).next())}))}class bt{constructor(t,e){this.img=t,this.idMap=e,this.part=16/t.width}getTextureAtlas(){return this.img}getTextureUV(t){var e;return null!==(e=this.idMap[t])&&void 0!==e?e:[0,0,this.part,this.part]}static fromBlobs(t){return wt(this,void 0,void 0,(function*(){const e=Math.sqrt(Object.keys(t).length+1),s=Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))),i=16*s,n=1/s,r=document.createElement("canvas");r.width=i,r.height=i;const o=r.getContext("2d");this.drawInvalidTexture(o);const a={};let h=1;return yield Promise.all(Object.keys(t).map((e=>wt(this,void 0,void 0,(function*(){const i=h%s,r=Math.floor(h/s);h+=1,a[e]=[n*i,n*r,n*i+n,n*r+n];const l=yield createImageBitmap(t[e]);o.drawImage(l,0,0,16,16,16*i,16*r,16,16)}))))),new bt(o.getImageData(0,0,i,i),a)}))}static empty(){const t=document.createElement("canvas");t.width=16,t.height=16;const e=t.getContext("2d");return bt.drawInvalidTexture(e),new bt(e.getImageData(0,0,16,16),{})}static drawInvalidTexture(t){t.fillStyle="black",t.fillRect(0,0,16,16),t.fillStyle="magenta",t.fillRect(0,0,8,8),t.fillRect(8,8,8,8)}}var Pt,xt;!function(t){function e(t){return"number"==typeof t?new s(t,t):t}t.target=function(t,e,s,i,r,o){return new n(t,e,s,i,r,o)},t.parameters=function(t,s,n,r,o,a,h){return new i(e(t),e(s),e(n),e(r),e(o),e(a),h)},t.param=e,t.range=function(t,e){return new s(t,e)};class s{constructor(t,e){this.min=t,this.max=e}distance(t){const e=("number"==typeof t?t:t.min)-this.max,s=this.min-("number"==typeof t?t:t.max);return e>0?e:Math.max(s,0)}union(t){return new s(Math.min(this.min,t.min),Math.max(this.max,t.max))}}t.Param=s;class i{constructor(t,e,s,i,n,r,o){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r,this.offset=o}fittness(t){return R(this.temperature.distance(t.temperature))+R(this.humidity.distance(t.humidity))+R(this.continentalness.distance(t.continentalness))+R(this.erosion.distance(t.erosion))+R(this.depth.distance(t.depth))+R(this.weirdness.distance(t.weirdness))+R(this.offset-t.offset)}space(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,new s(this.offset,this.offset)]}}t.ParamPoint=i;class n{constructor(t,e,s,i,n,r){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r}get offset(){return 0}toArray(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,this.offset]}}t.TargetPoint=n;t.Parameters=class{constructor(t){this.things=t,this.index=new r(t)}find(t){return this.index.search(t,((t,e)=>t.distance(e)))}};class r{constructor(t){this.root=r.build(t.map((([t,e])=>new h(t,e))))}static build(t){if(1===t.length)return t[0];if(t.length<=r.CHILDREN_PER_NODE){const e=t.map((t=>{let e=0;for(let s=0;s<7;s+=1){const i=t.space[s];e+=Math.abs((i.min+i.max)/2)}return{key:e,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t));return new a(e)}let e=1/0,s=-1,i=[];for(let n=0;n<7;++n){r.sort(t,n,!1),i=r.bucketize(t);let o=0;for(const t of i)o+=r.area(t.space);e>o&&(e=o,s=n)}return t=r.sort(t,s,!1),i=r.bucketize(t),i=r.sort(i,s,!0),new a(i.map((t=>r.build(t.children))))}static sort(t,e,s){return t.map((t=>{const i=t.space[e],n=(i.min+i.max)/2;return{key:s?Math.abs(n):n,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t))}static bucketize(t){const e=[];let s=[];const i=Math.pow(10,Math.floor(Math.log(t.length-.01)/Math.log(10)));for(const n of t)s.push(n),s.length<i||(e.push(new a(s)),s=[]);return 0!==s.length&&e.push(new a(s)),e}static area(t){let e=0;for(const s of t)e+=Math.abs(s.max-s.min);return e}search(t,e){return this.root.search(t.toArray(),e).thing()}}r.CHILDREN_PER_NODE=10,t.RTree=r;class o{constructor(t){this.space=t}distance(t){let e=0;for(let s=0;s<7;s+=1)e+=R(this.space[s].distance(t[s]));return e}}t.RNode=o;class a extends o{constructor(t){super(a.buildSpace(t)),this.children=t}static buildSpace(t){let e=[...Array(7)].map((()=>new s(1/0,-1/0)));for(const s of t)e=[...Array(7)].map(((t,i)=>e[i].union(s.space[i])));return e}search(t,e){let s=1/0,i=null;for(const n of this.children){const r=e(n,t);if(s<=r)continue;const o=n.search(t,e),a=n==o?r:e(o,t);s<=a||(s=a,i=o)}return i}}t.RSubTree=a;class h extends o{constructor(t,e){super(t.space()),this.thing=e}search(){return this}}t.RLeaf=h}(Pt||(Pt={}));class yt{constructor(t,e={offset:0,factor:1,peaks:1,nearWater:!1}){this.biome=t,this.shape=e}getBiome(t,e,s){return this.biome}getTerrainShape(t,e){return this.shape}}class At{constructor(t,e,s,i,n,r){this.cellWidth=t,this.cellHeight=e,this.cellCountY=s,this.biomeSource=i,this.settings=n,this.blendedNoise=r,this.mountainPeakNoise=new Y(new W(BigInt(42)),-16,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])}fillNoiseColumn(t,e,s,i,n){const r=e*this.cellWidth>>2,o=s*this.cellWidth>>2,{offset:a,factor:h,peaks:l}=this.biomeSource.getTerrainShape(r,o),c=684.412*this.settings.sampling.xzScale,u=684.412*this.settings.sampling.yScale,d=c/this.settings.sampling.xzFactor,f=u/this.settings.sampling.yFactor;for(let r=0;r<=n;r+=1){const n=r+i,o=this.blendedNoise.sample(e,n,s,c,u,d,f),g=this.samplePeakNoise(l,e*this.cellHeight,s*this.cellHeight)/128,p=this.computeInitialDensity(n*this.cellHeight,a,h,0,g)+o;t[r]=this.applySlide(p,n)}}samplePeakNoise(t,e,s){if(0===t)return 0;const i=3e3/this.cellWidth,n=this.mountainPeakNoise.sample(e*i,0,s*i);return n>0?t*n:t/2*n}computeInitialDensity(t,e,s,i,n){const r=(At.computeDimensionDensity(this.settings.densityFactor,this.settings.densityOffset,t,i)+e+n)*s;return r*(r>0?4:1)}applySlide(t,e){const s=e-Math.floor(this.settings.minY/this.cellHeight);if(this.settings.topSlide.size>0){const e=(this.cellCountY-s-this.settings.topSlide.offset)/this.settings.topSlide.size;t=_(this.settings.topSlide.target,t,e)}if(this.settings.bottomSlide.size>0){const e=(s-this.settings.bottomSlide.offset)/this.settings.bottomSlide.size;t=_(this.settings.bottomSlide.target,t,e)}return t}static computeDimensionDensity(t,e,s,i=0){return t*(1-s/128+i)+e}}!function(t){function e(t){return l.apply(t)+.015}function s(t){return c.apply(t)}function i(t){return u.apply(t)}function n(t){return 3*-(Math.abs(Math.abs(t)-.6666667)-.33333334)}t.offset=e,t.factor=s,t.peaks=i,t.peaksAndValleys=n,t.point=function(t,e,s){return{continents:t,erosion:e,weirdness:s,ridges:n(s)}},t.nearWater=function(t,e){return!(t<-.2)&&(t<-.05||Math.abs(e)<.15)},t.shape=function(t,n){return{offset:e(t),factor:s(t),peaks:i(t),nearWater:n}};const r=f("beachSpline",-.15,-.05,0,0,.1,0,-.03,!1,!1),o=f("lowSpline",-.1,-.1,.03,.1,.1,.01,-.03,!1,!1),a=f("midSpline",-.1,-.1,.03,.1,.7,.01,-.03,!0,!0),h=f("highSpline",-.05,.3,.03,.1,1,.01,.01,!0,!0),l=new Z("offsetSampler",(t=>t.continents)).addPoint(-1.1,.044).addPoint(-1.02,-.2222).addPoint(-.51,-.2222).addPoint(-.44,-.12).addPoint(-.18,-.12).addPoint(-.16,r).addPoint(-.15,r).addPoint(-.1,o).addPoint(.25,a).addPoint(1,h),c=new Z("Factor-Continents",(t=>t.continents)).addPoint(-.19,505).addPoint(-.15,d("erosionCoast",800,!0,"ridgeCoast-OldMountains")).addPoint(-.1,d("erosionInland",700,!0,"ridgeInland-OldMountains")).addPoint(.03,d("erosionMidInland",650,!0,"ridgeMidInland-OldMountains")).addPoint(.06,d("erosionFarInland",600,!1,"ridgeFarInland-OldMountains")),u=new Z("Peaks",(t=>t.continents)).addPoint(.1,0).addPoint(.2,new Z("Peaks-erosion",(t=>t.erosion)).addPoint(-.8,new Z("Peaks-erosion-ridges",(t=>t.ridges)).addPoint(-1,0).addPoint(.2,0).addPoint(1,new Z("Peaks-erosion-ridges-weirdness",(t=>t.weirdness)).addPoint(-.01,80).addPoint(.01,20))).addPoint(-.4,0));function d(t,e,s,i){const n=new Z(t,(t=>t.erosion)).addPoint(-.6,e).addPoint(-.5,342).addPoint(-.35,e).addPoint(-.25,e).addPoint(-.1,342).addPoint(.03,e);if(s){const t=new Z("weirdnessShattered",(t=>t.weirdness)).addPoint(0,e).addPoint(.1,80),s=new Z("ridgesShattered",(t=>t.ridges)).addPoint(-.9,e).addPoint(-.69,t);n.addPoint(.35,e).addPoint(.45,s).addPoint(.55,s).addPoint(.62,e)}else{const t=new Z(i,(t=>t.ridges)).addPoint(-.7,e).addPoint(-.15,175),s=new Z(i,(t=>t.ridges)).addPoint(.45,e).addPoint(.7,200);n.addPoint(.05,s).addPoint(.4,s).addPoint(.45,t).addPoint(.55,t).addPoint(.58,e)}return n}function f(t,e,s,i,n,r,o,a,h,l){const c=g(M(r,.6,1.5),l),u=g(M(r,.6,1),l),d=g(r,l),f=v(t+"-widePlateau",e-.15,.5*r,M(.5,.5,.5)*r,.5*r,.6*r,.5),p=v(t+"-narrowPlateau",e,o*r,i*r,.5*r,.6*r,.5),m=v(t+"-plains",e,o,o,i,n,.5),w=v(t+"-plainsFarInland",e,o,o,i,n,.5),b=new Z(t,(t=>t.ridges)).addPoint(-1,e).addPoint(-.4,m).addPoint(0,n+.07),P=v(t+"-swamps",-.02,a,a,i,n,0),x=new Z(t,(t=>t.erosion)).addPoint(-.85,c).addPoint(-.7,u).addPoint(-.4,d).addPoint(-.35,f).addPoint(-.1,p).addPoint(.2,m);return h&&x.addPoint(.4,w).addPoint(.45,b).addPoint(.55,b).addPoint(.58,w),x.addPoint(.7,P),x}function g(t,e){const s=new Z(`M-spline for continentalness: ${t} ${e}`,(t=>t.ridges)),i=p(-1,t,-.7),n=p(1,t,-.7),r=function(t){return.5*(1-t)/(.46082947*(1-.5*(1-t)))-1.17}(t);if(-.65<r&&r<1){const e=p(-.65,t,-.7),o=p(-.75,t,-.7),a=m(i,o,-1,-.75);s.addPoint(-1,i,a),s.addPoint(-.75,o),s.addPoint(-.65,e);const h=p(r,t,-.7),l=m(h,n,r,1);s.addPoint(r-.01,h),s.addPoint(r,h,l),s.addPoint(1,n,l)}else{const t=m(i,n,-1,1);e?(s.addPoint(-1,Math.max(.2,i)),s.addPoint(0,M(.5,i,n),t)):s.addPoint(-1,i,t),s.addPoint(1,n,t)}return s}function p(t,e,s){const i=.46082947*(t+1.17)*(1-.5*(1-e))-.5*(1-e);return t<s?Math.max(i,-.2222):Math.max(i,0)}function m(t,e,s,i){return(e-t)/(i-s)}function v(t,e,s,i,n,r,o){const a=Math.max(.5*(s-e),o),h=5*(i-s);return new Z(t,(t=>t.ridges)).addPoint(-1,e,a).addPoint(-.4,s,Math.min(a,h)).addPoint(0,i,h).addPoint(.4,n,2*(n-i)).addPoint(1,r,.7*(r-n))}}(xt||(xt={}));class St{constructor(t,e,s,i,n,r,o){this.parameters=e,this.temperature=new Y(new W(t),s.firstOctave,s.amplitudes),this.humidity=new Y(new W(t+BigInt(1)),i.firstOctave,i.amplitudes),this.continentalness=new Y(new W(t+BigInt(2)),n.firstOctave,n.amplitudes),this.erosion=new Y(new W(t+BigInt(3)),r.firstOctave,r.amplitudes),this.weirdness=new Y(new W(t+BigInt(4)),o.firstOctave,o.amplitudes),this.offset=new Y(new W(t+BigInt(5)),-3,[1,1,1,1])}getBiome(t,e,s){const i=t+this.getOffset(t,0,s),n=e+this.getOffset(e,s,t),r=s+this.getOffset(s,t,0),o=this.temperature.sample(i,n,r),a=this.humidity.sample(i,n,r),h=this.continentalness.sample(i,0,r),l=this.erosion.sample(i,0,r),c=this.weirdness.sample(i,0,r),u=xt.offset(xt.point(h,l,c)),d=At.computeDimensionDensity(1,-.51875,4*e)+u,f=new Pt.TargetPoint(o,a,h,l,d,c);return this.parameters.find(f)}getTerrainShape(t,e){const s=t+this.getOffset(t,0,e),i=e+this.getOffset(e,t,0),n=this.continentalness.sample(s,0,i),r=this.erosion.sample(s,0,i),o=this.weirdness.sample(s,0,i),a=xt.point(n,r,o),h=xt.nearWater(n,o);return xt.shape(a,h)}getOffset(t,e,s){return 4*this.offset.sample(t,e,s)}}class Bt{constructor(t,e,s,i,n,r){this.cellCountY=e,this.cellCountZ=s,this.cellMinY=n,this.filler=r,this.noise000=0,this.noise001=0,this.noise100=0,this.noise101=0,this.noise010=0,this.noise011=0,this.noise110=0,this.noise111=0,this.valueXZ00=0,this.valueXZ10=0,this.valueXZ01=0,this.valueXZ11=0,this.valueZ0=0,this.valueZ1=0,this.minCellX=i[0]*t,this.minCellZ=i[1]*s,this.slice0=Bt.allocateSlice(e,s),this.slice1=Bt.allocateSlice(e,s)}static allocateSlice(t,e){const s=Array(e+1);for(let i=0;i<e+1;i+=1)s[i]=Array(t+1);return s}initializeForFirstCellX(){this.fillSlice(this.slice0,this.minCellX)}advanceCellX(t){this.fillSlice(this.slice1,this.minCellX+t+1)}fillSlice(t,e){for(let s=0;s<this.cellCountZ+1;s+=1)this.filler(t[s],e,this.minCellZ+s,this.cellMinY,this.cellCountY)}selectCellYZ(t,e){this.noise000=this.slice0[e][t],this.noise001=this.slice0[e+1][t],this.noise100=this.slice1[e][t],this.noise101=this.slice1[e+1][t],this.noise010=this.slice0[e][t+1],this.noise011=this.slice0[e+1][t+1],this.noise110=this.slice1[e][t+1],this.noise111=this.slice1[e+1][t+1]}updateForY(t){this.valueXZ00=M(t,this.noise000,this.noise010),this.valueXZ10=M(t,this.noise100,this.noise110),this.valueXZ01=M(t,this.noise001,this.noise011),this.valueXZ11=M(t,this.noise101,this.noise111)}updateForX(t){this.valueZ0=M(t,this.valueXZ00,this.valueXZ10),this.valueZ1=M(t,this.valueXZ01,this.valueXZ11)}calculateValue(t){return M(t,this.valueZ0,this.valueZ1)}swapSlices(){[this.slice0,this.slice1]=[this.slice1,this.slice0]}}class Et{constructor(t,e,s){this.seed=t,this.biomeSource=e,this.settings=s,this.cellHeight=s.noise.ySize<<2,this.cellWidth=s.noise.xzSize<<2,this.cellCountXZ=Math.floor(16/this.cellWidth),this.cellCountY=Math.floor(s.noise.height/this.cellHeight);const i=new W(t),n=new z(i);s.noise.useSimplexSurfaceNoise?new X(i,[-3,-2,-1,0]):new V(i,-3,[1,1,1,1]),i.consume(2620),new V(i,-15,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]),this.sampler=new At(this.cellWidth,this.cellHeight,this.cellCountY,e,s.noise,n)}fill(t){const e=Math.max(t.minY,this.settings.noise.minY),s=Math.min(t.maxY,this.settings.noise.minY+this.settings.noise.height),i=Math.floor(e/this.cellHeight),n=Math.floor((s-e)/this.cellHeight),r=k.minBlockX(t.pos),o=k.minBlockZ(t.pos),a=new Bt(this.cellCountXZ,n,this.cellCountXZ,t.pos,i,this.sampler.fillNoiseColumn.bind(this.sampler)),h=Array(a);h.forEach((t=>t.initializeForFirstCellX()));for(let e=0;e<this.cellCountXZ;e+=1){h.forEach((t=>t.advanceCellX(e)));for(let s=0;s<this.cellCountXZ;s+=1){let l=t.getOrCreateSection(t.sectionsCount-1);for(let c=n-1;c>=0;c-=1){h.forEach((t=>t.selectCellYZ(c,s)));for(let n=this.cellHeight-1;n>=0;n-=1){const u=(i+c)*this.cellHeight+n,d=15&u,f=t.getSectionIndex(u);t.getSectionIndex(l.minBlockY)!==f&&(l=t.getOrCreateSection(f));const g=n/this.cellHeight;h.forEach((t=>t.updateForY(g)));for(let t=0;t<this.cellWidth;t+=1){const i=r+e*this.cellWidth+t,n=15&i,c=t/this.cellWidth;h.forEach((t=>t.updateForX(c)));for(let t=0;t<this.cellWidth;t+=1){const e=o+s*this.cellWidth+t,r=15&e,h=t/this.cellWidth,c=a.calculateValue(h),f=this.baseState(i,u,e,c);f.equals(B.AIR)||l.setBlockState(n,d,r,f)}}}}}h.forEach((t=>t.swapSlices()))}}baseState(t,e,s,i){return(i=(i=F(i/200,-1,1))/2-i*i*i/24)>0?this.settings.defaultBlock:e<this.settings.seaLevel?this.settings.defaultFluid:B.AIR}}
//# sourceMappingURL=deepslate.esm.js.map


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "ARRAY_TYPE": () => (/* binding */ ARRAY_TYPE),
/* harmony export */   "RANDOM": () => (/* binding */ RANDOM),
/* harmony export */   "setMatrixArrayType": () => (/* binding */ setMatrixArrayType),
/* harmony export */   "toRadian": () => (/* binding */ toRadian),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromXRotation": () => (/* binding */ fromXRotation),
/* harmony export */   "fromYRotation": () => (/* binding */ fromYRotation),
/* harmony export */   "fromZRotation": () => (/* binding */ fromZRotation),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromQuat2": () => (/* binding */ fromQuat2),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "getScaling": () => (/* binding */ getScaling),
/* harmony export */   "getRotation": () => (/* binding */ getRotation),
/* harmony export */   "fromRotationTranslationScale": () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   "fromRotationTranslationScaleOrigin": () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "frustum": () => (/* binding */ frustum),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "perspectiveFromFieldOfView": () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   "ortho": () => (/* binding */ ortho),
/* harmony export */   "lookAt": () => (/* binding */ lookAt),
/* harmony export */   "targetTo": () => (/* binding */ targetTo),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "hermite": () => (/* binding */ hermite),
/* harmony export */   "bezier": () => (/* binding */ bezier),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/BuilderData/ABBiome.ts":
/*!************************************!*\
  !*** ./src/BuilderData/ABBiome.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ABElement": () => (/* binding */ ABElement)
/* harmony export */ });
/* harmony import */ var _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/Renderer/ElementRenderer */ "./src/UI/Renderer/ElementRenderer.ts");

var ABElement = /** @class */ (function () {
    function ABElement(builder, elementA, elementB) {
        this.allowEdit = false;
        this.elementA = elementA;
        this.elementB = elementB;
        this.builder = builder;
    }
    ABElement.create = function (builder, elementA, elementB) {
        var ab_biome = new ABElement(builder, elementA, elementB);
        builder.registerLayoutElement(ab_biome);
        return ab_biome;
    };
    ABElement.prototype.lookupKey = function (temperatureIndex, humidityIndex) {
        return this.getKey();
    };
    ABElement.prototype.lookup = function (temperatureIndex, humidityIndex) {
        return this;
    };
    ABElement.prototype.lookupRecursive = function (temperatureIndex, humidityIndex, mode) {
        if (mode === "Any") {
            return this;
        }
        else if (mode === "A") {
            return this.builder.getLayoutElement(this.elementA).lookupRecursive(temperatureIndex, humidityIndex, mode);
        }
        else {
            return this.builder.getLayoutElement(this.elementB).lookupRecursive(temperatureIndex, humidityIndex, mode);
        }
    };
    ABElement.prototype.getElement = function (mode) {
        if (mode === "A") {
            return this.builder.getLayoutElement(this.elementA);
        }
        else {
            return this.builder.getLayoutElement(this.elementB);
        }
    };
    ABElement.prototype.getRenderer = function () {
        if (this.renderer === undefined)
            this.renderer = new _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_0__.ABBiomeRenderer(this);
        return this.renderer;
    };
    ABElement.prototype.getKey = function () {
        return this.elementA + "/" + this.elementB;
    };
    return ABElement;
}());



/***/ }),

/***/ "./src/BuilderData/Biome.ts":
/*!**********************************!*\
  !*** ./src/BuilderData/Biome.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Biome": () => (/* binding */ Biome)
/* harmony export */ });
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uniqid */ "./node_modules/uniqid/index.js");
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uniqid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/Renderer/ElementRenderer */ "./src/UI/Renderer/ElementRenderer.ts");


var Biome = /** @class */ (function () {
    function Biome(name, color, key, isVanilla) {
        if (isVanilla === void 0) { isVanilla = false; }
        this.allowEdit = true;
        this.name = name;
        this.color = color;
        if (key !== undefined)
            this.key = key;
        else if (isVanilla)
            this.key = name;
        else
            this.key = uniqid__WEBPACK_IMPORTED_MODULE_0__('biome_');
        this.allowEdit = !isVanilla;
        this.isVanilla = isVanilla;
    }
    Biome.create = function (builder, name, color, key, isVanilla) {
        if (isVanilla === void 0) { isVanilla = false; }
        var biome = new Biome(name, color, key, isVanilla);
        if (isVanilla)
            builder.registerVanillaBiome(biome);
        else
            builder.registerLayoutElement(biome);
        return biome;
    };
    Biome.fromJSON = function (builder, json) {
        if (builder.vanillaBiomes.has(json.key)) {
            builder.registerLayoutElement(builder.vanillaBiomes.get(json.key));
        }
        else {
            var biome = new Biome(json.name, json.color, json.key, false);
            builder.registerLayoutElement(biome);
            return biome;
        }
    };
    Biome.prototype.toJSON = function () {
        return {
            key: this.key,
            name: this.name,
            color: this.isVanilla ? undefined : this.color
        };
    };
    Biome.prototype.lookupKey = function (temperatureIndex, humidityIndex) {
        return this.getKey();
    };
    Biome.prototype.lookup = function (temperatureIndex, humidityIndex) {
        return this;
    };
    Biome.prototype.lookupRecursive = function (temperatureIndex, humidityIndex, mode) {
        return this;
    };
    Biome.prototype.getRenderer = function () {
        if (this.renderer === undefined)
            this.renderer = new _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_1__.BiomeRenderer(this);
        return this.renderer;
    };
    Biome.prototype.getKey = function () {
        return this.key;
    };
    return Biome;
}());



/***/ }),

/***/ "./src/BuilderData/BiomeBuilder.ts":
/*!*****************************************!*\
  !*** ./src/BuilderData/BiomeBuilder.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BiomeBuilder": () => (/* binding */ BiomeBuilder)
/* harmony export */ });
/* harmony import */ var _Vanilla_VanillaBiomes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vanilla/VanillaBiomes */ "./src/Vanilla/VanillaBiomes.ts");
/* harmony import */ var _ABBiome__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABBiome */ "./src/BuilderData/ABBiome.ts");
/* harmony import */ var _Biome__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Biome */ "./src/BuilderData/Biome.ts");
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layout */ "./src/BuilderData/Layout.ts");
/* harmony import */ var _LayoutElementDummy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LayoutElementDummy */ "./src/BuilderData/LayoutElementDummy.ts");
/* harmony import */ var _LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LayoutElementUnassigned */ "./src/BuilderData/LayoutElementUnassigned.ts");
/* harmony import */ var _Slice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Slice */ "./src/BuilderData/Slice.ts");







var BiomeBuilder = /** @class */ (function () {
    function BiomeBuilder(continentalnesses, erosions, weirdnesses, temperatures, humidities) {
        this.continentalnesses = continentalnesses;
        this.erosions = erosions;
        this.weirdnesses = weirdnesses.map(function (w) { return [w[0], w[1], "unassigned", "A"]; });
        this.temperatures = temperatures;
        this.humidities = humidities;
        this.renderedElements = new Map();
        this.layoutElements = new Map();
        this.vanillaBiomes = new Map();
        this.slices = [];
        this.layouts = [];
        this.biomes = [];
        this.layoutElementDummy = _LayoutElementDummy__WEBPACK_IMPORTED_MODULE_4__.LayoutElementDummy.create(this);
        this.layoutElementUnassigned = _LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_5__.LayoutElementUnassigned.create(this);
    }
    BiomeBuilder.prototype.loadJSON = function (json) {
        var _this = this;
        var _a, _b, _c;
        this.continentalnesses = json.continentalnesses;
        this.erosions = json.erosions;
        this.weirdnesses = json.weirdnesses;
        this.temperatures = json.temperatures;
        this.humidities = json.humidities;
        this.layoutElements.clear();
        this.layouts = [];
        this.biomes = [];
        this.slices = [];
        _Vanilla_VanillaBiomes__WEBPACK_IMPORTED_MODULE_0__.VanillaBiomes.registerVanillaBiomes(this);
        this.registerLayoutElement(this.layoutElementDummy);
        this.registerLayoutElement(this.layoutElementUnassigned);
        (_a = json.slices) === null || _a === void 0 ? void 0 : _a.forEach(function (slice) {
            _Slice__WEBPACK_IMPORTED_MODULE_6__.Slice.fromJSON(_this, slice);
        });
        (_b = json.layouts) === null || _b === void 0 ? void 0 : _b.forEach(function (layout) {
            _Layout__WEBPACK_IMPORTED_MODULE_3__.Layout.fromJSON(_this, layout);
        });
        (_c = json.biomes) === null || _c === void 0 ? void 0 : _c.forEach(function (biome) {
            _Biome__WEBPACK_IMPORTED_MODULE_2__.Biome.fromJSON(_this, biome);
        });
    };
    BiomeBuilder.prototype.toJSON = function () {
        var _this = this;
        return {
            continentalnesses: this.continentalnesses,
            erosions: this.erosions,
            weirdnesses: this.weirdnesses.map(function (weirdness) {
                weirdness[2] = _this.getSlice(weirdness[2]).getKey();
                return weirdness;
            }),
            temperatures: this.temperatures,
            humidities: this.humidities,
            layouts: this.layouts,
            slices: this.slices,
            biomes: this.biomes
        };
    };
    BiomeBuilder.prototype.getSlice = function (name) {
        var _a;
        return (_a = this.renderedElements.get(name)) !== null && _a !== void 0 ? _a : this.layoutElementUnassigned;
    };
    BiomeBuilder.prototype.getRenderedElement = function (name) {
        var _a;
        return (_a = this.renderedElements.get(name)) !== null && _a !== void 0 ? _a : this.layoutElementUnassigned;
    };
    BiomeBuilder.prototype.getLayoutElement = function (name) {
        var element = this.layoutElements.get(name);
        /*
        if (element === undefined && this.vanillaBiomes.has(name)){
            element = this.vanillaBiomes.get(name)
            this.registerLayoutElement(element)
        }*/
        if (element === undefined) {
            var biomeKeys = name.split('/');
            if (biomeKeys.length !== 2) {
                return this.layoutElementUnassigned;
            }
            var biomeA = this.getLayoutElement(biomeKeys[0]);
            var biomeB = this.getLayoutElement(biomeKeys[1]);
            return _ABBiome__WEBPACK_IMPORTED_MODULE_1__.ABElement.create(this, biomeA.getKey(), biomeB.getKey());
        }
        else {
            return element;
        }
    };
    BiomeBuilder.prototype.registerSlice = function (slice) {
        this.slices.push(slice);
        this.renderedElements.set(slice.getKey(), slice);
    };
    BiomeBuilder.prototype.removeSlice = function (slice) {
        var index = this.slices.indexOf(slice);
        if (index > -1) {
            this.slices.splice(index, 1);
        }
        this.renderedElements.delete(slice.getKey());
    };
    BiomeBuilder.prototype.registerVanillaBiome = function (biome) {
        this.vanillaBiomes.set(biome.getKey(), biome);
        this.renderedElements.set(biome.getKey(), biome);
    };
    BiomeBuilder.prototype.registerLayoutElement = function (element) {
        this.layoutElements.set(element.getKey(), element);
        this.renderedElements.set(element.getKey(), element);
        if (element instanceof _Layout__WEBPACK_IMPORTED_MODULE_3__.Layout) {
            this.layouts.push(element);
        }
        if (element instanceof _Biome__WEBPACK_IMPORTED_MODULE_2__.Biome) {
            this.biomes.push(element);
        }
    };
    BiomeBuilder.prototype.removeLayoutElement = function (element) {
        this.layoutElements.delete(element.getKey());
        this.renderedElements.delete(element.getKey());
        if (element instanceof _Layout__WEBPACK_IMPORTED_MODULE_3__.Layout) {
            var index = this.layouts.indexOf(element);
            this.layouts.splice(index, 1);
        }
        if (element instanceof _Biome__WEBPACK_IMPORTED_MODULE_2__.Biome) {
            var index = this.biomes.indexOf(element);
            this.biomes.splice(index, 1);
        }
    };
    BiomeBuilder.prototype.getNumTemperatures = function () {
        return this.temperatures.length;
    };
    BiomeBuilder.prototype.getNumHumidities = function () {
        return this.temperatures.length;
    };
    BiomeBuilder.prototype.getNumContinentalnesses = function () {
        return this.continentalnesses.length;
    };
    BiomeBuilder.prototype.getNumErosions = function () {
        return this.erosions.length;
    };
    return BiomeBuilder;
}());



/***/ }),

/***/ "./src/BuilderData/Exporter.ts":
/*!*************************************!*\
  !*** ./src/BuilderData/Exporter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Exporter": () => (/* binding */ Exporter)
/* harmony export */ });
/* harmony import */ var _Biome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Biome */ "./src/BuilderData/Biome.ts");
/* harmony import */ var _LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayoutElementUnassigned */ "./src/BuilderData/LayoutElementUnassigned.ts");


var Exporter = /** @class */ (function () {
    function Exporter(builder) {
        this.builder = builder;
    }
    Exporter.prototype.export = function () {
        var array = [];
        for (var w_idx = 0; w_idx < this.builder.weirdnesses.length; w_idx++) {
            var slice = this.builder.getSlice(this.builder.weirdnesses[w_idx][2]);
            var mode = this.builder.weirdnesses[w_idx][3];
            array[w_idx] = [];
            for (var c_idx = 0; c_idx < this.builder.continentalnesses.length; c_idx++) {
                array[w_idx][c_idx] = [];
                for (var e_idx = 0; e_idx < this.builder.erosions.length; e_idx++) {
                    array[w_idx][c_idx][e_idx] = [];
                    var layout = slice === null || slice === void 0 ? void 0 : slice.lookup(c_idx, e_idx);
                    for (var t_idx = 0; t_idx < this.builder.temperatures.length; t_idx++) {
                        array[w_idx][c_idx][e_idx][t_idx] = [];
                        for (var h_idx = 0; h_idx < this.builder.humidities.length; h_idx++) {
                            var biome = layout === null || layout === void 0 ? void 0 : layout.lookupRecursive(t_idx, h_idx, mode);
                            if (biome === undefined || biome instanceof _LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_1__.LayoutElementUnassigned) {
                                array[w_idx][c_idx][e_idx][t_idx][h_idx] = { biome: "", done: true };
                            }
                            else if (biome instanceof _Biome__WEBPACK_IMPORTED_MODULE_0__.Biome) {
                                array[w_idx][c_idx][e_idx][t_idx][h_idx] = { biome: biome.name, done: false };
                            }
                            else {
                                console.warn("Data structure corruption at w: " + w_idx, +" c: " + c_idx + " e: " + e_idx + " t: " + t_idx + " h: " + h_idx + " - Found element of type " + biome.constructor.name);
                            }
                        }
                    }
                }
            }
        }
        var biomes = [];
        for (var w_idx = 0; w_idx < this.builder.weirdnesses.length; w_idx++) {
            for (var c_idx = 0; c_idx < this.builder.continentalnesses.length; c_idx++) {
                for (var e_idx = 0; e_idx < this.builder.erosions.length; e_idx++) {
                    for (var t_idx = 0; t_idx < this.builder.temperatures.length; t_idx++) {
                        for (var h_idx = 0; h_idx < this.builder.humidities.length; h_idx++) {
                            if (array[w_idx][c_idx][e_idx][t_idx][h_idx].done)
                                continue;
                            var max_e_idx = void 0;
                            for (max_e_idx = e_idx; max_e_idx < this.builder.erosions.length; max_e_idx++) {
                                if (!this.checkRange(array, w_idx, c_idx, e_idx, t_idx, h_idx, w_idx, c_idx, max_e_idx, t_idx, h_idx))
                                    break;
                            }
                            max_e_idx--;
                            var max_w_idx = void 0;
                            for (max_w_idx = w_idx; max_w_idx < this.builder.weirdnesses.length; max_w_idx++) {
                                if (!this.checkRange(array, w_idx, c_idx, e_idx, t_idx, h_idx, max_w_idx, c_idx, max_e_idx, t_idx, h_idx))
                                    break;
                            }
                            max_w_idx--;
                            var max_c_idx = void 0;
                            for (max_c_idx = c_idx; max_c_idx < this.builder.continentalnesses.length; max_c_idx++) {
                                if (!this.checkRange(array, w_idx, c_idx, e_idx, t_idx, h_idx, max_w_idx, max_c_idx, max_e_idx, t_idx, h_idx))
                                    break;
                            }
                            max_c_idx--;
                            var max_h_idx = void 0;
                            for (max_h_idx = h_idx; max_h_idx < this.builder.humidities.length; max_h_idx++) {
                                if (!this.checkRange(array, w_idx, c_idx, e_idx, t_idx, h_idx, max_w_idx, max_c_idx, max_e_idx, t_idx, max_h_idx))
                                    break;
                            }
                            max_h_idx--;
                            var max_t_idx = void 0;
                            for (max_t_idx = t_idx; max_t_idx < this.builder.temperatures.length; max_t_idx++) {
                                if (!this.checkRange(array, w_idx, c_idx, e_idx, t_idx, h_idx, max_w_idx, max_c_idx, max_e_idx, max_t_idx, max_h_idx))
                                    break;
                            }
                            max_t_idx--;
                            this.setDone(array, w_idx, c_idx, e_idx, t_idx, h_idx, max_w_idx, max_c_idx, max_e_idx, max_t_idx, max_h_idx);
                            biomes.push({
                                parameters: {
                                    weirdness: [
                                        this.builder.weirdnesses[w_idx][1].min,
                                        this.builder.weirdnesses[max_w_idx][1].max
                                    ],
                                    continentalness: [
                                        this.builder.continentalnesses[c_idx][1].min,
                                        this.builder.continentalnesses[max_c_idx][1].max
                                    ],
                                    erosion: [
                                        this.builder.erosions[e_idx][1].min,
                                        this.builder.erosions[max_e_idx][1].max
                                    ],
                                    temperature: [
                                        this.builder.temperatures[t_idx][1].min,
                                        this.builder.temperatures[max_t_idx][1].max
                                    ],
                                    humidity: [
                                        this.builder.humidities[h_idx][1].min,
                                        this.builder.humidities[max_h_idx][1].max
                                    ],
                                    depth: 1.0,
                                    offset: 0.0
                                },
                                biome: array[w_idx][c_idx][e_idx][t_idx][h_idx].biome
                            });
                            biomes.push({
                                parameters: {
                                    weirdness: [
                                        this.builder.weirdnesses[w_idx][1].min,
                                        this.builder.weirdnesses[max_w_idx][1].max
                                    ],
                                    continentalness: [
                                        this.builder.continentalnesses[c_idx][1].min,
                                        this.builder.continentalnesses[max_c_idx][1].max
                                    ],
                                    erosion: [
                                        this.builder.erosions[e_idx][1].min,
                                        this.builder.erosions[max_e_idx][1].max
                                    ],
                                    temperature: [
                                        this.builder.temperatures[t_idx][1].min,
                                        this.builder.temperatures[max_t_idx][1].max
                                    ],
                                    humidity: [
                                        this.builder.humidities[h_idx][1].min,
                                        this.builder.humidities[max_h_idx][1].max
                                    ],
                                    depth: 0.0,
                                    offset: 0.0
                                },
                                biome: array[w_idx][c_idx][e_idx][t_idx][h_idx].biome
                            });
                        }
                    }
                }
            }
        }
        var dimension = {
            type: "minecraft:overworld",
            generator: {
                biome_source: {
                    biomes: biomes,
                    type: "minecraft:multi_noise"
                },
                seed: 0,
                settings: "minecraft:overworld",
                type: "minecraft:noise"
            }
        };
        console.log("Emmited " + biomes.length + " Biome settings...");
        return (JSON.stringify(dimension));
    };
    Exporter.prototype.checkRange = function (array, min_w_idx, min_c_idx, min_e_idx, min_t_idx, min_h_idx, max_w_idx, max_c_idx, max_e_idx, max_t_idx, max_h_idx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var biome = array[min_w_idx][min_c_idx][min_e_idx][min_t_idx][min_h_idx].biome;
        for (var w_idx = min_w_idx; w_idx <= max_w_idx; w_idx++) {
            for (var c_idx = min_c_idx; c_idx <= max_c_idx; c_idx++) {
                for (var e_idx = min_e_idx; e_idx <= max_e_idx; e_idx++) {
                    for (var t_idx = min_t_idx; t_idx <= max_t_idx; t_idx++) {
                        for (var h_idx = min_h_idx; h_idx <= max_h_idx; h_idx++) {
                            var cell_biome = (_e = (_d = (_c = (_b = (_a = array[w_idx]) === null || _a === void 0 ? void 0 : _a[c_idx]) === null || _b === void 0 ? void 0 : _b[e_idx]) === null || _c === void 0 ? void 0 : _c[t_idx]) === null || _d === void 0 ? void 0 : _d[h_idx]) === null || _e === void 0 ? void 0 : _e.biome;
                            if (cell_biome === undefined) {
                                console.warn("undefined element at w: " + w_idx + " c: " + c_idx + " e: " + e_idx + " t: " + t_idx + " h: " + h_idx);
                            }
                            if (((_k = (_j = (_h = (_g = (_f = array[w_idx]) === null || _f === void 0 ? void 0 : _f[c_idx]) === null || _g === void 0 ? void 0 : _g[e_idx]) === null || _h === void 0 ? void 0 : _h[t_idx]) === null || _j === void 0 ? void 0 : _j[h_idx]) === null || _k === void 0 ? void 0 : _k.biome) !== biome)
                                return false;
                        }
                    }
                }
            }
        }
        return true;
    };
    Exporter.prototype.setDone = function (array, min_w_idx, min_c_idx, min_e_idx, min_t_idx, min_h_idx, max_w_idx, max_c_idx, max_e_idx, max_t_idx, max_h_idx) {
        for (var w_idx = min_w_idx; w_idx <= max_w_idx; w_idx++) {
            for (var c_idx = min_c_idx; c_idx <= max_c_idx; c_idx++) {
                for (var e_idx = min_e_idx; e_idx <= max_e_idx; e_idx++) {
                    for (var t_idx = min_t_idx; t_idx <= max_t_idx; t_idx++) {
                        for (var h_idx = min_h_idx; h_idx <= max_h_idx; h_idx++) {
                            array[w_idx][c_idx][e_idx][t_idx][h_idx].done = true;
                        }
                    }
                }
            }
        }
    };
    return Exporter;
}());



/***/ }),

/***/ "./src/BuilderData/Layout.ts":
/*!***********************************!*\
  !*** ./src/BuilderData/Layout.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Layout": () => (/* binding */ Layout)
/* harmony export */ });
/* harmony import */ var _UI_Renderer_LayoutGridRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/Renderer/LayoutGridRenderer */ "./src/UI/Renderer/LayoutGridRenderer.ts");
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uniqid */ "./node_modules/uniqid/index.js");
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uniqid__WEBPACK_IMPORTED_MODULE_1__);


var Layout = /** @class */ (function () {
    function Layout(builder, name, array, key) {
        this.allowEdit = true;
        this.name = name;
        this.builder = builder;
        this.array = array !== null && array !== void 0 ? array : new Array(builder.getNumTemperatures()).fill(0).map(function () { return new Array(builder.getNumHumidities()).fill("unassigned"); });
        this.key = key !== null && key !== void 0 ? key : uniqid__WEBPACK_IMPORTED_MODULE_1__('layout_');
        this.undoActions = [];
    }
    Layout.create = function (builder, name, array, key) {
        var layout = new Layout(builder, name, array, key);
        builder.registerLayoutElement(layout);
        return layout;
    };
    Layout.fromJSON = function (builder, json) {
        return Layout.create(builder, json.name, json.array, json.key);
    };
    Layout.prototype.toJSON = function () {
        var _this = this;
        return {
            key: this.key,
            name: this.name,
            array: this.array.map(function (row) { return row.map(function (e) { return _this.builder.getLayoutElement(e).getKey(); }); })
        };
    };
    Layout.prototype.set = function (temperatureIndex, humidityIndex, element, recordUndo) {
        if (recordUndo === void 0) { recordUndo = true; }
        if (this.array[temperatureIndex][humidityIndex] === element)
            return;
        if (recordUndo)
            this.undoActions.push({ t_id: temperatureIndex, h_id: humidityIndex, value: this.array[temperatureIndex][humidityIndex] });
        this.array[temperatureIndex][humidityIndex] = element;
    };
    Layout.prototype.undo = function () {
        if (this.undoActions.length > 0) {
            var action = this.undoActions.pop();
            this.array[action.t_id][action.h_id] = action.value;
        }
    };
    Layout.prototype.lookupKey = function (temperatureIndex, humidityIndex) {
        return this.array[temperatureIndex][humidityIndex];
    };
    Layout.prototype.lookup = function (temperatureIndex, humidityIndex) {
        var key = this.lookupKey(temperatureIndex, humidityIndex);
        var element = this.builder.getLayoutElement(key);
        return element;
    };
    Layout.prototype.lookupRecursive = function (temperatureIndex, humidityIndex, mode) {
        var element = this.lookup(temperatureIndex, humidityIndex);
        return element.lookupRecursive(temperatureIndex, humidityIndex, mode);
    };
    Layout.prototype.getSize = function () {
        return [this.builder.getNumTemperatures(), this.builder.getNumHumidities()];
    };
    Layout.prototype.getRenderer = function () {
        if (this.renderer === undefined)
            this.renderer = new _UI_Renderer_LayoutGridRenderer__WEBPACK_IMPORTED_MODULE_0__.LayoutGridRenderer(this);
        return this.renderer;
    };
    Layout.prototype.getKey = function () {
        return this.key;
    };
    return Layout;
}());



/***/ }),

/***/ "./src/BuilderData/LayoutElementDummy.ts":
/*!***********************************************!*\
  !*** ./src/BuilderData/LayoutElementDummy.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayoutElementDummy": () => (/* binding */ LayoutElementDummy)
/* harmony export */ });
var LayoutElementDummy = /** @class */ (function () {
    function LayoutElementDummy() {
        this.allowEdit = false;
        this.name = "__dummy__";
    }
    LayoutElementDummy.create = function (builder) {
        var dummy = new LayoutElementDummy();
        builder.registerLayoutElement(dummy);
        return dummy;
    };
    LayoutElementDummy.prototype.lookupKey = function (temperatureIndex, humidityIndex) {
        return "__dummy__";
    };
    LayoutElementDummy.prototype.lookup = function (temperatureIndex, humidityIndex) {
        return this;
    };
    LayoutElementDummy.prototype.lookupRecursive = function (temperatureIndex, humidityIndex, mode) {
        return this;
    };
    LayoutElementDummy.prototype.getRenderer = function () {
        throw new Error("Method not implemented.");
    };
    LayoutElementDummy.prototype.getKey = function () {
        return "__dummy__";
    };
    return LayoutElementDummy;
}());



/***/ }),

/***/ "./src/BuilderData/LayoutElementUnassigned.ts":
/*!****************************************************!*\
  !*** ./src/BuilderData/LayoutElementUnassigned.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayoutElementUnassigned": () => (/* binding */ LayoutElementUnassigned)
/* harmony export */ });
/* harmony import */ var _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/Renderer/ElementRenderer */ "./src/UI/Renderer/ElementRenderer.ts");

var LayoutElementUnassigned = /** @class */ (function () {
    function LayoutElementUnassigned() {
        this.allowEdit = false;
        this.name = "- Unassigned -";
    }
    LayoutElementUnassigned.create = function (builder) {
        var element = new LayoutElementUnassigned();
        builder.registerLayoutElement(element);
        return element;
    };
    LayoutElementUnassigned.prototype.lookupKey = function (temperatureIndex, humidityIndex) {
        return this.getKey();
    };
    LayoutElementUnassigned.prototype.lookup = function (temperatureIndex, humidityIndex) {
        return this;
    };
    LayoutElementUnassigned.prototype.lookupRecursive = function (temperatureIndex, humidityIndex, mode) {
        return this;
    };
    LayoutElementUnassigned.prototype.getRenderer = function () {
        if (this.renderer === undefined)
            this.renderer = new _UI_Renderer_ElementRenderer__WEBPACK_IMPORTED_MODULE_0__.UnassignedRenderer();
        return this.renderer;
    };
    LayoutElementUnassigned.prototype.getKey = function () {
        return "unassigned";
    };
    return LayoutElementUnassigned;
}());



/***/ }),

/***/ "./src/BuilderData/Slice.ts":
/*!**********************************!*\
  !*** ./src/BuilderData/Slice.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Slice": () => (/* binding */ Slice)
/* harmony export */ });
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uniqid */ "./node_modules/uniqid/index.js");
/* harmony import */ var uniqid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uniqid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI_Renderer_SliceGridRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/Renderer/SliceGridRenderer */ "./src/UI/Renderer/SliceGridRenderer.ts");


var Slice = /** @class */ (function () {
    function Slice(builder, name, array, key) {
        this.allowEdit = true;
        this.name = name;
        this.builder = builder;
        this.array = array;
        this.key = key !== null && key !== void 0 ? key : uniqid__WEBPACK_IMPORTED_MODULE_0__('slice_');
        this.undoActions = [];
    }
    Slice.create = function (builder, name, fill) {
        var slice = new Slice(builder, name, new Array(builder.getNumContinentalnesses()).fill(0).map(function () { return new Array(builder.getNumErosions()).fill(fill); }));
        builder.registerSlice(slice);
        return slice;
    };
    Slice.fromJSON = function (builder, json) {
        var slice = new Slice(builder, json.name, json.array, json.key);
        builder.registerSlice(slice);
        return slice;
    };
    Slice.prototype.toJSON = function () {
        var _this = this;
        return {
            key: this.key,
            name: this.name,
            array: this.array.map(function (row) { return row.map(function (e) { return _this.builder.getLayoutElement(e).getKey(); }); })
        };
    };
    Slice.prototype.getSize = function () {
        return [this.builder.getNumContinentalnesses(), this.builder.getNumErosions()];
    };
    Slice.prototype.set = function (continentalnessIndex, erosionIndex, element) {
        if (this.array[continentalnessIndex][erosionIndex] === element)
            return;
        this.undoActions.push({ c_id: continentalnessIndex, e_id: erosionIndex, value: this.array[continentalnessIndex][erosionIndex] });
        this.array[continentalnessIndex][erosionIndex] = element;
    };
    Slice.prototype.undo = function () {
        if (this.undoActions.length > 0) {
            var action = this.undoActions.pop();
            this.array[action.c_id][action.e_id] = action.value;
        }
    };
    Slice.prototype.lookupKey = function (continentalnessIndex, erosionIndex) {
        return this.array[continentalnessIndex][erosionIndex];
    };
    Slice.prototype.lookup = function (continentalnessIndex, erosionIndex) {
        var key = this.lookupKey(continentalnessIndex, erosionIndex);
        return this.builder.getLayoutElement(key);
    };
    Slice.prototype.getRenderer = function () {
        if (this.renderer === undefined)
            this.renderer = new _UI_Renderer_SliceGridRenderer__WEBPACK_IMPORTED_MODULE_1__.SliceGridRenderer(this);
        return this.renderer;
    };
    Slice.prototype.getKey = function () {
        return this.key;
    };
    return Slice;
}());



/***/ }),

/***/ "./src/UI/AssignSlicesManager.ts":
/*!***************************************!*\
  !*** ./src/UI/AssignSlicesManager.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssignSlicesManager": () => (/* binding */ AssignSlicesManager)
/* harmony export */ });
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ "./src/UI/UI.ts");

var AssignSlicesManager = /** @class */ (function () {
    function AssignSlicesManager(builder) {
        this.builder = builder;
        this.title = document.getElementById("layoutName");
        this.div = document.getElementById("assignSlices");
        this.splineCanvas = document.getElementById("splineDisplayCanvas");
        this.undoActions = [];
    }
    AssignSlicesManager.prototype.refresh = function () {
        var _this = this;
        _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().splineDisplayManager.setPos(undefined);
        this.title.readOnly = true;
        this.title.value = "Assign Slices";
        this.div.classList.remove("hidden");
        this.div.innerHTML = "";
        var table = document.createElement("table");
        this.builder.weirdnesses.forEach(function (weirdness, w_idx) {
            var element = _this.builder.getRenderedElement(weirdness[2]);
            var row = document.createElement("tr");
            var name_col = document.createElement("td");
            name_col.innerHTML = weirdness[0] + ": ";
            name_col.classList.add("weirdness_name");
            row.appendChild(name_col);
            var slice_icon_col = document.createElement("td");
            slice_icon_col.classList.add("slice_icon");
            var slice_icon = document.createElement("canvas");
            slice_icon.width = 100;
            slice_icon.height = 100;
            element.getRenderer().draw(slice_icon.getContext('2d'), 0, 0, 100, 100, -1, -1, false, true);
            slice_icon_col.appendChild(slice_icon);
            row.appendChild(slice_icon_col);
            var slice_name_col = document.createElement("td");
            slice_name_col.innerHTML = element.name;
            slice_name_col.classList.add("slice_name");
            row.appendChild(slice_name_col);
            var slice_mode_select_col = document.createElement("td");
            slice_mode_select_col.classList.add("slice_mode_select");
            var slice_mode_select_img = document.createElement("img");
            slice_mode_select_img.src = "mode_" + weirdness[3] + ".png";
            slice_mode_select_img.onclick = function (evt) {
                _this.builder.weirdnesses[w_idx][3] = weirdness[3] === "A" ? "B" : "A";
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().refresh();
                evt.preventDefault();
                evt.stopPropagation();
            };
            slice_mode_select_col.appendChild(slice_mode_select_img);
            row.onclick = function (evt) {
                if (evt.altKey) {
                    _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().selectedElement = _this.builder.weirdnesses[w_idx][2];
                    _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().refresh();
                }
                else {
                    if (_UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().selectedElement !== "" && _this.builder.weirdnesses[w_idx][2] !== _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().selectedElement) {
                        _this.undoActions.push({ w_idx: w_idx, value: _this.builder.weirdnesses[w_idx][2] });
                        _this.builder.weirdnesses[w_idx][2] = _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().selectedElement;
                        _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().refresh();
                    }
                }
            };
            row.oncontextmenu = function (evt) {
                if (_this.builder.weirdnesses[w_idx][2] !== "unassigned") {
                    _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().openElement = _this.builder.weirdnesses[w_idx][2];
                    _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().refresh();
                }
                evt.preventDefault();
            };
            row.onmouseover = function (evt) {
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().splineDisplayManager.setWeirdnesses([weirdness[1]]);
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().splineDisplayManager.refresh();
            };
            row.appendChild(slice_mode_select_col);
            table.appendChild(row);
        });
        var t = this;
        table.onmouseout = function (evt) {
            if (!t.div.classList.contains('hidden')) {
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().splineDisplayManager.setWeirdnesses([]);
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().splineDisplayManager.refresh();
            }
        };
        this.div.appendChild(table);
        this.div.tabIndex = 1;
        this.div.focus();
        this.div.onkeydown = function (evt) {
            if (evt.key === "z" && evt.ctrlKey && _this.undoActions.length > 0) {
                var action = _this.undoActions.pop();
                _this.builder.weirdnesses[action.w_idx][2] = action.value;
                _UI__WEBPACK_IMPORTED_MODULE_0__.UI.getInstance().refresh();
            }
        };
    };
    AssignSlicesManager.prototype.hide = function () {
        this.div.classList.add("hidden");
    };
    return AssignSlicesManager;
}());



/***/ }),

/***/ "./src/UI/LayoutEditor.ts":
/*!********************************!*\
  !*** ./src/UI/LayoutEditor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayoutEditor": () => (/* binding */ LayoutEditor)
/* harmony export */ });
/* harmony import */ var _BuilderData_ABBiome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BuilderData/ABBiome */ "./src/BuilderData/ABBiome.ts");
/* harmony import */ var _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BuilderData/Biome */ "./src/BuilderData/Biome.ts");
/* harmony import */ var _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../BuilderData/Layout */ "./src/BuilderData/Layout.ts");
/* harmony import */ var _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../BuilderData/LayoutElementUnassigned */ "./src/BuilderData/LayoutElementUnassigned.ts");
/* harmony import */ var _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../BuilderData/Slice */ "./src/BuilderData/Slice.ts");
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UI */ "./src/UI/UI.ts");






function lerp(a, b, l) {
    return ((1 - l) * a + l * b);
}
var LayoutEditor = /** @class */ (function () {
    function LayoutEditor(builder) {
        var _this = this;
        this.builder = builder;
        this.title = document.getElementById("layoutName");
        this.canvas = document.getElementById("layoutEditorCanvas");
        this.splineCanvas = document.getElementById("splineDisplayCanvas");
        var tooltip = document.getElementById("layoutEditorTooltip");
        var tooltip_name = tooltip.getElementsByClassName("name")[0];
        this.title.onchange = function (evt) {
            _this.layout.name = _this.title.value;
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().refresh();
        };
        this.canvas.onmousemove = function (evt) {
            var renderer = _this.layout.getRenderer();
            _this.mouse_position = _this.getMousePosition(evt);
            var ids = renderer.getIdsFromPosition(0, 0, _this.canvas.width, _this.canvas.height, _this.mouse_position.mouse_x, _this.mouse_position.mouse_y);
            if (ids === undefined) {
                tooltip.classList.add("hidden");
                var spline_ctx = _this.splineCanvas.getContext('2d');
                spline_ctx.clearRect(0, 0, _this.splineCanvas.width, _this.splineCanvas.height);
                return;
            }
            _this.canvas.focus();
            tooltip.style.left = (Math.min(evt.pageX + 20, document.body.clientWidth - tooltip.clientWidth)) + "px";
            tooltip.style.top = (evt.pageY + 15) + "px";
            tooltip.classList.remove("hidden");
            var element = _this.layout.lookup(ids.t_idx, ids.h_idx);
            if (_this.layout instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout) {
                if (element instanceof _BuilderData_ABBiome__WEBPACK_IMPORTED_MODULE_0__.ABElement) {
                    element = element.getElement(ids.mode);
                }
            }
            if (element instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_1__.Biome) {
                tooltip_name.innerHTML = element.name;
            }
            else if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout) {
                tooltip_name.innerHTML = "&crarr; " + element.name + " (Layout)";
            }
            else if (element instanceof _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_3__.LayoutElementUnassigned) {
                tooltip_name.innerHTML = "Unassigned";
            }
            var cont = builder.continentalnesses[ids.t_idx][1];
            var c = lerp(cont.min, cont.max, ids.local_t);
            var ero = builder.erosions[ids.h_idx][1];
            var e = lerp(ero.min, ero.max, ids.local_h);
            if (_this.layout instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_4__.Slice) {
                _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.setPos({ c: c, e: e });
                _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.refresh();
            }
        };
        this.canvas.onmouseleave = function (evt) {
            tooltip.classList.add("hidden");
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.setPos(undefined);
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.refresh();
        };
        this.canvas.onclick = function (evt) {
            var renderer = _this.layout.getRenderer();
            var mouse_position = _this.getMousePosition(evt);
            var ids = renderer.getIdsFromPosition(0, 0, _this.canvas.width, _this.canvas.height, mouse_position.mouse_x, mouse_position.mouse_y);
            if (ids === undefined) {
                return;
            }
            _this.handleInteraction(ids.t_idx, ids.h_idx, ids.mode, evt.ctrlKey ? "add_alt" : evt.altKey ? "pick" : "add");
        };
        this.canvas.onauxclick = function (evt) {
            if (evt.button === 1) {
                var renderer = _this.layout.getRenderer();
                var mouse_position = _this.getMousePosition(evt);
                var ids = renderer.getIdsFromPosition(0, 0, _this.canvas.width, _this.canvas.height, mouse_position.mouse_x, mouse_position.mouse_y);
                if (ids === undefined) {
                    return;
                }
                _this.handleInteraction(ids.t_idx, ids.h_idx, ids.mode, "pick");
            }
        };
        this.canvas.oncontextmenu = function (evt) {
            var renderer = _this.layout.getRenderer();
            var mouse_position = _this.getMousePosition(evt);
            var ids = renderer.getIdsFromPosition(0, 0, _this.canvas.width, _this.canvas.height, mouse_position.mouse_x, mouse_position.mouse_y);
            if (ids === undefined) {
                return;
            }
            _this.handleInteraction(ids.t_idx, ids.h_idx, ids.mode, "open");
            evt.preventDefault();
        };
        this.canvas.onkeydown = function (evt) {
            if (evt.key === "z" && evt.ctrlKey) {
                _this.undo();
                _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().refresh();
            }
        };
        this.canvas.onkeyup = function (evt) {
            if (evt.key === "Delete") {
                var renderer = _this.layout.getRenderer();
                var mouse_position = _this.mouse_position;
                var ids = renderer.getIdsFromPosition(0, 0, _this.canvas.width, _this.canvas.height, mouse_position.mouse_x, mouse_position.mouse_y);
                if (ids === undefined) {
                    return;
                }
                _this.handleInteraction(ids.t_idx, ids.h_idx, ids.mode, "remove");
                evt.preventDefault;
            }
        };
    }
    LayoutEditor.prototype.getMousePosition = function (evt) {
        var rect = this.canvas.getBoundingClientRect();
        var scaleX = this.canvas.width / rect.width;
        var scaleY = this.canvas.height / rect.height;
        var canvasMouseX = (evt.clientX - rect.left) * scaleX;
        var canvasMouseY = (evt.clientY - rect.top) * scaleY;
        return { mouse_x: canvasMouseX, mouse_y: canvasMouseY };
    };
    LayoutEditor.prototype.handleInteraction = function (t_idx, h_idx, mode, action) {
        var element = this.layout.lookup(t_idx, h_idx);
        var exact_element = element;
        if (exact_element instanceof _BuilderData_ABBiome__WEBPACK_IMPORTED_MODULE_0__.ABElement) {
            if (mode === "A") {
                exact_element = this.builder.getLayoutElement(exact_element.elementA);
            }
            else {
                exact_element = this.builder.getLayoutElement(exact_element.elementB);
            }
        }
        var selectedElement = _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().selectedElement;
        if (action === "remove") {
            selectedElement = "unassigned";
            action = "add";
        }
        if (action === "pick") {
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().selectedElement = exact_element.getKey();
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().refresh();
        }
        else if ((action === "add" || action === "add_alt") && selectedElement !== "") {
            //Cycle Check
            var se = this.builder.layoutElements.get(selectedElement);
            if (se instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout && this.layout instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout) {
                this.layout.set(t_idx, h_idx, this.builder.layoutElementDummy.getKey(), false);
                if (se.lookupRecursive(t_idx, h_idx, "A") === this.builder.layoutElementDummy || se.lookupRecursive(t_idx, h_idx, "B") === this.builder.layoutElementDummy) {
                    //Cycle found
                    this.layout.set(t_idx, h_idx, element.getKey(), false);
                    return;
                }
                else {
                    this.layout.set(t_idx, h_idx, element.getKey(), false);
                }
            }
            if (!se && this.builder.vanillaBiomes.has(selectedElement)) {
                this.builder.registerLayoutElement(this.builder.vanillaBiomes.get(selectedElement));
            }
            if (action === "add_alt" && !(element instanceof _BuilderData_ABBiome__WEBPACK_IMPORTED_MODULE_0__.ABElement) && this.layout instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout) {
                // add alternate
                if (mode === "A") {
                    this.layout.set(t_idx, h_idx, selectedElement + "/" + element.getKey());
                }
                else {
                    this.layout.set(t_idx, h_idx, element.getKey() + "/" + selectedElement);
                }
            }
            else {
                if (element instanceof _BuilderData_ABBiome__WEBPACK_IMPORTED_MODULE_0__.ABElement) {
                    if (mode === "A") {
                        if (selectedElement === element.elementB) {
                            this.layout.set(t_idx, h_idx, selectedElement);
                        }
                        else {
                            this.layout.set(t_idx, h_idx, selectedElement + "/" + element.elementB);
                        }
                    }
                    else {
                        if (selectedElement === element.elementA) {
                            this.layout.set(t_idx, h_idx, selectedElement);
                        }
                        else {
                            this.layout.set(t_idx, h_idx, element.elementA + "/" + selectedElement);
                        }
                    }
                }
                else {
                    this.layout.set(t_idx, h_idx, selectedElement);
                }
            }
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().refresh();
        }
        else if (action === "open") {
            // Right mouse button
            // open
            if (exact_element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout) {
                _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().openElement = exact_element.getKey();
                _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().refresh();
            }
        }
    };
    LayoutEditor.prototype.undo = function () {
        this.layout.undo();
    };
    LayoutEditor.prototype.refresh = function () {
        var _this = this;
        this.canvas.classList.remove("hidden");
        this.title.readOnly = false;
        var element = this.builder.getRenderedElement(_UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().openElement);
        if (element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_4__.Slice || element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_2__.Layout)
            this.layout = element;
        this.title.value = this.layout.name;
        if (this.layout instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_4__.Slice) {
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.setWeirdnesses(this.builder.weirdnesses.filter(function (w) { return (w[2] === _this.layout.getKey()); }).map(function (w) { return w[1]; }));
        }
        else {
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.setWeirdnesses([]);
            _UI__WEBPACK_IMPORTED_MODULE_5__.UI.getInstance().splineDisplayManager.setPos(undefined);
        }
        this.layout.getRenderer().draw(this.canvas.getContext('2d'), 0, 0, this.canvas.width, this.canvas.height, -1, -1, true, false);
    };
    LayoutEditor.prototype.hide = function () {
        this.canvas.classList.add("hidden");
    };
    return LayoutEditor;
}());



/***/ }),

/***/ "./src/UI/MenuManager.ts":
/*!*******************************!*\
  !*** ./src/UI/MenuManager.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MenuManager": () => (/* binding */ MenuManager)
/* harmony export */ });
/* harmony import */ var _BuilderData_Exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BuilderData/Exporter */ "./src/BuilderData/Exporter.ts");
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UI */ "./src/UI/UI.ts");


var MenuManager = /** @class */ (function () {
    function MenuManager() {
    }
    MenuManager.createClickHandlers = function () {
        this.loadVanillaButton = document.getElementById('loadVanillaButton');
        this.openButton = document.getElementById('openButton');
        this.saveButton = document.getElementById('saveButton');
        this.exportButton = document.getElementById('exportButton');
        this.loadVanillaButton.onclick = function (evt) {
            fetch('vanilla_overworld_biome_builder.json').then(function (r) { return r.text(); }).then(function (jsonString) {
                _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().builder.loadJSON(JSON.parse(jsonString));
                _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().openElement = "assign_slices";
                _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().refresh();
            });
        };
        this.openButton.onclick = function (evt) {
            var input = document.createElement('input');
            input.type = 'file';
            input.onchange = function (evt) {
                var file = evt.target.files[0];
                var reader = new FileReader();
                reader.readAsText(file, 'UTF-8');
                reader.onload = function (evt) {
                    var jsonString = evt.target.result;
                    _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().builder.loadJSON(JSON.parse(jsonString));
                    _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().openElement = "assign_slices";
                    _UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().refresh();
                };
                console.log(file);
            };
            input.click();
        };
        this.saveButton.onclick = function (evt) {
            var jsonString = JSON.stringify(_UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().builder.toJSON());
            var bb = new Blob([jsonString], { type: 'text/plain' });
            var a = document.createElement('a');
            a.download = 'biome_builder.json';
            a.href = window.URL.createObjectURL(bb);
            a.click();
        };
        this.exportButton.onclick = function (evt) {
            var exporter = new _BuilderData_Exporter__WEBPACK_IMPORTED_MODULE_0__.Exporter(_UI__WEBPACK_IMPORTED_MODULE_1__.UI.getInstance().builder);
            var jsonString = exporter.export();
            var bb = new Blob([jsonString], { type: 'text/plain' });
            var a = document.createElement('a');
            a.download = 'dimension.json';
            a.href = window.URL.createObjectURL(bb);
            a.click();
        };
    };
    return MenuManager;
}());



/***/ }),

/***/ "./src/UI/Renderer/ElementRenderer.ts":
/*!********************************************!*\
  !*** ./src/UI/Renderer/ElementRenderer.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BiomeRenderer": () => (/* binding */ BiomeRenderer),
/* harmony export */   "UnassignedRenderer": () => (/* binding */ UnassignedRenderer),
/* harmony export */   "ABBiomeRenderer": () => (/* binding */ ABBiomeRenderer)
/* harmony export */ });
/* harmony import */ var _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../BuilderData/Biome */ "./src/BuilderData/Biome.ts");
/* harmony import */ var _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../BuilderData/Layout */ "./src/BuilderData/Layout.ts");
/* harmony import */ var _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../BuilderData/LayoutElementUnassigned */ "./src/BuilderData/LayoutElementUnassigned.ts");



var BiomeRenderer = /** @class */ (function () {
    function BiomeRenderer(biome) {
        this.biome = biome;
    }
    BiomeRenderer.prototype.draw = function (ctx, minX, minY, sizeX, sizeY, t_idx, h_idx, indicateRecursive, isIcon) {
        if (indicateRecursive === void 0) { indicateRecursive = true; }
        if (isIcon === void 0) { isIcon = false; }
        ctx.fillStyle = this.biome.color;
        ctx.fillRect(minX, minY, sizeX, sizeY);
    };
    BiomeRenderer.prototype.getIdsFromPosition = function (minX, minY, sizeX, sizeY, x, y) {
        return { t_idx: -1, h_idx: -1, mode: "A" };
    };
    return BiomeRenderer;
}());

var UnassignedRenderer = /** @class */ (function () {
    function UnassignedRenderer() {
    }
    UnassignedRenderer.prototype.draw = function (ctx, minX, minY, sizeX, sizeY, t_idx, h_idx, indicateRecursive, isIcon) {
        if (indicateRecursive === void 0) { indicateRecursive = true; }
        if (isIcon === void 0) { isIcon = false; }
        ctx.fillStyle = "gray";
        ctx.fillRect(minX, minY, sizeX, sizeY);
        ctx.fillStyle = "white";
        ctx.font = (sizeX * 0.75) + 'px serif';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("?", minX + sizeX * 0.5, minY + sizeY * 0.55);
    };
    return UnassignedRenderer;
}());

var ABBiomeRenderer = /** @class */ (function () {
    function ABBiomeRenderer(ab_biome) {
        this.ab_biome = ab_biome;
    }
    ABBiomeRenderer.prototype.draw = function (ctx, minX, minY, sizeX, sizeY, t_idx, h_idx, indicateRecursive, isIcon) {
        if (indicateRecursive === void 0) { indicateRecursive = true; }
        if (isIcon === void 0) { isIcon = false; }
        var isARecursive = this.ab_biome.getElement("A") instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout;
        var isBRecursive = this.ab_biome.getElement("B") instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout;
        var elementA = this.ab_biome.lookupRecursive(t_idx, h_idx, "A");
        if (elementA instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome)
            ctx.fillStyle = elementA.color;
        else if (elementA instanceof _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_2__.LayoutElementUnassigned)
            ctx.fillStyle = "gray";
        ctx.beginPath();
        ctx.moveTo(minX, minY);
        ctx.lineTo(minX + sizeX, minY);
        ctx.lineTo(minX, minY + sizeY);
        ctx.fill();
        if (elementA instanceof _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_2__.LayoutElementUnassigned) {
            ctx.fillStyle = "white";
            ctx.font = (sizeX * 0.5) + 'px serif';
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("?", minX + sizeX * 0.3, minY + sizeY * 0.4);
        }
        if (indicateRecursive && isARecursive) {
            ctx.fillStyle = "rgb(255,255,255,0.8)";
            ctx.beginPath();
            ctx.moveTo(minX, minY);
            ctx.lineTo(minX + sizeX, minY);
            ctx.lineTo(minX, minY + sizeY);
            ctx.fill();
            if (!isIcon) {
                ctx.fillStyle = "rgb(0,0,0,1)";
                ctx.font = '110px serif';
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('', minX + 0.25 * sizeX, minY + 0.33 * sizeY);
            }
        }
        var elementB = this.ab_biome.lookupRecursive(t_idx, h_idx, "B");
        if (elementB instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome)
            ctx.fillStyle = elementB.color;
        else if (elementB instanceof _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_2__.LayoutElementUnassigned)
            ctx.fillStyle = "gray";
        ctx.beginPath();
        ctx.moveTo(minX + sizeX, minY);
        ctx.lineTo(minX + sizeX, minY + sizeY);
        ctx.lineTo(minX, minY + sizeY);
        ctx.fill();
        if (elementB instanceof _BuilderData_LayoutElementUnassigned__WEBPACK_IMPORTED_MODULE_2__.LayoutElementUnassigned) {
            ctx.fillStyle = "white";
            ctx.font = (sizeX * 0.5) + 'px serif';
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("?", minX + sizeX * 0.72, minY + sizeY * 0.75);
        }
        if (indicateRecursive && isBRecursive) {
            ctx.fillStyle = "rgb(255,255,255,0.8)";
            ctx.beginPath();
            ctx.moveTo(minX + sizeX, minY);
            ctx.lineTo(minX + sizeX, minY + sizeY);
            ctx.lineTo(minX, minY + sizeY);
            ctx.fill();
            if (!isIcon) {
                ctx.fillStyle = "rgb(0,0,0,1)";
                ctx.font = '110px serif';
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('', minX + 0.72 * sizeX, minY + 0.8 * sizeY);
            }
        }
        ctx.strokeStyle = "black";
        ctx.lineWidth = sizeX / 30;
        ctx.beginPath();
        ctx.moveTo(minX + sizeX, minY);
        ctx.lineTo(minX, minY + sizeY);
        ctx.stroke();
    };
    return ABBiomeRenderer;
}());



/***/ }),

/***/ "./src/UI/Renderer/LayoutGridRenderer.ts":
/*!***********************************************!*\
  !*** ./src/UI/Renderer/LayoutGridRenderer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayoutGridRenderer": () => (/* binding */ LayoutGridRenderer)
/* harmony export */ });
/* harmony import */ var _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../BuilderData/Layout */ "./src/BuilderData/Layout.ts");

var LayoutGridRenderer = /** @class */ (function () {
    function LayoutGridRenderer(layout) {
        this.layout = layout;
    }
    LayoutGridRenderer.prototype.draw = function (ctx, minX, minY, sizeX, sizeY, _t_idx, _h_idx, indicateRecursive, isIcon) {
        if (_t_idx === void 0) { _t_idx = -1; }
        if (_h_idx === void 0) { _h_idx = -1; }
        if (indicateRecursive === void 0) { indicateRecursive = true; }
        if (isIcon === void 0) { isIcon = false; }
        var size = this.layout.getSize();
        var maxElementSizeX = sizeX / size[1];
        var maxElementSizeY = sizeY / size[0];
        var elementSize = Math.min(maxElementSizeX, maxElementSizeY);
        var xOffset = (elementSize * size[1] - sizeX) / 2 + minX;
        var yOffset = (elementSize * size[0] - sizeY) / 2 + minY;
        ctx.clearRect(minX, minY, sizeX, sizeY);
        for (var t_idx = 0; t_idx < size[0]; t_idx++) {
            for (var h_idx = 0; h_idx < size[1]; h_idx++) {
                var element = this.layout.lookup(t_idx, h_idx);
                if (element === undefined)
                    console.log("undefined at: " + t_idx + ", " + h_idx);
                var isRecursive = false;
                if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_0__.Layout) {
                    element = element.lookupRecursive(t_idx, h_idx, "Any");
                    isRecursive = true;
                }
                element.getRenderer().draw(ctx, xOffset + h_idx * elementSize, yOffset + t_idx * elementSize, elementSize, elementSize, t_idx, h_idx, indicateRecursive, isIcon);
                if (isRecursive && indicateRecursive) {
                    ctx.fillStyle = "rgb(255,255,255,0.8)";
                    ctx.beginPath();
                    ctx.rect(xOffset + h_idx * elementSize, yOffset + t_idx * elementSize, elementSize, elementSize);
                    ctx.fill();
                    if (!isIcon) {
                        ctx.fillStyle = "rgb(0,0,0,1)";
                        ctx.font = '140px serif';
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText('', xOffset + (h_idx + 0.5) * elementSize, yOffset + (t_idx + 0.6) * elementSize);
                    }
                }
                ctx.strokeStyle = "black";
                ctx.lineWidth = elementSize / 30;
                ctx.beginPath();
                ctx.rect(xOffset + h_idx * elementSize, yOffset + t_idx * elementSize, elementSize, elementSize);
                ctx.stroke();
            }
        }
    };
    LayoutGridRenderer.prototype.getIdsFromPosition = function (minX, minY, sizeX, sizeY, x, y) {
        var size = this.layout.getSize();
        var maxElementSizeX = sizeX / size[1];
        var maxElementSizeY = sizeY / size[0];
        var elementSize = Math.min(maxElementSizeX, maxElementSizeY);
        if (x < minX || y < minY || x > minX + size[1] * elementSize || y > minY + size[0] * elementSize)
            return undefined;
        var t_idx = Math.floor((y - minY) / elementSize);
        var h_idx = Math.floor((x - minX) / elementSize);
        var localX = x - minX - (t_idx * elementSize);
        var localY = y - minY - (h_idx * elementSize);
        var mode = localX > elementSize - localY ? "B" : "A";
        return { t_idx: t_idx, h_idx: h_idx, local_t: localX / elementSize, local_h: localY / elementSize, mode: mode };
    };
    return LayoutGridRenderer;
}());



/***/ }),

/***/ "./src/UI/Renderer/SliceGridRenderer.ts":
/*!**********************************************!*\
  !*** ./src/UI/Renderer/SliceGridRenderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SliceGridRenderer": () => (/* binding */ SliceGridRenderer)
/* harmony export */ });
/* harmony import */ var _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../BuilderData/Layout */ "./src/BuilderData/Layout.ts");

var SliceGridRenderer = /** @class */ (function () {
    function SliceGridRenderer(slice) {
        this.slice = slice;
    }
    SliceGridRenderer.prototype.draw = function (ctx, minX, minY, sizeX, sizeY, _t_idx, _h_idx, indicateRecursive, isIcon) {
        if (_t_idx === void 0) { _t_idx = -1; }
        if (_h_idx === void 0) { _h_idx = -1; }
        if (indicateRecursive === void 0) { indicateRecursive = true; }
        if (isIcon === void 0) { isIcon = false; }
        var size = this.slice.getSize();
        var maxElementSizeX = sizeX / size[1];
        var maxElementSizeY = sizeY / size[0];
        var elementSize = Math.min(maxElementSizeX, maxElementSizeY);
        var xOffset = (elementSize * size[1] - sizeX) / 2 + minX;
        var yOffset = (elementSize * size[0] - sizeY) / 2 + minY;
        ctx.clearRect(minX, minY, sizeX, sizeY);
        for (var t_idx = 0; t_idx < size[0]; t_idx++) {
            for (var h_idx = 0; h_idx < size[1]; h_idx++) {
                var element = this.slice.lookup(t_idx, h_idx);
                if (element === undefined)
                    console.log("undefined at: " + t_idx + ", " + h_idx);
                if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_0__.Layout && !isIcon)
                    element.getRenderer().draw(ctx, xOffset + (h_idx + 0.1) * elementSize, yOffset + (t_idx + 0.1) * elementSize, elementSize * 0.8, elementSize * 0.8, t_idx, h_idx, false, true);
                else
                    element.getRenderer().draw(ctx, xOffset + h_idx * elementSize, yOffset + t_idx * elementSize, elementSize, elementSize, t_idx, h_idx, false, true);
                /*
                if (element instanceof Layout && !isIcon) {
                    ctx.fillStyle = "rgb(0,0,0,1)"
                    ctx.font = '60px serif';
                    ctx.textAlign = "center"
                    ctx.textBaseline = "middle"
                    ctx.fillText('', xOffset + (h_idx + 0.5) * elementSize, yOffset + (t_idx + 0.6) * elementSize)
                }*/
                ctx.strokeStyle = "black";
                ctx.lineWidth = elementSize / 30;
                ctx.beginPath();
                ctx.rect(xOffset + h_idx * elementSize, yOffset + t_idx * elementSize, elementSize, elementSize);
                ctx.stroke();
            }
        }
    };
    SliceGridRenderer.prototype.getIdsFromPosition = function (minX, minY, sizeX, sizeY, x, y) {
        var size = this.slice.getSize();
        var maxElementSizeX = sizeX / size[1];
        var maxElementSizeY = sizeY / size[0];
        var elementSize = Math.min(maxElementSizeX, maxElementSizeY);
        if (x < minX || y < minY || x > minX + size[1] * elementSize || y > minY + size[0] * elementSize)
            return undefined;
        var t_idx = Math.floor((y - minY) / elementSize);
        var h_idx = Math.floor((x - minX) / elementSize);
        var localX = x - minX - (h_idx * elementSize);
        var localY = y - minY - (t_idx * elementSize);
        var mode = localX > elementSize - localY ? "B" : "A";
        return { t_idx: t_idx, h_idx: h_idx, local_h: localX / elementSize, local_t: localY / elementSize, mode: mode };
    };
    return SliceGridRenderer;
}());



/***/ }),

/***/ "./src/UI/SidebarManager.ts":
/*!**********************************!*\
  !*** ./src/UI/SidebarManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SidebarManager": () => (/* binding */ SidebarManager)
/* harmony export */ });
/* harmony import */ var _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BuilderData/Biome */ "./src/BuilderData/Biome.ts");
/* harmony import */ var _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BuilderData/Layout */ "./src/BuilderData/Layout.ts");
/* harmony import */ var _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../BuilderData/Slice */ "./src/BuilderData/Slice.ts");
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UI */ "./src/UI/UI.ts");




var SidebarManager = /** @class */ (function () {
    function SidebarManager(builder) {
        this.sidebar = document.getElementById("sidebar_menu");
        this.builder = builder;
    }
    SidebarManager.prototype.refresh = function () {
        var _this = this;
        var _a, _b, _c;
        var lastSearch = (_c = (_b = (_a = this.sidebar.getElementsByClassName("search_bar")) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : "";
        this.sidebar.innerHTML = "";
        this.layout_divs = [];
        this.biome_divs = [];
        // Add Assign splices Button
        var assignSplicesButton = document.createElement("div");
        assignSplicesButton.classList.add("sidebar_entry");
        assignSplicesButton.classList.add("assign_slices_button");
        if (_UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement === "assign_slices") {
            assignSplicesButton.classList.add("open");
        }
        assignSplicesButton.innerHTML = "Assign Slices";
        assignSplicesButton.onclick = function (evt) {
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement = "";
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement = "assign_slices";
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
            evt.preventDefault();
        };
        assignSplicesButton.oncontextmenu = assignSplicesButton.onclick;
        this.sidebar.appendChild(assignSplicesButton);
        // Add spacer
        var spacer0 = document.createElement("div");
        spacer0.classList.add("spacer");
        this.sidebar.appendChild(spacer0);
        // Add Add Button
        var addSlicesButton = document.createElement("div");
        addSlicesButton.classList.add("sidebar_entry");
        addSlicesButton.classList.add("add_layout_button");
        addSlicesButton.innerHTML = "+ Add Slice";
        addSlicesButton.onclick = function (evt) {
            var slice = _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice.create(_this.builder, "New Slice", "unassigned");
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement = slice.getKey();
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
            _this.sidebar.getElementsByClassName("open")[0].scrollIntoView(false);
        };
        this.sidebar.appendChild(addSlicesButton);
        // Add Slices
        this.builder.slices.forEach(function (slice) {
            _this.layout_divs.push(_this.createElementDiv(slice, "slice"));
        });
        // Add spacer
        var spacer1 = document.createElement("div");
        spacer1.classList.add("spacer");
        this.sidebar.appendChild(spacer1);
        // Add Add Button
        var addLayoutButton = document.createElement("div");
        addLayoutButton.classList.add("sidebar_entry");
        addLayoutButton.classList.add("add_layout_button");
        addLayoutButton.innerHTML = "+ Add Layout";
        addLayoutButton.onclick = function (evt) {
            var layout = _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout.create(_this.builder, "New Layout");
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement = layout.getKey();
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
            _this.sidebar.getElementsByClassName("open")[0].scrollIntoView(false);
        };
        this.sidebar.appendChild(addLayoutButton);
        // Layouts
        this.builder.layouts.forEach(function (element) {
            _this.layout_divs.push(_this.createElementDiv(element, "layout"));
        });
        // Add spacer
        var spacer2 = document.createElement("div");
        spacer2.classList.add("spacer");
        this.sidebar.appendChild(spacer2);
        // Add Add Button
        var addBiomeButton = document.createElement("div");
        addBiomeButton.classList.add("sidebar_entry");
        addBiomeButton.classList.add("add_layout_button");
        addBiomeButton.innerHTML = "+ Add Biome";
        addBiomeButton.onclick = function (evt) {
            var biome_name = prompt("Input biome name:", "new:biome");
            if (biome_name === null)
                return;
            var biome = _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome.create(_this.builder, biome_name, "#888888");
            if (_UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement !== "assign_slises")
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement = biome.getKey();
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
        };
        this.sidebar.appendChild(addBiomeButton);
        // Add seachBar
        this.search_bar = document.createElement("input");
        this.search_bar.type = "text";
        this.search_bar.placeholder = "Seach...";
        this.search_bar.value = lastSearch;
        this.search_bar.classList.add("search_bar");
        this.search_bar.oninput = function (evt) {
            _this.updateBiomeSearch();
        };
        this.sidebar.appendChild(this.search_bar);
        // Biomes
        this.builder.biomes.forEach(function (element) {
            var div = _this.createElementDiv(element, "biome");
            _this.biome_divs.push(div);
        });
        var vanilla_label = document.createElement("div");
        vanilla_label.innerHTML = "Unused Vanilla Biomes";
        vanilla_label.classList.add("label");
        this.sidebar.appendChild(vanilla_label);
        // Vanilla Biomes
        this.builder.vanillaBiomes.forEach(function (element) {
            if (_this.builder.layoutElements.has(element.getKey()))
                return;
            var div = _this.createElementDiv(element, "vanilla_biome");
            _this.biome_divs.push(div);
        });
        // Add bottom spacer
        this.bottom_spacer = document.createElement("div");
        this.bottom_spacer.classList.add("spacer");
        this.sidebar.appendChild(this.bottom_spacer);
        this.sidebar.onscroll = function (evt) {
            var bottom_spacer_pos = _this.bottom_spacer.getBoundingClientRect().top - _this.sidebar.getBoundingClientRect().top;
            var bottom_spacer_height = Math.max((_this.sidebar.clientHeight - bottom_spacer_pos - 20), 0);
            _this.bottom_spacer.style.height = bottom_spacer_height + "px";
        };
        this.updateBiomeSearch();
    };
    SidebarManager.prototype.updateBiomeSearch = function () {
        var _this = this;
        this.bottom_spacer.style.height = "10000pt";
        this.biome_divs.forEach(function (div) {
            if (div.getAttribute("key").includes(_this.search_bar.value)) {
                div.classList.remove("hidden");
            }
            else {
                div.classList.add("hidden");
            }
        });
        var bottom_spacer_pos = this.bottom_spacer.getBoundingClientRect().top - this.sidebar.getBoundingClientRect().top;
        var bottom_spacer_height = Math.max((this.sidebar.clientHeight - bottom_spacer_pos - 20), 0);
        this.bottom_spacer.style.height = bottom_spacer_height + "px";
    };
    SidebarManager.prototype.createElementDiv = function (element, c) {
        var _this = this;
        var _a, _b;
        var element_div = document.createElement("div");
        element_div.classList.add("sidebar_entry");
        element_div.classList.add(c);
        element_div.draggable = (c !== "vanilla_biome");
        if (element.getKey() === ((_a = _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance()) === null || _a === void 0 ? void 0 : _a.selectedElement)) {
            element_div.classList.add("selected");
        }
        if (element.getKey() === ((_b = _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance()) === null || _b === void 0 ? void 0 : _b.openElement)) {
            element_div.classList.add("open");
        }
        element_div.setAttribute("key", element.name);
        if (element instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome) {
            var color_input_1 = document.createElement("input");
            color_input_1.classList.add("color_selector");
            color_input_1.type = "color";
            color_input_1.value = element.color;
            //color_input.disabled = !element.allowEdit
            color_input_1.onchange = function (evt) {
                element.color = color_input_1.value;
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
            };
            element_div.appendChild(color_input_1);
        }
        else {
            var layout_canvas = document.createElement("canvas");
            layout_canvas.classList.add("grid");
            layout_canvas.width = 100;
            layout_canvas.height = 100;
            element.getRenderer().draw(layout_canvas.getContext("2d"), 0, 0, 100, 100, -1, -1, false, true);
            element_div.appendChild(layout_canvas);
        }
        var layout_name = document.createElement("span");
        layout_name.innerHTML = element.name;
        layout_name.classList.add("name");
        element_div.appendChild(layout_name);
        if (element.allowEdit) {
            var edit_name_button = document.createElement("img");
            edit_name_button.classList.add("button", "edit");
            edit_name_button.src = "edit-pen.svg";
            edit_name_button.onclick = function (evt) {
                var new_name = prompt("Edit name of " + element.constructor.name, element.name);
                if (new_name === null)
                    return;
                element.name = new_name;
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
                evt.stopPropagation();
            };
            element_div.appendChild(edit_name_button);
        }
        if (c !== "vanilla_biome") {
            var db = document.createElement("img");
            db.classList.add("button", "delete");
            db.src = "trash-bin.svg";
            db.onclick = function (evt) {
                if (!confirm("Deleting " + element.constructor.name + " \"" + element.name + "\""))
                    return;
                if (element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice) {
                    _this.builder.removeSlice(element);
                }
                else {
                    _this.builder.removeLayoutElement(element);
                }
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
                evt.stopPropagation();
            };
            element_div.appendChild(db);
        }
        if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout || element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice) {
            element_div.oncontextmenu = function (evt) {
                if (_UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement === "assign_slices") {
                    _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement = "";
                }
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement = element.getKey();
                if (_UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement === element.getKey()) {
                    _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement = "";
                }
                _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
                evt.preventDefault();
            };
            element_div.ondblclick = element_div.oncontextmenu;
        }
        else if (element instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome && element.allowEdit) {
        }
        element_div.onclick = function (evt) {
            if ((_UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().openElement === "assign_slices") !== (element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice))
                return;
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().selectedElement = element.getKey();
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
            /*
            this.layout_divs.forEach(div => {
                div.classList.toggle("selected", div.getAttribute("key") === UI.getInstance().selectedElement)
            });

            this.biome_divs.forEach(div => {
                div.classList.toggle("selected", div.getAttribute("key") === UI.getInstance().selectedElement)
            });*/
        };
        element_div.ondragstart = function (evt) {
            evt.dataTransfer.setData("type", c);
            evt.dataTransfer.setData("key", element.getKey());
            element_div.classList.add("dragged");
        };
        element_div.ondragend = function (evt) {
            element_div.classList.remove("dragged");
        };
        element_div.ondragover = function (evt) {
            if (evt.dataTransfer.getData("type") === c && evt.dataTransfer.getData("key") !== element.getKey()) {
                var self_id, other_id;
                if (element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice) {
                    self_id = _this.builder.slices.indexOf(element);
                    other_id = _this.builder.slices.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                }
                else if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout) {
                    self_id = _this.builder.layouts.indexOf(element);
                    other_id = _this.builder.layouts.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                }
                else if (element instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome) {
                    self_id = _this.builder.biomes.indexOf(element);
                    other_id = _this.builder.biomes.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                }
                if (self_id < other_id) {
                    element_div.classList.add("dragover_up");
                }
                else {
                    element_div.classList.add("dragover_down");
                }
                evt.preventDefault();
            }
        };
        element_div.ondragleave = function (evt) {
            element_div.classList.remove("dragover_up", "dragover_down");
        };
        element_div.ondrop = function (evt) {
            element_div.classList.remove("dragover_up", "dragover_down");
            var self_id, other_id;
            if (element instanceof _BuilderData_Slice__WEBPACK_IMPORTED_MODULE_2__.Slice) {
                self_id = _this.builder.slices.indexOf(element);
                other_id = _this.builder.slices.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                _this.builder.slices.splice(self_id, 0, _this.builder.slices.splice(other_id, 1)[0]);
            }
            else if (element instanceof _BuilderData_Layout__WEBPACK_IMPORTED_MODULE_1__.Layout) {
                self_id = _this.builder.layouts.indexOf(element);
                other_id = _this.builder.layouts.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                _this.builder.layouts.splice(self_id, 0, _this.builder.layouts.splice(other_id, 1)[0]);
            }
            else if (element instanceof _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome) {
                self_id = _this.builder.biomes.indexOf(element);
                other_id = _this.builder.biomes.findIndex(function (e) { return e.getKey() === evt.dataTransfer.getData("key"); });
                _this.builder.biomes.splice(self_id, 0, _this.builder.biomes.splice(other_id, 1)[0]);
            }
            _UI__WEBPACK_IMPORTED_MODULE_3__.UI.getInstance().refresh();
        };
        this.sidebar.appendChild(element_div);
        return element_div;
    };
    return SidebarManager;
}());



/***/ }),

/***/ "./src/UI/SplineDisplayManager.ts":
/*!****************************************!*\
  !*** ./src/UI/SplineDisplayManager.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplineDisplayManager": () => (/* binding */ SplineDisplayManager)
/* harmony export */ });
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");

var SplineDisplayManager = /** @class */ (function () {
    function SplineDisplayManager(builder) {
        this.builder = builder;
        this.splineCanvas = document.getElementById("splineDisplayCanvas");
        this.weirdnesses = [];
    }
    SplineDisplayManager.prototype.setPos = function (pos) {
        this.pos = pos;
    };
    SplineDisplayManager.prototype.setWeirdnesses = function (weirdnesses) {
        this.weirdnesses = weirdnesses;
    };
    SplineDisplayManager.prototype.refresh = function () {
        var spline_ctx = this.splineCanvas.getContext('2d');
        var scw = this.splineCanvas.width;
        var sch = this.splineCanvas.height;
        spline_ctx.clearRect(0, 0, scw, sch);
        if (this.pos) {
            spline_ctx.fillStyle = "rgb(92, 154, 255)";
            spline_ctx.fillRect(0, 0.8 * sch, scw, 0.2 * sch);
            spline_ctx.fillStyle = "rgb(80,80,80)";
            spline_ctx.beginPath();
            spline_ctx.moveTo(0, sch);
            for (var w = -1; w < 1; w += 0.1) {
                var offset = deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.offset(deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.point(this.pos.c, this.pos.e, w));
                spline_ctx.lineTo((w + 1) * 0.5 * scw, -offset * 0.75 * sch + 0.8 * sch);
            }
            spline_ctx.lineTo(scw, sch);
            spline_ctx.fill();
            spline_ctx.strokeStyle = "rgb(255,0,0)";
            spline_ctx.setLineDash([5, 5]);
            spline_ctx.lineWidth = 3;
            spline_ctx.beginPath();
            for (var w = -1; w < 1; w += 0.1) {
                var factor = deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.factor(deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.point(this.pos.c, this.pos.e, w));
                spline_ctx.lineTo((w + 1) * 0.5 * scw, -(1 / factor) * 50 * sch + sch);
            }
            spline_ctx.stroke();
            spline_ctx.strokeStyle = "rgb(0,0,255)";
            spline_ctx.setLineDash([5, 5]);
            spline_ctx.lineWidth = 3;
            spline_ctx.beginPath();
            for (var w = -1; w < 1; w += 0.1) {
                var peaks = deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.peaks(deepslate__WEBPACK_IMPORTED_MODULE_0__.TerrainShaper.point(this.pos.c, this.pos.e, w));
                spline_ctx.lineTo((w + 1) * 0.5 * scw, -peaks / 100 * sch + sch);
            }
            spline_ctx.stroke();
        }
        spline_ctx.fillStyle = "rgba(255,255,0,0.2)";
        spline_ctx.strokeStyle = "yellow";
        spline_ctx.setLineDash([5, 5]);
        spline_ctx.lineWidth = 1;
        this.weirdnesses.forEach(function (weirdness) {
            spline_ctx.beginPath();
            spline_ctx.rect((weirdness.min + 1) * 0.5 * scw, -2, (weirdness.max - weirdness.min) * 0.5 * scw, sch + 4);
            spline_ctx.stroke();
            spline_ctx.fill();
        });
    };
    return SplineDisplayManager;
}());



/***/ }),

/***/ "./src/UI/UI.ts":
/*!**********************!*\
  !*** ./src/UI/UI.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UI": () => (/* binding */ UI)
/* harmony export */ });
/* harmony import */ var _AssignSlicesManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssignSlicesManager */ "./src/UI/AssignSlicesManager.ts");
/* harmony import */ var _LayoutEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayoutEditor */ "./src/UI/LayoutEditor.ts");
/* harmony import */ var _MenuManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MenuManager */ "./src/UI/MenuManager.ts");
/* harmony import */ var _SidebarManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SidebarManager */ "./src/UI/SidebarManager.ts");
/* harmony import */ var _SplineDisplayManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SplineDisplayManager */ "./src/UI/SplineDisplayManager.ts");





var UI = /** @class */ (function () {
    function UI(builder) {
        this.selectedElement = "";
        UI.instance = this;
        this.openElement = "assign_slices";
        this.builder = builder;
        this.layoutEditor = new _LayoutEditor__WEBPACK_IMPORTED_MODULE_1__.LayoutEditor(builder);
        this.sidebarManager = new _SidebarManager__WEBPACK_IMPORTED_MODULE_3__.SidebarManager(builder);
        this.assignSlicesEditor = new _AssignSlicesManager__WEBPACK_IMPORTED_MODULE_0__.AssignSlicesManager(builder);
        this.splineDisplayManager = new _SplineDisplayManager__WEBPACK_IMPORTED_MODULE_4__.SplineDisplayManager(builder);
        this.refresh();
        _MenuManager__WEBPACK_IMPORTED_MODULE_2__.MenuManager.createClickHandlers();
    }
    UI.create = function (builder) {
        if (UI.instance !== undefined)
            throw new Error("UI instance already exists");
        new UI(builder);
    };
    UI.getInstance = function () {
        return UI.instance;
    };
    UI.prototype.refresh = function () {
        this.sidebarManager.refresh();
        if (this.openElement === "assign_slices") {
            this.layoutEditor.hide();
            this.assignSlicesEditor.refresh();
        }
        else {
            this.assignSlicesEditor.hide();
            this.layoutEditor.refresh();
        }
        this.splineDisplayManager.refresh();
    };
    UI.instance = undefined;
    return UI;
}());



/***/ }),

/***/ "./src/Vanilla/VanillaBiomes.ts":
/*!**************************************!*\
  !*** ./src/Vanilla/VanillaBiomes.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VanillaBiomes": () => (/* binding */ VanillaBiomes)
/* harmony export */ });
/* harmony import */ var _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BuilderData/Biome */ "./src/BuilderData/Biome.ts");

var VanillaBiomes = /** @class */ (function () {
    function VanillaBiomes() {
    }
    VanillaBiomes.registerVanillaBiomes = function (builder) {
        for (var _i = 0, _a = VanillaBiomes.biomes; _i < _a.length; _i++) {
            var biome = _a[_i];
            _BuilderData_Biome__WEBPACK_IMPORTED_MODULE_0__.Biome.create(builder, biome.name, this.colorToHex(biome.r, biome.g, biome.b), undefined, true);
        }
    };
    VanillaBiomes.colorToHex = function (r, g, b) {
        return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
    };
    VanillaBiomes.biomes = [
        { name: "minecraft:ocean", r: 50, g: 50, b: 255 },
        { name: "minecraft:plains", r: 61, g: 196, b: 12 },
        { name: "minecraft:desert", r: 247, g: 237, b: 40 },
        { name: "minecraft:extreme_hills", r: 66, g: 66, b: 66 },
        { name: "minecraft:forest", r: 21, g: 107, b: 23 },
        { name: "minecraft:taiga", r: 105, g: 69, b: 19 },
        { name: "minecraft:swamp", r: 60, g: 130, b: 96 },
        { name: "minecraft:river", r: 53, g: 116, b: 232 },
        { name: "minecraft:nether_wastes", r: 163, g: 62, b: 62 },
        { name: "minecraft:the_end", r: 252, g: 244, b: 121 },
        { name: "minecraft:frozen_ocean", r: 209, g: 237, b: 255 },
        { name: "minecraft:frozen_river", r: 166, g: 212, b: 255 },
        { name: "minecraft:snowy_tundra", r: 239, g: 255, b: 235 },
        { name: "minecraft:snowy_mountains", r: 239, g: 255, b: 235 },
        { name: "minecraft:mushroom_fields", r: 250, g: 145, b: 248 },
        { name: "minecraft:mushroom_field_shore", r: 240, g: 187, b: 252 },
        { name: "minecraft:beach", r: 255, g: 249, b: 138 },
        { name: "minecraft:desert_hills", r: 181, g: 174, b: 33 },
        { name: "minecraft:wooded_hills", r: 17, g: 69, b: 18 },
        { name: "minecraft:taiga_hills", r: 30, g: 69, b: 8 },
        { name: "minecraft:mountain_edge", r: 110, g: 109, b: 109 },
        { name: "minecraft:jungle", r: 45, g: 227, b: 5 },
        { name: "minecraft:jungle_hills", r: 33, g: 184, b: 0 },
        { name: "minecraft:jungle_edge", r: 66, g: 207, b: 35 },
        { name: "minecraft:deep_ocean", r: 5, g: 10, b: 82 },
        { name: "minecraft:stone_shore", r: 166, g: 166, b: 166 },
        { name: "minecraft:snowy_beach", r: 211, g: 212, b: 193 },
        { name: "minecraft:birch_forest", r: 31, g: 145, b: 33 },
        { name: "minecraft:birch_forest_hills", r: 28, g: 97, b: 29 },
        { name: "minecraft:dark_forest", r: 7, g: 46, b: 7 },
        { name: "minecraft:snowy_taiga", r: 179, g: 207, b: 163 },
        { name: "minecraft:snowy_taiga_hills", r: 103, g: 117, b: 95 },
        { name: "minecraft:giant_tree_taiga", r: 46, g: 23, b: 6 },
        { name: "minecraft:giant_tree_taiga_hills", r: 23, g: 15, b: 3 },
        { name: "minecraft:wooded_mountains", r: 37, g: 64, b: 36 },
        { name: "minecraft:savanna", r: 179, g: 242, b: 61 },
        { name: "minecraft:savanna_plateau", r: 132, g: 181, b: 40 },
        { name: "minecraft:badlands", r: 212, g: 82, b: 42 },
        { name: "minecraft:wooded_badlands_plateau", r: 230, g: 171, b: 62 },
        { name: "minecraft:badlands_plateau", r: 120, g: 83, b: 42 },
        { name: "minecraft:small_end_islands", r: 234, g: 247, b: 52 },
        { name: "minecraft:end_midlands", r: 170, g: 179, b: 55 },
        { name: "minecraft:end_highlands", r: 112, g: 117, b: 46 },
        { name: "minecraft:end_barrens", r: 199, g: 204, b: 137 },
        { name: "minecraft:warm_ocean", r: 95, g: 70, b: 224 },
        { name: "minecraft:lukewarm_ocean", r: 80, g: 40, b: 212 },
        { name: "minecraft:cold_ocean", r: 120, g: 188, b: 222 },
        { name: "minecraft:deep_warm_ocean", r: 64, g: 54, b: 99 },
        { name: "minecraft:deep_lukewarm_ocean", r: 49, g: 35, b: 87 },
        { name: "minecraft:deep_cold_ocean", r: 59, g: 84, b: 102 },
        { name: "minecraft:deep_frozen_ocean", r: 116, g: 133, b: 145 },
        { name: "minecraft:the_void", r: 0, g: 0, b: 0 },
        { name: "minecraft:sunflower_plains", r: 198, g: 255, b: 92 },
        { name: "minecraft:desert_lakes", r: 97, g: 179, b: 186 },
        { name: "minecraft:gravelly_hills", r: 85, g: 101, b: 102 },
        { name: "minecraft:flower_forest", r: 172, g: 252, b: 33 },
        { name: "minecraft:taiga_mountains", r: 46, g: 30, b: 8 },
        { name: "minecraft:swamp_hills", r: 32, g: 66, b: 50 },
        { name: "minecraft:ice_spikes", r: 194, g: 237, b: 255 },
        { name: "minecraft:modified_jungle", r: 11, g: 227, b: 37 },
        { name: "minecraft:modified_jungle_edge", r: 71, g: 237, b: 91 },
        { name: "minecraft:tall_birch_forest", r: 31, g: 173, b: 34 },
        { name: "minecraft:tall_birch_hills", r: 4, g: 74, b: 6 },
        { name: "minecraft:dark_forest_hills", r: 0, g: 31, b: 1 },
        { name: "minecraft:snowy_taiga_mountains", r: 74, g: 99, b: 74 },
        { name: "minecraft:giant_spruce_taiga", r: 25, g: 61, b: 15 },
        { name: "minecraft:giant_spruce_taiga_hills", r: 13, g: 36, b: 7 },
        { name: "minecraft:modified_gravelly_mountains", r: 82, g: 89, b: 99 },
        { name: "minecraft:shattered_savanna", r: 171, g: 219, b: 81 },
        { name: "minecraft:shattered_savanna_plateau", r: 124, g: 158, b: 60 },
        { name: "minecraft:eroded_badlands", r: 110, g: 44, b: 24 },
        { name: "minecraft:modified_wooded_badlands_plateau", r: 128, g: 98, b: 54 },
        { name: "minecraft:modified_badlands_plateau", r: 145, g: 101, b: 600 },
        { name: "minecraft:bamboo_jungle", r: 158, g: 224, b: 83 },
        { name: "minecraft:bamboo_jungle_hills", r: 98, g: 140, b: 49 },
        { name: "minecraft:soul_sand_valley", r: 140, g: 132, b: 108 },
        { name: "minecraft:crimson_forest", r: 68, g: 171, b: 171 },
        { name: "minecraft:warped_forest", r: 219, g: 60, b: 46 },
        { name: "minecraft:basalt_deltas", r: 79, g: 73, b: 66 },
        { name: "minecraft:snowy_slopes", r: 140, g: 195, b: 222 },
        { name: "minecraft:lofty_peaks", r: 196, g: 168, b: 193 },
        { name: "minecraft:snowcapped_peaks", r: 200, g: 198, b: 200 },
        { name: "minecraft:stony_peaks", r: 82, g: 92, b: 103 },
        { name: "minecraft:grove", r: 150, g: 150, b: 189 },
        { name: "minecraft:meadow", r: 169, g: 197, b: 80 },
        { name: "minecraft:lush_caves", r: 112, g: 255, b: 79 },
        { name: "minecraft:dripstone_caves", r: 140, g: 124, b: 0 }
    ];
    return VanillaBiomes;
}());



/***/ }),

/***/ "./node_modules/uniqid/index.js":
/*!**************************************!*\
  !*** ./node_modules/uniqid/index.js ***!
  \**************************************/
/***/ ((module) => {

/* 
(The MIT License)
Copyright (c) 2014-2021 Halsz dm <adam@aimform.com>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//  Unique Hexatridecimal ID Generator
// ================================================

//  Dependencies
// ================================================
var pid = typeof process !== 'undefined' && process.pid ? process.pid.toString(36) : '' ;
var address = '';
if(false){ var i, networkInterfaces, mac, os; } 

//  Exports
// ================================================
module.exports = module.exports["default"] = function(prefix, suffix){ return (prefix ? prefix : '') + address + pid + now().toString(36) + (suffix ? suffix : ''); }
module.exports.process = function(prefix, suffix){ return (prefix ? prefix : '') + pid + now().toString(36) + (suffix ? suffix : ''); }
module.exports.time    = function(prefix, suffix){ return (prefix ? prefix : '') + now().toString(36) + (suffix ? suffix : ''); }

//  Helpers
// ================================================
function now(){
    var time = Date.now();
    var last = now.last || time;
    return now.last = time > last ? time : last + 1;
}


/***/ }),

/***/ "./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deflate": () => (/* binding */ Deflate_1),
/* harmony export */   "Inflate": () => (/* binding */ Inflate_1),
/* harmony export */   "constants": () => (/* binding */ constants_1),
/* harmony export */   "default": () => (/* binding */ pako),
/* harmony export */   "deflate": () => (/* binding */ deflate_1),
/* harmony export */   "deflateRaw": () => (/* binding */ deflateRaw_1),
/* harmony export */   "gzip": () => (/* binding */ gzip_1),
/* harmony export */   "inflate": () => (/* binding */ inflate_1),
/* harmony export */   "inflateRaw": () => (/* binding */ inflateRaw_1),
/* harmony export */   "ungzip": () => (/* binding */ ungzip_1)
/* harmony export */ });

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


const deflate$2 = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 30;       /* got a data error -- remain here until reset */
const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;

var pako = {
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");
/* harmony import */ var _BuilderData_BiomeBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BuilderData/BiomeBuilder */ "./src/BuilderData/BiomeBuilder.ts");
/* harmony import */ var _Vanilla_VanillaBiomes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vanilla/VanillaBiomes */ "./src/Vanilla/VanillaBiomes.ts");
/* harmony import */ var _UI_UI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UI/UI */ "./src/UI/UI.ts");




var close_elements = document.getElementsByClassName("closable_vertical");
var _loop_1 = function (i) {
    close_elements[i].getElementsByClassName("button")[0].onclick = function (evt) {
        close_elements[i].classList.toggle("closed");
    };
};
for (var i = 0; i < close_elements.length; i++) {
    _loop_1(i);
}
var continentalnesses = [
    ['Mushroom Field', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.2, -1.05)],
    ['Deep Ocean', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.05, -0.455)],
    ['Ocean', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.455, -0.19)],
    ['Coast', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.19, -0.11)],
    ['Near Inland', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.11, 0.03)],
    ['Mid Inland', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.03, 0.3)],
    ['Far Inland', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.3, 1.0)]
];
var erosions = [
    ['0', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.0, -0.78)],
    ['1', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.78, -0.375)],
    ['2', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.375, -0.2225)],
    ['3', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.2225, 0.05)],
    ['4', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.05, 0.45)],
    ['5', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.45, 0.55)],
    ['6', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.55, 1.0)],
];
var weirdnesses = [
    ['Mid Slice A2', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.0, -0.93333334)],
    ['High Slice A2', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.93333334, -0.7666667)],
    ['Peaks A', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.7666667, -0.56666666)],
    ['High Slice A', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.56666666, -0.4)],
    ['Mid Slice A', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.4, -0.26666668)],
    ['Low Slice A', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.26666668, -0.05)],
    ['Valley', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.05, 0.05)],
    ['Low Slice B', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.05, 0.26666668)],
    ['Mid Slice B', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.26666668, 0.4)],
    ['High Slice B', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.4, 0.56666666)],
    ['Peaks B', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.56666666, 0.7666667)],
    ['High Slice B2', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.7666667, 0.93333334)],
    ['Mid Slice B2', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.93333334, 1.0)],
];
var temperatures = [
    ['forzen', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.0, -0.45)],
    ['cold', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.45, -0.15)],
    ['normal', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.15, 0.2)],
    ['warm', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.2, 0.55)],
    ['hot', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.55, 1.0)],
];
var humidities = [
    ['very dry', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-1.0, -0.3)],
    ['dry', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.3, -0.1)],
    ['normal', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(-0.1, 0.1)],
    ['humid', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.1, 0.3)],
    ['very humid', new deepslate__WEBPACK_IMPORTED_MODULE_0__.Climate.Param(0.3, 1.0)],
];
var builder = new _BuilderData_BiomeBuilder__WEBPACK_IMPORTED_MODULE_1__.BiomeBuilder(continentalnesses, erosions, weirdnesses, temperatures, humidities);
_Vanilla_VanillaBiomes__WEBPACK_IMPORTED_MODULE_2__.VanillaBiomes.registerVanillaBiomes(builder);
_UI_UI__WEBPACK_IMPORTED_MODULE_3__.UI.create(builder);
//const valley_slice = Slice.create(builder, "Valley", 6)
//valley_slice.set(3, 2, "River")
//valley_slice.set(3, 3, "Middle")
//const slice_grid = SliceGrid.createSliceGridHTML(builder, valley_slice)
//document.getElementById("sliceEditor").appendChild(slice_grid)

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDaEQsRUFBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDL0MsRUFBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDL0MsRUFBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDaEQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDbkQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsZ0NBQWdDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDaEUsRUFBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDakQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDckQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDbkQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDL0MsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDckQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDckQsRUFBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDbEQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdEQsRUFBQyxJQUFJLEVBQUUsOEJBQThCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDbEQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDNUQsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsa0NBQWtDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDOUQsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDbEQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDMUQsRUFBQyxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDbEQsRUFBQyxJQUFJLEVBQUUsbUNBQW1DLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDbEUsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDMUQsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDNUQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDcEQsRUFBQyxJQUFJLEVBQUUsMEJBQTBCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdEQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsK0JBQStCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDNUQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDN0QsRUFBQyxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDOUMsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsMEJBQTBCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDcEQsRUFBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdEQsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUsZ0NBQWdDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDOUQsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsaUNBQWlDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDOUQsRUFBQyxJQUFJLEVBQUUsOEJBQThCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDM0QsRUFBQyxJQUFJLEVBQUUsb0NBQW9DLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUM7UUFDaEUsRUFBQyxJQUFJLEVBQUUsdUNBQXVDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDcEUsRUFBQyxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDNUQsRUFBQyxJQUFJLEVBQUUscUNBQXFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDcEUsRUFBQyxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUsNENBQTRDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDMUUsRUFBQyxJQUFJLEVBQUUscUNBQXFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDckUsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsK0JBQStCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDN0QsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDNUQsRUFBQyxJQUFJLEVBQUUsMEJBQTBCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDekQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUM7UUFDdEQsRUFBQyxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDeEQsRUFBQyxJQUFJLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDdkQsRUFBQyxJQUFJLEVBQUUsNEJBQTRCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFH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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxvRUFBb0U7Ozs7O0FBSzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckMsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsUUFBUTtBQUNSO0FB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O0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZTs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEscUNBQXFDOztBQUU3QyxRQUFRLHVDQUF1Qzs7OztBQUkvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeU87Ozs7Ozs7VUNuak56TztVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VB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QUFDO0lBQ3pDLENBQUMsTUFBTSxFQUFFLElBQUksb0RBQWEsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxvREFBYSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztDQUN4QztBQUVELElBQU0sVUFBVSxHQUE4QjtJQUMxQyxDQUFDLFVBQVUsRUFBRSxJQUFJLG9EQUFhLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxDQUFDLEtBQUssRUFBRSxJQUFJLG9EQUFhLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDLFFBQVEsRUFBRSxJQUFJLG9EQUFhLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDeEMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxvREFBYSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDLFlBQVksRUFBRSxJQUFJLG9EQUFhLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0NBQzlDO0FBRUQsSUFBTSxPQUFPLEdBQUcsSUFBSSxtRUFBWSxDQUFDLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFVBQVUsQ0FBQztBQUVwRyx1RkFBbUMsQ0FBQyxPQUFPLENBQUM7QUFFNUMsNkNBQVMsQ0FBQyxPQUFPLENBQUM7QUFFbEIseURBQXlEO0FBQ3pELGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFJbEMseUVBQXlFO0FBQ3pFLGdFQUFnRSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vbm9kZV9tb2R1bGVzL2RlZXBzbGF0ZS9kaXN0L2RlZXBzbGF0ZS5lc20uanMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMy5qcyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci8uL3NyYy9CdWlsZGVyRGF0YS9BQkJpb21lLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL0J1aWxkZXJEYXRhL0Jpb21lLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL0J1aWxkZXJEYXRhL0Jpb21lQnVpbGRlci50cyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci8uL3NyYy9CdWlsZGVyRGF0YS9FeHBvcnRlci50cyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci8uL3NyYy9CdWlsZGVyRGF0YS9MYXlvdXQudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvQnVpbGRlckRhdGEvTGF5b3V0RWxlbWVudER1bW15LnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL0J1aWxkZXJEYXRhL0xheW91dEVsZW1lbnRVbmFzc2lnbmVkLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL0J1aWxkZXJEYXRhL1NsaWNlLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL1VJL0Fzc2lnblNsaWNlc01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVUkvTGF5b3V0RWRpdG9yLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL1VJL01lbnVNYW5hZ2VyLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vc3JjL1VJL1JlbmRlcmVyL0VsZW1lbnRSZW5kZXJlci50cyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci8uL3NyYy9VSS9SZW5kZXJlci9MYXlvdXRHcmlkUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVUkvUmVuZGVyZXIvU2xpY2VHcmlkUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVUkvU2lkZWJhck1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVUkvU3BsaW5lRGlzcGxheU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVUkvVUkudHMiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvVmFuaWxsYS9WYW5pbGxhQmlvbWVzLnRzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyLy4vbm9kZV9tb2R1bGVzL3VuaXFpZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9taW5lY3JhZnQtYmlvbWUtYnVpbGRlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL21pbmVjcmFmdC1iaW9tZS1idWlsZGVyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWluZWNyYWZ0LWJpb21lLWJ1aWxkZXIvLi9zcmMvYXBwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0IGZyb21cInBha29cIjtpbXBvcnR7dmVjMyBhcyBlLG1hdDQgYXMgcyxnbE1hdHJpeCBhcyBpfWZyb21cImdsLW1hdHJpeFwiO3ZhciBuOyFmdW5jdGlvbih0KXt0LlVQPVwidXBcIix0LkRPV049XCJkb3duXCIsdC5OT1JUSD1cIm5vcnRoXCIsdC5FQVNUPVwiZWFzdFwiLHQuU09VVEg9XCJzb3V0aFwiLHQuV0VTVD1cIndlc3RcIn0obnx8KG49e30pKTtjb25zdCByPXtbbi5VUF06WzAsMSwwXSxbbi5ET1dOXTpbMCwtMSwwXSxbbi5OT1JUSF06WzAsMCwtMV0sW24uRUFTVF06WzEsMCwwXSxbbi5TT1VUSF06WzAsMCwxXSxbbi5XRVNUXTpbLTEsMCwwXX07dmFyIG87IWZ1bmN0aW9uKHQpe3QuQUxMPVt0LlVQLHQuRE9XTix0Lk5PUlRILHQuRUFTVCx0LlNPVVRILHQuV0VTVF0sdC5ub3JtYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHJbdF19fShufHwobj17fSkpLGZ1bmN0aW9uKHQpe3QuY3JlYXRlPWZ1bmN0aW9uKHQsZSxzKXtyZXR1cm5bdCxlLHNdfSx0Lm9mZnNldD1mdW5jdGlvbih0LGUscyxpKXtyZXR1cm5bdFswXStlLHRbMV0rcyx0WzJdK2ldfSx0LnRvd2FyZHM9ZnVuY3Rpb24oZSxzKXtyZXR1cm4gdC5vZmZzZXQoZSwuLi5uLm5vcm1hbChzKSl9fShvfHwobz17fSkpO2NvbnN0IGE9e2VuZDowLGJ5dGU6MSxzaG9ydDoyLGludDozLGxvbmc6NCxmbG9hdDo1LGRvdWJsZTo2LGJ5dGVBcnJheTo3LHN0cmluZzo4LGxpc3Q6OSxjb21wb3VuZDoxMCxpbnRBcnJheToxMSxsb25nQXJyYXk6MTJ9LGg9W1wiZW5kXCIsXCJieXRlXCIsXCJzaG9ydFwiLFwiaW50XCIsXCJsb25nXCIsXCJmbG9hdFwiLFwiZG91YmxlXCIsXCJieXRlQXJyYXlcIixcInN0cmluZ1wiLFwibGlzdFwiLFwiY29tcG91bmRcIixcImludEFycmF5XCIsXCJsb25nQXJyYXlcIl07Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGU9ITEpe3RoaXMuYnl0ZT10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0SW50OFwiLDEpLHRoaXMuc2hvcnQ9dGhpcy5yZWFkTnVtLmJpbmQodGhpcyxcImdldEludDE2XCIsMiksdGhpcy5pbnQ9dGhpcy5yZWFkTnVtLmJpbmQodGhpcyxcImdldEludDMyXCIsNCksdGhpcy5mbG9hdD10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0RmxvYXQzMlwiLDQpLHRoaXMuZG91YmxlPXRoaXMucmVhZE51bS5iaW5kKHRoaXMsXCJnZXRGbG9hdDY0XCIsOCksdGhpcy5vZmZzZXQ9MCx0aGlzLmxpdHRsZUVuZGlhbj1lLHRoaXMuYXJyYXlWaWV3PXQsdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0KX1lbmQoKXtyZXR1cm4gbnVsbH1yZWFkTnVtKHQsZSl7Y29uc3Qgcz10aGlzLmRhdGFWaWV3W3RdKHRoaXMub2Zmc2V0LHRoaXMubGl0dGxlRW5kaWFuKTtyZXR1cm4gdGhpcy5vZmZzZXQrPWUsc31sb25nKCl7cmV0dXJuW3RoaXMuaW50KCksdGhpcy5pbnQoKV19Ynl0ZUFycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5ieXRlKCkpO3JldHVybiBlfWludEFycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5pbnQoKSk7cmV0dXJuIGV9bG9uZ0FycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5sb25nKCkpO3JldHVybiBlfXN0cmluZygpe2NvbnN0IHQ9dGhpcy5zaG9ydCgpLGU9dGhpcy5hcnJheVZpZXcuc2xpY2UodGhpcy5vZmZzZXQsdGhpcy5vZmZzZXQrdCk7cmV0dXJuIHRoaXMub2Zmc2V0Kz10LGZ1bmN0aW9uKHQpe3ZhciBlLHM9W107Zm9yKGU9MDtlPHQubGVuZ3RoO2UrKykwPT0oMTI4JnRbZV0pP3MucHVzaCgxMjcmdFtlXSk6ZSsxPHQubGVuZ3RoJiYxOTI9PSgyMjQmdFtlXSkmJjEyOD09KDE5MiZ0W2UrMV0pP3MucHVzaCgoMzEmdFtlXSk8PDZ8NjMmdFtlKzFdKTplKzI8dC5sZW5ndGgmJjIyND09KDI0MCZ0W2VdKSYmMTI4PT0oMTkyJnRbZSsxXSkmJjEyOD09KDE5MiZ0W2UrMl0pP3MucHVzaCgoMTUmdFtlXSk8PDEyfCg2MyZ0W2UrMV0pPDw2fDYzJnRbZSsyXSk6ZSszPHQubGVuZ3RoJiYyNDA9PSgyNDgmdFtlXSkmJjEyOD09KDE5MiZ0W2UrMV0pJiYxMjg9PSgxOTImdFtlKzJdKSYmMTI4PT0oMTkyJnRbZSszXSkmJnMucHVzaCgoNyZ0W2VdKTw8MTh8KDYzJnRbZSsxXSk8PDEyfCg2MyZ0W2UrMl0pPDw2fDYzJnRbZSszXSk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxzKX0oZSl9bGlzdCgpe2NvbnN0IHQ9aFt0aGlzLmJ5dGUoKV0sZT10aGlzLmludCgpLHM9W107Zm9yKGxldCBpPTA7aTxlO2krKylzLnB1c2godGhpc1t0XSgpKTtyZXR1cm57dHlwZTp0LHZhbHVlOnN9fWNvbXBvdW5kKCl7Y29uc3QgdD17fTtmb3IoOzspe2NvbnN0IGU9aFt0aGlzLmJ5dGUoKV07aWYoXCJlbmRcIj09PWUpYnJlYWs7Y29uc3Qgcz10aGlzLnN0cmluZygpLGk9dGhpc1tlXSgpO3Rbc109e3R5cGU6ZSx2YWx1ZTppfX1yZXR1cm4gdH19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0PSExKXt0aGlzLmJ5dGU9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRJbnQ4XCIsMSksdGhpcy5zaG9ydD10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEludDE2XCIsMiksdGhpcy5pbnQ9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRJbnQzMlwiLDQpLHRoaXMuZmxvYXQ9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRGbG9hdDMyXCIsNCksdGhpcy5kb3VibGU9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRGbG9hdDY0XCIsOCksdGhpcy5vZmZzZXQ9MCx0aGlzLmxpdHRsZUVuZGlhbj10LHRoaXMuYnVmZmVyPW5ldyBBcnJheUJ1ZmZlcigxMDI0KSx0aGlzLmFycmF5Vmlldz1uZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciksdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpfWFjY29tbW9kYXRlKHQpe2NvbnN0IGU9dGhpcy5vZmZzZXQrdDtpZih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoPj1lKXJldHVybjtsZXQgcz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2Zvcig7czxlOylzKj0yO2NvbnN0IGk9bmV3IEFycmF5QnVmZmVyKHMpLG49bmV3IFVpbnQ4QXJyYXkoaSk7bi5zZXQodGhpcy5hcnJheVZpZXcpLHRoaXMub2Zmc2V0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgmJm4uZmlsbCgwLHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsdGhpcy5vZmZzZXQpLHRoaXMuYnVmZmVyPWksdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcoaSksdGhpcy5hcnJheVZpZXc9bn1nZXREYXRhKCl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMCksdGhpcy5hcnJheVZpZXcuc2xpY2UoMCx0aGlzLm9mZnNldCl9ZW5kKHQpe313cml0ZU51bSh0LGUscyl7dGhpcy5hY2NvbW1vZGF0ZShlKSx0aGlzLmRhdGFWaWV3W3RdKHRoaXMub2Zmc2V0LHMsdGhpcy5saXR0bGVFbmRpYW4pLHRoaXMub2Zmc2V0Kz1lfWxvbmcodCl7dGhpcy5pbnQodFswXSksdGhpcy5pbnQodFsxXSl9Ynl0ZUFycmF5KHQpe3RoaXMuaW50KHQubGVuZ3RoKSx0aGlzLmFjY29tbW9kYXRlKHQubGVuZ3RoKSx0aGlzLmFycmF5Vmlldy5zZXQodCx0aGlzLm9mZnNldCksdGhpcy5vZmZzZXQrPXQubGVuZ3RofWludEFycmF5KHQpe3RoaXMuaW50KHQubGVuZ3RoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmludCh0W2VdKX1sb25nQXJyYXkodCl7dGhpcy5pbnQodC5sZW5ndGgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMubG9uZyh0W2VdKX1zdHJpbmcodCl7Y29uc3QgZT1mdW5jdGlvbih0KXt2YXIgZSxzLGk9W107Zm9yKGU9MDtlPHQubGVuZ3RoO2UrKykocz10LmNoYXJDb2RlQXQoZSkpPDEyOD9pLnB1c2gocyk6czwyMDQ4PyhpLnB1c2goMTkyfHM+PjYpLGkucHVzaCgxMjh8NjMmcykpOnM8NjU1MzY/KGkucHVzaCgyMjR8cz4+MTIpLGkucHVzaCgxMjh8cz4+NiY2MyksaS5wdXNoKDEyOHw2MyZzKSk6KGkucHVzaCgyNDB8cz4+MTgmNyksaS5wdXNoKDEyOHxzPj4xMiY2MyksaS5wdXNoKDEyOHxzPj42JjYzKSxpLnB1c2goMTI4fDYzJnMpKTtyZXR1cm4gaX0odCk7dGhpcy5zaG9ydChlLmxlbmd0aCksdGhpcy5hY2NvbW1vZGF0ZShlLmxlbmd0aCksdGhpcy5hcnJheVZpZXcuc2V0KGUsdGhpcy5vZmZzZXQpLHRoaXMub2Zmc2V0Kz1lLmxlbmd0aH1saXN0KHQpe3RoaXMuYnl0ZShhW3QudHlwZV0pLHRoaXMuaW50KHQudmFsdWUubGVuZ3RoKSx0LnZhbHVlO2ZvcihsZXQgZT0wO2U8dC52YWx1ZS5sZW5ndGg7ZSsrKXRoaXNbdC50eXBlXSh0LnZhbHVlW2VdKX1jb21wb3VuZCh0KXtmb3IoY29uc3QgZSBpbiB0KXRoaXMuYnl0ZShhW3RbZV0udHlwZV0pLHRoaXMuc3RyaW5nKGUpLHRoaXNbdFtlXS50eXBlXSh0W2VdLnZhbHVlKTt0aGlzLmJ5dGUoYS5lbmQpfX1mdW5jdGlvbiB1KHQsZSl7Y29uc3Qgcz1uZXcgbCh0LGUpO2lmKHMuYnl0ZSgpIT09YS5jb21wb3VuZCl0aHJvdyBuZXcgRXJyb3IoXCJUb3AgdGFnIHNob3VsZCBiZSBhIGNvbXBvdW5kXCIpO3JldHVybntuYW1lOnMuc3RyaW5nKCksdmFsdWU6cy5jb21wb3VuZCgpfX1mdW5jdGlvbiBkKGUscyl7cmV0dXJuIHUodC5pbmZsYXRlKGUpLHMpfWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4gMj09PShzPW5ldyBVaW50OEFycmF5KHQuc2xpY2UoMCwyKSkpLmxlbmd0aCYmMzE9PT1zWzBdJiYxMzk9PT1zWzFdP3tjb21wcmVzc2VkOiEwLHJlc3VsdDpkKHQsZSl9Ontjb21wcmVzc2VkOiExLHJlc3VsdDp1KHQsZSl9O3ZhciBzfWZ1bmN0aW9uIGcodCl7Y29uc3QgZT1bXTtmb3IobGV0IHM9MDtzPDMyO3MrPTEpZm9yKGxldCBpPTA7aTwzMjtpKz0xKXtjb25zdCBuPTQqKCgzMSZzKSszMiooMzEmaSkpO2lmKDA9PT10W24rM10pY29udGludWU7Y29uc3Qgcj0odFtuXTw8MTYpKyh0W24rMV08PDgpK3RbbisyXSxvPSh0W24rNDA5Nl08PDI0KSsodFtuKzQwOTddPDwxNikrKHRbbis0MDk4XTw8OCkrdFtuKzQwOTldLGE9NDA5NipyLGg9KHRbYV08PDI0KSsodFthKzFdPDwxNikrKHRbYSsyXTw8OCkrdFthKzNdLGw9dFthKzRdLGM9dC5zbGljZShhKzUsYSs0K2gpO2UucHVzaCh7eDpzLHo6aSx0aW1lc3RhbXA6byxjb21wcmVzc2lvbjpsLGRhdGE6Y30pfXJldHVybiBlfWZ1bmN0aW9uIHAodCxlLHMpe2NvbnN0IGk9eCh0LGUscyk7c3dpdGNoKGkuY29tcHJlc3Npb24pe2Nhc2UgMTpjYXNlIDI6aS5uYnQ9ZChpLmRhdGEpO2JyZWFrO2Nhc2UgMzppLm5idD11KGkuZGF0YSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29tcHJlc3Npb24gbW9kZSAke2kuY29tcHJlc3Npb259YCl9cmV0dXJuIGl9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IHM9bmV3IGMoZSk7cmV0dXJuIHMuYnl0ZShhLmNvbXBvdW5kKSxzLnN0cmluZyh0Lm5hbWUpLHMuY29tcG91bmQodC52YWx1ZSkscy5nZXREYXRhKCl9ZnVuY3Rpb24gdihlLHMsaSl7Y29uc3Qgbj1tKGUscyk7cmV0dXJuIHRbaT9cImRlZmxhdGVcIjpcImd6aXBcIl0obil9ZnVuY3Rpb24gdyh0LGUscyl7cmV0dXJuIGU/dih0LHMpOm0odCxzKX1mdW5jdGlvbiBiKHQpe2xldCBlPTA7Zm9yKGNvbnN0IHMgb2YgdCllKz1NYXRoLmNlaWwocy5kYXRhLmxlbmd0aC80MDk2KTtjb25zdCBzPW5ldyBVaW50OEFycmF5KDgxOTIrNDA5NiplKSxpPW5ldyBEYXRhVmlldyhzLmJ1ZmZlcik7bGV0IG49Mjtmb3IoY29uc3QgZSBvZiB0KXtjb25zdCB0PTQqKCgzMSZlLngpKzMyKigzMSZlLnopKSxyPU1hdGguY2VpbChlLmRhdGEubGVuZ3RoLzQwOTYpO2kuc2V0SW50OCh0LG4+PjE2KSxpLnNldEludDE2KHQrMSw2NTUzNSZuKSxpLnNldEludDgodCszLHIpLGkuc2V0SW50MzIodCs0MDk2LGUudGltZXN0YW1wKTtjb25zdCBvPTQwOTYqbjtpLnNldEludDMyKG8sZS5kYXRhLmxlbmd0aCsxKSxpLnNldEludDgobys0LGUuY29tcHJlc3Npb24pLHMuc2V0KGUuZGF0YSxvKzUpLG4rPXJ9cmV0dXJuIHN9ZnVuY3Rpb24gUCh0LGUscyxpKXtjb25zdCBuPXgodCxlLHMpO3N3aXRjaChuLmNvbXByZXNzaW9uKXtjYXNlIDE6bi5kYXRhPXYoaSk7YnJlYWs7Y2FzZSAyOm4uZGF0YT12KGksITEsITApO2JyZWFrO2Nhc2UgMzpuLmRhdGE9bShpKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wcmVzc2lvbiBtb2RlICR7bi5jb21wcmVzc2lvbn1gKX1yZXR1cm4gbn1mdW5jdGlvbiB4KHQsZSxzKXtjb25zdCBpPXQuZmluZCgodD0+dC54PT09ZSYmdC56PT09cykpO2lmKHZvaWQgMD09PWkpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBjaHVuayBbJHtlfSwgJHtzfV1gKTtyZXR1cm4gaX1mdW5jdGlvbiB5KHQsZSxzKXtpZighdFtlXSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgJHtlfSB0YWdgKTtpZih0W2VdLnR5cGUhPT1zKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtlfSB0byBiZSBvZiB0eXBlICR7c30sIGJ1dCBmb3VuZCAke3RbZV0udHlwZX1gKTtyZXR1cm4gdFtlXS52YWx1ZX1mdW5jdGlvbiBBKHQsZSxzLGkpe2NvbnN0IG49eSh0LGUsXCJsaXN0XCIpO2lmKG4udHlwZSE9PXMpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V9IHRvIGJlIGEgbGlzdCBvZiAke3N9cywgYnV0IGZvdW5kICR7bi50eXBlfXNgKTtpZihpJiZuLnZhbHVlLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V9IHRvIGJlIGEgbGlzdCBvZiBsZW5ndGggJHtpfSwgYnV0IGZvdW5kIGxlbmd0aCAke24udmFsdWUubGVuZ3RofWApO3JldHVybiBuLnZhbHVlfWZ1bmN0aW9uIFModCxlKXt0cnl7cmV0dXJuIHQoKX1jYXRjaCh0KXtyZXR1cm4gZX19Y2xhc3MgQntjb25zdHJ1Y3Rvcih0LGU9e30pe3RoaXMubmFtZT10LHRoaXMucHJvcGVydGllcz1lfWdldE5hbWUoKXtyZXR1cm4gdGhpcy5uYW1lfWdldFByb3BlcnRpZXMoKXtyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzfWdldFByb3BlcnR5KHQpe3JldHVybiB0aGlzLnByb3BlcnRpZXNbdF19aXNGbHVpZCgpe3JldHVyblwibWluZWNyYWZ0OndhdGVyXCI9PT10aGlzLm5hbWV8fFwibWluZWNyYWZ0OmxhdmFcIj09PXRoaXMubmFtZX1lcXVhbHModCl7cmV0dXJuIHRoaXMubmFtZT09PXQubmFtZSYmT2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKS5ldmVyeSgoZT0+dC5wcm9wZXJ0aWVzW2VdPT09dGhpcy5wcm9wZXJ0aWVzW2VdKSl9dG9TdHJpbmcoKXtyZXR1cm4gMD09PU9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcykubGVuZ3RoP3RoaXMubmFtZTpgJHt0aGlzLm5hbWV9WyR7T2JqZWN0LmVudHJpZXModGhpcy5wcm9wZXJ0aWVzKS5tYXAoKChbdCxlXSk9PnQrXCI9XCIrZSkpLmpvaW4oXCIsXCIpfV1gfXN0YXRpYyBmcm9tTmJ0KHQpe2NvbnN0IGU9eSh0LnZhbHVlLFwiTmFtZVwiLFwic3RyaW5nXCIpLHM9UygoKCk9PnkodC52YWx1ZSxcIlByb3BlcnRpZXNcIixcImNvbXBvdW5kXCIpKSx7fSksaT1PYmplY3Qua2V5cyhzKS5yZWR1Y2UoKCh0LGUpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tlXTp5KHMsZSxcInN0cmluZ1wiKX0pKSx7fSk7cmV0dXJuIG5ldyBCKGUsaSl9fUIuQUlSPW5ldyBCKFwibWluZWNyYWZ0OmFpclwiKTtjbGFzcyBFe2NvbnN0cnVjdG9yKHQpe3RoaXMubWluWT10LHRoaXMuc3RvcmFnZT1BcnJheShFLlNJWkUpLHRoaXMucGFsZXR0ZT1bQi5BSVJdfWdldCBtaW5CbG9ja1koKXtyZXR1cm4gdGhpcy5taW5ZPDw0fWluZGV4KHQsZSxzKXtyZXR1cm4odDw8OCkrKGU8PDQpK3N9Z2V0QmxvY2tTdGF0ZSh0LGUscyl7dmFyIGk7Y29uc3Qgbj10aGlzLnN0b3JhZ2VbdGhpcy5pbmRleCh0LGUscyldO3JldHVybiBudWxsIT09KGk9dGhpcy5wYWxldHRlW25dKSYmdm9pZCAwIT09aT9pOkIuQUlSfXNldEJsb2NrU3RhdGUodCxlLHMsaSl7bGV0IG49dGhpcy5wYWxldHRlLmZpbmRJbmRleCgodD0+dC5lcXVhbHMoaSkpKTstMT09PW4mJihuPXRoaXMucGFsZXR0ZS5sZW5ndGgsdGhpcy5wYWxldHRlLnB1c2goaSkpLHRoaXMuc3RvcmFnZVt0aGlzLmluZGV4KHQsZSxzKV09bn19RS5XSURUSD0xNixFLlNJWkU9RS5XSURUSCpFLldJRFRIKkUuV0lEVEg7Y2xhc3MgQ3tjb25zdHJ1Y3Rvcih0LGUscyl7dGhpcy5taW5ZPXQsdGhpcy5oZWlnaHQ9ZSx0aGlzLnBvcz1zLHRoaXMuc2VjdGlvbnM9QXJyYXkodGhpcy5zZWN0aW9uc0NvdW50KS5maWxsKG51bGwpfWdldCBtYXhZKCl7cmV0dXJuIHRoaXMubWluWSt0aGlzLmhlaWdodH1nZXQgbWluU2VjdGlvbigpe3JldHVybiB0aGlzLm1pblk+PjR9Z2V0IG1heFNlY3Rpb24oKXtyZXR1cm4gMSsodGhpcy5tYXhZLTE+PjQpfWdldCBzZWN0aW9uc0NvdW50KCl7cmV0dXJuIHRoaXMubWF4U2VjdGlvbi10aGlzLm1pblNlY3Rpb259Z2V0U2VjdGlvbkluZGV4KHQpe3JldHVybih0Pj40KS10aGlzLm1pblNlY3Rpb259Z2V0QmxvY2tTdGF0ZSh0KXt2YXIgZTtjb25zdFtzLGksbl09dCxyPXRoaXMuc2VjdGlvbnNbdGhpcy5nZXRTZWN0aW9uSW5kZXgoaSldO3JldHVybiBudWxsIT09KGU9bnVsbD09cj92b2lkIDA6ci5nZXRCbG9ja1N0YXRlKDE1JnMsMTUmaSwxNSZuKSkmJnZvaWQgMCE9PWU/ZTpCLkFJUn1zZXRCbG9ja1N0YXRlKHQsZSl7Y29uc3RbcyxpLG5dPXQscj10aGlzLmdldFNlY3Rpb25JbmRleChpKTtsZXQgbz10aGlzLnNlY3Rpb25zW3JdO2lmKG51bGw9PT1vKXtpZihlLmVxdWFscyhCLkFJUikpcmV0dXJuO289dGhpcy5nZXRPckNyZWF0ZVNlY3Rpb24ocil9by5zZXRCbG9ja1N0YXRlKDE1JnMsMTUmaSwxNSZuLGUpfWdldE9yQ3JlYXRlU2VjdGlvbih0KXtyZXR1cm4gbnVsbD09dGhpcy5zZWN0aW9uc1t0XSYmKHRoaXMuc2VjdGlvbnNbdF09bmV3IEUodGhpcy5taW5TZWN0aW9uK3QpKSx0aGlzLnNlY3Rpb25zW3RdfX12YXIgazshZnVuY3Rpb24odCl7dC5jcmVhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm5bdCxlXX0sdC5mcm9tQmxvY2tQb3M9ZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0+PjQsdFsyXT4+NF19LHQuZnJvbUxvbmc9ZnVuY3Rpb24odCl7cmV0dXJuWzQyOTQ5NjcyOTUmTnVtYmVyKHQpLE51bWJlcih0Pj5CaWdJbnQoMzIpKV19LHQubWluQmxvY2tYPWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPDw0fSx0Lm1pbkJsb2NrWj1mdW5jdGlvbih0KXtyZXR1cm4gdFsxXTw8NH0sdC5tYXhCbG9ja1g9ZnVuY3Rpb24odCl7cmV0dXJuIHRbMF08PDE5fSx0Lm1heEJsb2NrWj1mdW5jdGlvbih0KXtyZXR1cm4gdFsxXTw8MTl9fShrfHwoaz17fSkpO2NsYXNzIEl7Y29uc3RydWN0b3IodCxlPVtdLHM9W10pe3RoaXMuc2l6ZT10LHRoaXMucGFsZXR0ZT1lLHRoaXMuYmxvY2tzPXMsdGhpcy5ibG9ja3NNYXA9W10scy5mb3JFYWNoKChlPT57aWYoIXRoaXMuaXNJbnNpZGUoZS5wb3MpKXRocm93IG5ldyBFcnJvcihgRm91bmQgYmxvY2sgYXQgJHtlLnBvc30gd2hpY2ggaXMgb3V0c2lkZSB0aGUgc3RydWN0dXJlIGJvdW5kcyAke3RoaXMuc2l6ZX1gKTt0aGlzLmJsb2Nrc01hcFtlLnBvc1swXSp0WzFdKnRbMl0rZS5wb3NbMV0qdFsyXStlLnBvc1syXV09ZX0pKX1nZXRTaXplKCl7cmV0dXJuIHRoaXMuc2l6ZX1hZGRCbG9jayh0LGUscyxpKXtpZighdGhpcy5pc0luc2lkZSh0KSl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgYmxvY2sgYXQgJHt0fSBvdXRzaWRlIHRoZSBzdHJ1Y3R1cmUgYm91bmRzICR7dGhpcy5zaXplfWApO2NvbnN0IG49bmV3IEIoZSxzKTtsZXQgcj10aGlzLnBhbGV0dGUuZmluZEluZGV4KCh0PT50LmVxdWFscyhuKSkpO3JldHVybi0xPT09ciYmKHI9dGhpcy5wYWxldHRlLmxlbmd0aCx0aGlzLnBhbGV0dGUucHVzaChuKSksdGhpcy5ibG9ja3MucHVzaCh7cG9zOnQsc3RhdGU6cixuYnQ6aX0pLHRoaXMuYmxvY2tzTWFwW3RbMF0qdGhpcy5zaXplWzFdKnRoaXMuc2l6ZVsyXSt0WzFdKnRoaXMuc2l6ZVsyXSt0WzJdXT17cG9zOnQsc3RhdGU6cixuYnQ6aX0sdGhpc31nZXRCbG9ja3MoKXtyZXR1cm4gdGhpcy5ibG9ja3MubWFwKCh0PT4oe3Bvczp0LnBvcyxzdGF0ZTp0aGlzLnBhbGV0dGVbdC5zdGF0ZV0sbmJ0OnQubmJ0fSkpKX1nZXRCbG9jayh0KXtpZighdGhpcy5pc0luc2lkZSh0KSlyZXR1cm4gbnVsbDtjb25zdCBlPXRoaXMuYmxvY2tzTWFwW3RbMF0qdGhpcy5zaXplWzFdKnRoaXMuc2l6ZVsyXSt0WzFdKnRoaXMuc2l6ZVsyXSt0WzJdXTtpZighZSlyZXR1cm4gbnVsbDtyZXR1cm57cG9zOmUucG9zLHN0YXRlOnRoaXMucGFsZXR0ZVtlLnN0YXRlXSxuYnQ6ZS5uYnR9fWlzSW5zaWRlKHQpe3JldHVybiB0WzBdPj0wJiZ0WzBdPHRoaXMuc2l6ZVswXSYmdFsxXT49MCYmdFsxXTx0aGlzLnNpemVbMV0mJnRbMl0+PTAmJnRbMl08dGhpcy5zaXplWzJdfXN0YXRpYyBmcm9tTmJ0KHQpe2NvbnN0IGU9QSh0LnZhbHVlLFwic2l6ZVwiLFwiaW50XCIsMykscz1BKHQudmFsdWUsXCJwYWxldHRlXCIsXCJjb21wb3VuZFwiKS5tYXAoKHQ9PkIuZnJvbU5idCh7bmFtZTpcIlwiLHZhbHVlOnR9KSkpLGk9QSh0LnZhbHVlLFwiYmxvY2tzXCIsXCJjb21wb3VuZFwiKS5tYXAoKHQ9Pih7cG9zOkEodCxcInBvc1wiLFwiaW50XCIsMyksc3RhdGU6eSh0LFwic3RhdGVcIixcImludFwiKSxuYnQ6UygoKCk9PnkodCxcIm5idFwiLFwiY29tcG91bmRcIikpLHZvaWQgMCl9KSkpO3JldHVybiBuZXcgSShlLHMsaSl9fWZ1bmN0aW9uIFIodCl7cmV0dXJuIHQqdH1mdW5jdGlvbiBGKHQsZSxzKXtyZXR1cm4gTWF0aC5tYXgoZSxNYXRoLm1pbihzLHQpKX1mdW5jdGlvbiBNKHQsZSxzKXtyZXR1cm4gZSt0KihzLWUpfWZ1bmN0aW9uIFQodCxlLHMsaSxuLHIpe3JldHVybiBNKGUsTSh0LHMsaSksTSh0LG4scikpfWZ1bmN0aW9uIE4odCxlLHMsaSxuLHIsbyxhLGgsbCxjKXtyZXR1cm4gTShzLFQodCxlLGksbixyLG8pLFQodCxlLGEsaCxsLGMpKX1mdW5jdGlvbiBfKHQsZSxzKXtyZXR1cm4gczwwP3Q6cz4xP2U6TShzLHQsZSl9ZnVuY3Rpb24gVSh0KXtyZXR1cm4gdCp0KnQqKHQqKDYqdC0xNSkrMTApfWZ1bmN0aW9uIEQodCxlLHMpe2xldCBpPWUtdDtmb3IoO2k+MDspe2NvbnN0IGU9TWF0aC5mbG9vcihpLzIpLG49dCtlO3Mobik/aT1lOih0PW4rMSxpLT1lKzEpfXJldHVybiB0fWNsYXNzIE97Y29uc3RydWN0b3IodCl7dGhpcy54bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy55bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy56bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy5wPUFycmF5KDI1Nik7Zm9yKGxldCB0PTA7dDwyNTY7dCs9MSl0aGlzLnBbdF09dDtmb3IobGV0IGU9MDtlPDI1NjtlKz0xKXtjb25zdCBzPXQubmV4dEludCgyNTYtZSksaT10aGlzLnBbZV07dGhpcy5wW2VdPXRoaXMucFtlK3NdLHRoaXMucFtlK3NdPWl9fXNhbXBsZTJEKHQsZSl7bGV0IHMsaSxuO2NvbnN0IHI9KHQrZSkqTy5GMixvPU1hdGguZmxvb3IodCtyKSxhPXQtKG8tKHM9KG8rKGk9TWF0aC5mbG9vcihlK3IpKSkqTy5HMikpO2xldCBoLGw7YT4obj1lLShpLXMpKT8oaD0xLGw9MCk6KGg9MCxsPTEpO2NvbnN0IGM9YS1oK08uRzIsdT1uLWwrTy5HMixkPWEtMSsyKk8uRzIsZj1uLTErMipPLkcyLGc9MjU1Jm8scD0yNTUmaSxtPXRoaXMuUChnK3RoaXMuUChwKSklMTIsdj10aGlzLlAoZytoK3RoaXMuUChwK2wpKSUxMix3PXRoaXMuUChnKzErdGhpcy5QKHArMSkpJTEyO3JldHVybiA3MCoodGhpcy5nZXRDb3JuZXJOb2lzZTNEKG0sYSxuLDAsLjUpK3RoaXMuZ2V0Q29ybmVyTm9pc2UzRCh2LGMsdSwwLC41KSt0aGlzLmdldENvcm5lck5vaXNlM0QodyxkLGYsMCwuNSkpfXNhbXBsZSh0LGUscyl7Y29uc3QgaT0uMzMzMzMzMzMzMzMzMzMzMyoodCtlK3MpLG49TWF0aC5mbG9vcih0K2kpLHI9TWF0aC5mbG9vcihlK2kpLG89TWF0aC5mbG9vcihzK2kpLGE9LjE2NjY2NjY2NjY2NjY2NjY2KihuK3IrbyksaD10LShuLWEpLGw9ZS0oci1hKSxjPXMtKG8tYSk7bGV0IHUsZCxmLGcscCxtO2g+PWw/bD49Yz8odT0xLGQ9MCxmPTAsZz0xLHA9MSxtPTApOmg+PWM/KHU9MSxkPTAsZj0wLGc9MSxwPTAsbT0xKToodT0wLGQ9MCxmPTEsZz0xLHA9MCxtPTEpOmw8Yz8odT0wLGQ9MCxmPTEsZz0wLHA9MSxtPTEpOmg8Yz8odT0wLGQ9MSxmPTAsZz0wLHA9MSxtPTEpOih1PTAsZD0xLGY9MCxnPTEscD0xLG09MCk7Y29uc3Qgdj1oLXUrLjE2NjY2NjY2NjY2NjY2NjY2LHc9bC1kKy4xNjY2NjY2NjY2NjY2NjY2NixiPWMtZisuMTY2NjY2NjY2NjY2NjY2NjYsUD1oLWcrLjMzMzMzMzMzMzMzMzMzMzMseD1sLXArLjMzMzMzMzMzMzMzMzMzMzMseT1jLW0rLjMzMzMzMzMzMzMzMzMzMzMsQT1oLS41LFM9bC0uNSxCPWMtLjUsRT0yNTUmbixDPTI1NSZyLGs9MjU1Jm8sST10aGlzLlAoRSt0aGlzLlAoQyt0aGlzLlAoaykpKSUxMixSPXRoaXMuUChFK3UrdGhpcy5QKEMrZCt0aGlzLlAoaytmKSkpJTEyLEY9dGhpcy5QKEUrZyt0aGlzLlAoQytwK3RoaXMuUChrK20pKSklMTIsTT10aGlzLlAoRSsxK3RoaXMuUChDKzErdGhpcy5QKGsrMSkpKSUxMjtyZXR1cm4gMzIqKHRoaXMuZ2V0Q29ybmVyTm9pc2UzRChJLGgsbCxjLC42KSt0aGlzLmdldENvcm5lck5vaXNlM0QoUix2LHcsYiwuNikrdGhpcy5nZXRDb3JuZXJOb2lzZTNEKEYsUCx4LHksLjYpK3RoaXMuZ2V0Q29ybmVyTm9pc2UzRChNLEEsUyxCLC42KSl9UCh0KXtyZXR1cm4gdGhpcy5wWzI1NSZ0XX1nZXRDb3JuZXJOb2lzZTNEKHQsZSxzLGksbil7bGV0IHIsbz1uLWUqZS1zKnMtaSppO3JldHVybiBvPDA/cj0wOihvKj1vLHI9bypvKk8uZ3JhZERvdCh0LGUscyxpKSkscn1zdGF0aWMgZ3JhZERvdCh0LGUscyxpKXtjb25zdCBuPU8uR1JBRElFTlRbMTUmdF07cmV0dXJuIG5bMF0qZStuWzFdKnMrblsyXSppfX1PLkdSQURJRU5UPVtbMSwxLDBdLFstMSwxLDBdLFsxLC0xLDBdLFstMSwtMSwwXSxbMSwwLDFdLFstMSwwLDFdLFsxLDAsLTFdLFstMSwwLC0xXSxbMCwxLDFdLFswLC0xLDFdLFswLDEsLTFdLFswLC0xLC0xXSxbMSwxLDBdLFswLC0xLDFdLFstMSwxLDBdLFswLC0xLC0xXV0sTy5GMj0uNSooTWF0aC5zcXJ0KDMpLTEpLE8uRzI9KDMtTWF0aC5zcXJ0KDMpKS82O2NsYXNzIEx7Y29uc3RydWN0b3IodCl7dGhpcy54bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy55bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy56bz0yNTYqdC5uZXh0RG91YmxlKCksdGhpcy5wPUFycmF5KDI1Nik7Zm9yKGxldCB0PTA7dDwyNTY7dCs9MSl0aGlzLnBbdF09dD4xMjc/dC0yNTY6dDtmb3IobGV0IGU9MDtlPDI1NjtlKz0xKXtjb25zdCBzPXQubmV4dEludCgyNTYtZSksaT10aGlzLnBbZV07dGhpcy5wW2VdPXRoaXMucFtlK3NdLHRoaXMucFtlK3NdPWl9fXNhbXBsZSh0LGUscyxpPTAsbj0wKXtjb25zdCByPXQrdGhpcy54byxvPWUrdGhpcy55byxhPXMrdGhpcy56byxoPU1hdGguZmxvb3IociksbD1NYXRoLmZsb29yKG8pLGM9TWF0aC5mbG9vcihhKSx1PXItaCxkPW8tbCxmPWEtYztsZXQgZz0wO2lmKDAhPT1pKXtjb25zdCB0PW4+PTAmJm48ZD9uOmQ7Zz1NYXRoLmZsb29yKHQvaSsxZS03KSppfXJldHVybiB0aGlzLnNhbXBsZUFuZExlcnAoaCxsLGMsdSxkLWcsZixkKX1zYW1wbGVBbmRMZXJwKHQsZSxzLGksbixyLG8pe2NvbnN0IGE9dGhpcy5QKHQpLGg9dGhpcy5QKHQrMSksbD10aGlzLlAoYStlKSxjPXRoaXMuUChhK2UrMSksdT10aGlzLlAoaCtlKSxkPXRoaXMuUChoK2UrMSksZj1PLmdyYWREb3QodGhpcy5QKGwrcyksaSxuLHIpLGc9Ty5ncmFkRG90KHRoaXMuUCh1K3MpLGktMSxuLHIpLHA9Ty5ncmFkRG90KHRoaXMuUChjK3MpLGksbi0xLHIpLG09Ty5ncmFkRG90KHRoaXMuUChkK3MpLGktMSxuLTEsciksdj1PLmdyYWREb3QodGhpcy5QKGwrcysxKSxpLG4sci0xKSx3PU8uZ3JhZERvdCh0aGlzLlAodStzKzEpLGktMSxuLHItMSksYj1PLmdyYWREb3QodGhpcy5QKGMrcysxKSxpLG4tMSxyLTEpLFA9Ty5ncmFkRG90KHRoaXMuUChkK3MrMSksaS0xLG4tMSxyLTEpO3JldHVybiBOKFUoaSksVShvKSxVKHIpLGYsZyxwLG0sdix3LGIsUCl9UCh0KXtyZXR1cm4gMjU1JnRoaXMucFsyNTUmdF19fWNsYXNzIFZ7Y29uc3RydWN0b3IodCxlLHMpe2lmKDEtZTxzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGl2ZSBvY3RhdmVzIGFyZSBub3QgYWxsb3dlZFwiKTt0aGlzLm5vaXNlTGV2ZWxzPUFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9LWU7aT49MDtpLT0xKWk8cy5sZW5ndGgmJjAhPT1zW2ldP3RoaXMubm9pc2VMZXZlbHNbaV09bmV3IEwodCk6dC5jb25zdW1lKDI2Mik7dGhpcy5hbXBsaXR1ZGVzPXMsdGhpcy5sb3dlc3RGcmVxSW5wdXRGYWN0b3I9TWF0aC5wb3coMixlKSx0aGlzLmxvd2VzdEZyZXFWYWx1ZUZhY3Rvcj1NYXRoLnBvdygyLHMubGVuZ3RoLTEpLyhNYXRoLnBvdygyLHMubGVuZ3RoKS0xKX1zYW1wbGUodCxlLHMsaT0wLG49MCxyPSExKXtsZXQgbz0wLGE9dGhpcy5sb3dlc3RGcmVxSW5wdXRGYWN0b3IsaD10aGlzLmxvd2VzdEZyZXFWYWx1ZUZhY3Rvcjtmb3IobGV0IGw9MDtsPHRoaXMubm9pc2VMZXZlbHMubGVuZ3RoO2wrPTEpe2NvbnN0IGM9dGhpcy5ub2lzZUxldmVsc1tsXTtjJiYobys9dGhpcy5hbXBsaXR1ZGVzW2xdKmgqYy5zYW1wbGUoVi53cmFwKHQqYSkscj8tYy55bzpWLndyYXAoZSphKSxWLndyYXAocyphKSxpKmEsbiphKSksYSo9MixoLz0yfXJldHVybiBvfWdldE9jdGF2ZU5vaXNlKHQpe3JldHVybiB0aGlzLm5vaXNlTGV2ZWxzW3RoaXMubm9pc2VMZXZlbHMubGVuZ3RoLTEtdF19c3RhdGljIHdyYXAodCl7cmV0dXJuIHQtMzM1NTQ0MzIqTWF0aC5mbG9vcih0LzMzNTU0NDMyKy41KX19Y2xhc3Mgentjb25zdHJ1Y3Rvcih0KXt0aGlzLm1pbkxpbWl0Tm9pc2U9bmV3IFYodCwtMTUsWzEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdKSx0aGlzLm1heExpbWl0Tm9pc2U9bmV3IFYodCwtMTUsWzEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdKSx0aGlzLm1haW5Ob2lzZT1uZXcgVih0LC03LFsxLDEsMSwxLDEsMCwwLDBdKX1zYW1wbGUodCxlLHMsaSxuLHIsbyl7bGV0IGEsaD0wLGw9MTtmb3IobGV0IGk9MDtpPDg7aSs9MSl7aWYoYT10aGlzLm1haW5Ob2lzZS5nZXRPY3RhdmVOb2lzZShpKSxhKXtjb25zdCBpPXIqbCxuPW8qbCxjPVYud3JhcCh0KmkpLHU9Vi53cmFwKGUqbiksZD1WLndyYXAocyppKTtoKz1hLnNhbXBsZShjLHUsZCxuLGUqbikvbH1sLz0yfWg9KGgvMTArMSkvMixsPTE7bGV0IGM9MCx1PTA7Zm9yKGxldCByPTA7cjwxNjtyKz0xKXtjb25zdCBvPWkqbCxkPW4qbCxmPVYud3JhcCh0Km8pLGc9Vi53cmFwKGUqZCkscD1WLndyYXAocypvKTtoPDEmJihhPXRoaXMubWluTGltaXROb2lzZS5nZXRPY3RhdmVOb2lzZShyKSkmJihjKz1hLnNhbXBsZShmLGcscCxkLGUqZCkvbCksaD4wJiYoYT10aGlzLm1heExpbWl0Tm9pc2UuZ2V0T2N0YXZlTm9pc2UocikpJiYodSs9YS5zYW1wbGUoZixnLHAsZCxlKmQpL2wpLGwvPTJ9cmV0dXJuIF8oYy81MTIsdS81MTIsaCl9fWNsYXNzIFl7Y29uc3RydWN0b3IodCxlLHMpe3RoaXMuZmlyc3Q9bmV3IFYodCxlLHMpLHRoaXMuc2Vjb25kPW5ldyBWKHQsZSxzKTtsZXQgaT0xLzAsbj0tMS8wO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGg7dCs9MSkwIT09c1t0XSYmKGk9TWF0aC5taW4oaSx0KSxuPU1hdGgubWF4KG4sdCkpO2NvbnN0IHI9LjEqKDErMS8obi1pKzEpKTt0aGlzLnZhbHVlRmFjdG9yPTEvNi9yfXNhbXBsZSh0LGUscyl7Y29uc3QgaT10KlkuSU5QVVRfRkFDVE9SLG49ZSpZLklOUFVUX0ZBQ1RPUixyPXMqWS5JTlBVVF9GQUNUT1I7cmV0dXJuKHRoaXMuZmlyc3Quc2FtcGxlKHQsZSxzKSt0aGlzLnNlY29uZC5zYW1wbGUoaSxuLHIpKSp0aGlzLnZhbHVlRmFjdG9yfX1ZLklOUFVUX0ZBQ1RPUj0xLjAxODEyNjg4ODIxNzUyMjc7Y2xhc3MgWHtjb25zdHJ1Y3Rvcih0LGUpe2NvbnN0IHM9ZVtlLmxlbmd0aC0xXSxpPS1lWzBdK3MrMSxuPW5ldyBTZXQoZSkscj1uZXcgTyh0KTt0aGlzLm5vaXNlTGV2ZWxzPUFycmF5KGkpLHM+PTAmJnM8aSYmbi5oYXMoMCkmJih0aGlzLm5vaXNlTGV2ZWxzW3NdPXIpO2ZvcihsZXQgZT1zKzE7ZTxpO2UrPTEpZT49MCYmbi5oYXMocy1lKT90aGlzLm5vaXNlTGV2ZWxzW2VdPW5ldyBPKHQpOnQuY29uc3VtZSgyNjIpO2lmKHM+MCl0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGl2ZSBvY3RhdmVzIGFyZSBub3QgYWxsb3dlZFwiKTt0aGlzLmhpZ2hlc3RGcmVxSW5wdXRGYWN0b3I9TWF0aC5wb3coMixzKSx0aGlzLmhpZ2hlc3RGcmVxVmFsdWVGYWN0b3I9MS8oTWF0aC5wb3coMixpKS0xKX1zYW1wbGUodCxlLHMpe2xldCBpPTAsbj10aGlzLmhpZ2hlc3RGcmVxSW5wdXRGYWN0b3Iscj10aGlzLmhpZ2hlc3RGcmVxVmFsdWVGYWN0b3I7Zm9yKGxldCBvPTA7bzx0aGlzLm5vaXNlTGV2ZWxzLmxlbmd0aDtvKz0xKXtjb25zdCBhPXRoaXMubm9pc2VMZXZlbHNbb107YSYmKGkrPXIqYS5zYW1wbGUyRCh0Km4rKHM/YS54bzowKSxlKm4rKHM/YS55bzowKSkpLG4vPTIscio9Mn1yZXR1cm4gaX19Y2xhc3MgSHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlZWQ9QmlnSW50KDApLHRoaXMuc2V0U2VlZCh0KX1zZXRTZWVkKHQpe3RoaXMuc2VlZD10XkguTVVMVElQTElFUiZILk1PRFVMVVNfTUFTS31hZHZhbmNlKCl7dGhpcy5zZWVkPXRoaXMuc2VlZCpILk1VTFRJUExJRVIrSC5JTkNSRU1FTlQmSC5NT0RVTFVTX01BU0t9Y29uc3VtZSh0KXtmb3IobGV0IGU9MDtlPHQ7ZSs9MSl0aGlzLmFkdmFuY2UoKX1uZXh0KHQpe3RoaXMuYWR2YW5jZSgpO2NvbnN0IGU9TnVtYmVyKHRoaXMuc2VlZD4+QmlnSW50KEguTU9EVUxVU19CSVRTLXQpKTtyZXR1cm4gZT4yMTQ3NDgzNjQ3P2UtNDI5NDk2NzI5NjplfW5leHRJbnQodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5uZXh0KDMyKTtpZigwPT0odCZ0LTEpKXJldHVybiBOdW1iZXIoQmlnSW50KHQpKkJpZ0ludCh0aGlzLm5leHQoMzEpKT4+QmlnSW50KDMxKSk7bGV0IGUscztmb3IoOyhlPXRoaXMubmV4dCgzMSkpLShzPWUldCkrKHQtMSk8MDspO3JldHVybiBzfW5leHRGbG9hdCgpe3JldHVybiB0aGlzLm5leHQoMjQpKkguRkxPQVRfTVVMVElQTElFUn1uZXh0RG91YmxlKCl7Y29uc3QgdD10aGlzLm5leHQoMzApO3JldHVybiB0aGlzLmFkdmFuY2UoKSx0KkguRE9VQkxFX01VTFRJUExJRVJ9fUguTU9EVUxVU19CSVRTPTQ4LEguTU9EVUxVU19NQVNLPUJpZ0ludChcIjI4MTQ3NDk3NjcxMDY1NVwiKSxILk1VTFRJUExJRVI9QmlnSW50KFwiMjUyMTQ5MDM5MTdcIiksSC5JTkNSRU1FTlQ9QmlnSW50KFwiMTFcIiksSC5GTE9BVF9NVUxUSVBMSUVSPTEvTWF0aC5wb3coMiwyNCksSC5ET1VCTEVfTVVMVElQTElFUj0xL01hdGgucG93KDIsMzApO2NsYXNzIFcgZXh0ZW5kcyBIe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvdW50PTB9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5jb3VudH1uZXh0KHQpe3JldHVybiB0aGlzLmNvdW50Kz0xLHN1cGVyLm5leHQodCl9fWNsYXNzIFp7Y29uc3RydWN0b3IodCxlLHM9W10saT1bXSxuPVtdKXt0aGlzLm5hbWU9dCx0aGlzLmNvb3JkaW5hdGU9ZSx0aGlzLmxvY2F0aW9ucz1zLHRoaXMudmFsdWVzPWksdGhpcy5kZXJpdmF0aXZlcz1ufWFwcGx5KHQpe2NvbnN0IGU9dGhpcy5jb29yZGluYXRlKHQpLHM9RCgwLHRoaXMubG9jYXRpb25zLmxlbmd0aCwodD0+ZTx0aGlzLmxvY2F0aW9uc1t0XSkpLTEsaT10aGlzLmxvY2F0aW9ucy5sZW5ndGgtMTtpZihzPDApcmV0dXJuIHRoaXMudmFsdWVzWzBdKHQpK3RoaXMuZGVyaXZhdGl2ZXNbMF0qKGUtdGhpcy5sb2NhdGlvbnNbMF0pO2lmKHM9PT1pKXJldHVybiB0aGlzLnZhbHVlc1tpXSh0KSt0aGlzLmRlcml2YXRpdmVzW2ldKihlLXRoaXMubG9jYXRpb25zW2ldKTtjb25zdCBuPXRoaXMubG9jYXRpb25zW3NdLHI9dGhpcy5sb2NhdGlvbnNbcysxXSxvPXRoaXMuZGVyaXZhdGl2ZXNbc10sYT10aGlzLmRlcml2YXRpdmVzW3MrMV0saD0oZS1uKS8oci1uKSxsPXRoaXMudmFsdWVzW3NdKHQpLGM9dGhpcy52YWx1ZXNbcysxXSh0KSx1PW8qKHItbiktKGMtbCksZD0tYSooci1uKSsoYy1sKTtyZXR1cm4gTShoLGwsYykraCooMS1oKSpNKGgsdSxkKX1hZGRQb2ludCh0LGUscz0wKXtyZXR1cm4gdGhpcy5sb2NhdGlvbnMucHVzaCh0KSx0aGlzLnZhbHVlcy5wdXNoKFwibnVtYmVyXCI9PXR5cGVvZiBlPygpPT5lOmUuYXBwbHkuYmluZChlKSksdGhpcy5kZXJpdmF0aXZlcy5wdXNoKHMpLHRoaXN9fW5ldyBaKFwiYVwiLCgoKT0+MSksW10sW10sW10pO2NvbnN0IGo9dD0+Wyh0Pj4xNiYyNTUpLzI1NiwodD4+OCYyNTUpLzI1NiwoMjU1JnQpLzI1Nl0sJD1bMTI0LzI1NiwxODkvMjU2LDEwNy8yNTZdLEc9aig2Mzk2MjU3KSxxPWooODQzMTQ0NSksSz1qKDQ3NjQ5NTIpLEo9aig0MTU5MjA0KSxRPWooODQzMTQ0NSksdHQ9aigyMTI5OTY4KSxldD10PT5bdC84LDEtdC8zMiw2NCp0XSxzdD17bGFyZ2VfZmVybjooKT0+JCx0YWxsX2dyYXNzOigpPT4kLGdyYXNzX2Jsb2NrOigpPT4kLGZlcm46KCk9PiQsZ3Jhc3M6KCk9PiQscG90dGVkX2Zlcm46KCk9PiQsc3BydWNlX2xlYXZlczooKT0+RyxiaXJjaF9sZWF2ZXM6KCk9PnEsb2FrX2xlYXZlczooKT0+SyxqdW5nbGVfbGVhdmVzOigpPT5LLGFjYWNpYV9sZWF2ZXM6KCk9PkssZGFya19vYWtfbGVhdmVzOigpPT5LLHZpbmU6KCk9Pkssd2F0ZXI6KCk9PkosYnViYmxlX2NvbHVtbjooKT0+SixjYXVsZHJvbjooKT0+SixyZWRzdG9uZV93aXJlOnQ9Pnt2YXIgZTtyZXR1cm4odD0+e2NvbnN0IGU9dC8xNTtyZXR1cm5bLjYqZSsoZT4wPy40Oi4zKSxGKGUqZSouNy0uNSwwLDEpLEYoZSplKi42LS43LDAsMSldfSkocGFyc2VJbnQobnVsbCE9PShlPXQucG93ZXIpJiZ2b2lkIDAhPT1lP2U6XCIwXCIpKX0sc3VnYXJfY2FuZTooKT0+JCxhdHRhY2hlZF9tZWxvbl9zdGVtOigpPT5RLGF0dGFjaGVkX3B1bXBraW5fc3RlbTooKT0+USxtZWxvbl9zdGVtOnQ9Pnt2YXIgZTtyZXR1cm4gZXQocGFyc2VJbnQobnVsbCE9PShlPXQuYWdlKSYmdm9pZCAwIT09ZT9lOlwiMFwiKSl9LHB1bXBraW5fc3RlbTp0PT57dmFyIGU7cmV0dXJuIGV0KHBhcnNlSW50KG51bGwhPT0oZT10LmFnZSkmJnZvaWQgMCE9PWU/ZTpcIjBcIikpfSxsaWx5X3BhZDooKT0+dHR9O3ZhciBpdDtmdW5jdGlvbiBudCguLi50KXtsZXQgZT0wO2Zvcihjb25zdCBzIG9mIHQpZSs9cy5sZW5ndGg7Y29uc3Qgcz1uZXcgRmxvYXQzMkFycmF5KGUpO2xldCBpPTA7Zm9yKGNvbnN0IGUgb2YgdClzLnNldChlLGkpLGkrPWUubGVuZ3RoO3JldHVybiBzfWZ1bmN0aW9uIHJ0KHQscyl7Y29uc3QgaT1lLmNyZWF0ZSgpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bis9MylpWzBdPXRbbl0saVsxXT10W24rMV0saVsyXT10W24rMl0sZS50cmFuc2Zvcm1NYXQ0KGksaSxzKSx0W25dPWlbMF0sdFtuKzFdPWlbMV0sdFtuKzJdPWlbMl19IWZ1bmN0aW9uKHQpe3Qucm90YXRlPWZ1bmN0aW9uKHQsZSxzKXtsZXR7dXA6aSxkb3duOm4sbm9ydGg6cixlYXN0Om8sc291dGg6YSx3ZXN0Omh9PXQ7c3dpdGNoKHMpe2Nhc2UgOTA6W3IsbyxhLGhdPVtvLGEsaCxyXTticmVhaztjYXNlIDE4MDpbcixvLGEsaF09W2EsaCxyLG9dO2JyZWFrO2Nhc2UgMjcwOltyLG8sYSxoXT1baCxyLG8sYV19c3dpdGNoKGUpe2Nhc2UgOTA6W2kscixuLGFdPVtyLG4sYSxpXTticmVhaztjYXNlIDE4MDpbaSxyLG4sYV09W24sYSxpLHJdO2JyZWFrO2Nhc2UgMjcwOltpLHIsbixhXT1bYSxpLHIsbl19cmV0dXJue3VwOmksZG93bjpuLG5vcnRoOnIsZWFzdDpvLHNvdXRoOmEsd2VzdDpofX19KGl0fHwoaXQ9e30pKTtjbGFzcyBvdHtjb25zdHJ1Y3Rvcih0LGUscyl7dGhpcy5pZD10LHRoaXMudmFyaWFudHM9ZSx0aGlzLm11bHRpcGFydD1zLHRoaXMudmFyaWFudHM9ZX1nZXRNb2RlbFZhcmlhbnRzKHQpe2lmKHRoaXMudmFyaWFudHMpe2NvbnN0IGU9T2JqZWN0LmtleXModGhpcy52YXJpYW50cykuZmlsdGVyKChlPT50aGlzLm1hdGNoZXNWYXJpYW50KGUsdCkpKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuW107Y29uc3Qgcz10aGlzLnZhcmlhbnRzW2VbMF1dO3JldHVybltBcnJheS5pc0FycmF5KHMpP3NbMF06c119aWYodGhpcy5tdWx0aXBhcnQpe3JldHVybiB0aGlzLm11bHRpcGFydC5maWx0ZXIoKGU9PiFlLndoZW58fHRoaXMubWF0Y2hlc0Nhc2UoZS53aGVuLHQpKSkubWFwKCh0PT5BcnJheS5pc0FycmF5KHQuYXBwbHkpP3QuYXBwbHlbMF06dC5hcHBseSkpfXJldHVybltdfWdldEJ1ZmZlcnModCxlLG4scixvLGEpe3ZhciBoLGwsYyx1O2NvbnN0IGQ9dGhpcy5nZXRNb2RlbFZhcmlhbnRzKGUpLGY9W10sZz1bXSxwPVtdLG09W107Zm9yKGNvbnN0IHYgb2YgZCl7Y29uc3QgZD1pdC5yb3RhdGUoYSxudWxsIT09KGg9di54KSYmdm9pZCAwIT09aD9oOjAsbnVsbCE9PShsPXYueSkmJnZvaWQgMCE9PWw/bDowKSx3PXIuZ2V0QmxvY2tNb2RlbCh2Lm1vZGVsKS5nZXRCdWZmZXJzKHQsZSxuLG8sZCk7aWYodi54fHx2Lnkpe2NvbnN0IHQ9cy5jcmVhdGUoKTtzLmlkZW50aXR5KHQpLHMudHJhbnNsYXRlKHQsdCxbOCw4LDhdKSxzLnJvdGF0ZVkodCx0LC1pLnRvUmFkaWFuKG51bGwhPT0oYz12LnkpJiZ2b2lkIDAhPT1jP2M6MCkpLHMucm90YXRlWCh0LHQsLWkudG9SYWRpYW4obnVsbCE9PSh1PXYueCkmJnZvaWQgMCE9PXU/dTowKSkscy50cmFuc2xhdGUodCx0LFstOCwtOCwtOF0pLHJ0KHcucG9zaXRpb24sdCl9Zi5wdXNoKHcucG9zaXRpb24pLGcucHVzaCguLi53LnRleENvb3JkKSxwLnB1c2goLi4udy50aW50Q29sb3IpLG0ucHVzaCguLi53LmluZGV4KSxvKz13LnRleENvb3JkLmxlbmd0aC8yfWNvbnN0IHY9cy5jcmVhdGUoKTtzLmlkZW50aXR5KHYpLHMuc2NhbGUodix2LFsuMDYyNSwuMDYyNSwuMDYyNV0pO2NvbnN0IHc9bnQoLi4uZik7cmV0dXJuIHJ0KHcsdikse3Bvc2l0aW9uOncsdGV4Q29vcmQ6Zyx0aW50Q29sb3I6cCxpbmRleDptfX1tYXRjaGVzVmFyaWFudCh0LGUpe3JldHVybiB0LnNwbGl0KFwiLFwiKS5ldmVyeSgodD0+e2NvbnN0W3MsaV09dC5zcGxpdChcIj1cIik7cmV0dXJuIGVbc109PT1pfSkpfW1hdGNoZXNDYXNlKHQsZSl7aWYoQXJyYXkuaXNBcnJheSh0Lk9SKSlyZXR1cm4gdC5PUi5zb21lKCh0PT50aGlzLm1hdGNoZXNDYXNlKHQsZSkpKTtjb25zdCBzPXQ7cmV0dXJuIE9iamVjdC5rZXlzKHMpLmV2ZXJ5KCh0PT5zW3RdLnNwbGl0KFwifFwiKS5pbmNsdWRlcyhlW3RdKSkpfXN0YXRpYyBmcm9tSnNvbih0LGUpe3JldHVybiBuZXcgb3QodCxlLnZhcmlhbnRzLGUubXVsdGlwYXJ0KX19Y29uc3QgYXQ9ezA6WzAsMywyLDMsMiwxLDAsMV0sOTA6WzIsMywyLDEsMCwxLDAsM10sMTgwOlsyLDEsMCwxLDAsMywyLDNdLDI3MDpbMCwxLDAsMywyLDMsMiwxXX0saHQ9e3g6WzEsMCwwXSx5OlswLDEsMF0sejpbMCwwLDFdfSxsdD0xLjQxNDIxMzU2MjM3LGN0PXt4OlsxLGx0LGx0XSx5OltsdCwxLGx0XSx6OltsdCxsdCwxXX07Y2xhc3MgdXR7Y29uc3RydWN0b3IodCxlLHMsaSl7dGhpcy5pZD10LHRoaXMucGFyZW50PWUsdGhpcy50ZXh0dXJlcz1zLHRoaXMuZWxlbWVudHM9aSx0aGlzLmZsYXR0ZW5lZD0hMX1nZXRCdWZmZXJzKHQsZSxzLGksbil7dmFyIHI7Y29uc3Qgbz1bXSxhPVtdLGg9W10sbD1bXTtmb3IoY29uc3QgYyBvZiBudWxsIT09KHI9dGhpcy5lbGVtZW50cykmJnZvaWQgMCE9PXI/cjpbXSl7Y29uc3Qgcj10aGlzLmdldEVsZW1lbnRCdWZmZXJzKHQsZSxjLGkscyxuKTtvLnB1c2goci5wb3NpdGlvbiksYS5wdXNoKC4uLnIudGV4Q29vcmQpLGgucHVzaCguLi5yLnRpbnRDb2xvciksbC5wdXNoKC4uLnIuaW5kZXgpLGkrPXIudGV4Q29vcmQubGVuZ3RoLzJ9cmV0dXJue3Bvc2l0aW9uOm50KC4uLm8pLHRleENvb3JkOmEsdGludENvbG9yOmgsaW5kZXg6bH19Z2V0RWxlbWVudEJ1ZmZlcnModCxuLHIsbyxhLGgpe3ZhciBsLGMsdSxkLGYsZyxwLG0sdix3LGIsUDtjb25zdCB4PXIuZnJvbVswXSx5PXIuZnJvbVsxXSxBPXIuZnJvbVsyXSxTPXIudG9bMF0sQj1yLnRvWzFdLEU9ci50b1syXSxDPVtdLGs9W10sST1bXSxSPVtdLEY9KGUscyxpKT0+e3ZhciByLGgsbCxjLHUsZCxmLGcscCxtLHYsdztjb25zdFtiLFAseCx5XT1hLmdldFRleHR1cmVVVih0aGlzLmdldFRleHR1cmUoZS50ZXh0dXJlKSksQT0oeC1iKS8xNixTPSh5LVApLzE2LEI9QS8xNixFPVMvMTY7c1swXT0obnVsbCE9PShoPW51bGw9PT0ocj1lLnV2KXx8dm9pZCAwPT09cj92b2lkIDA6clswXSkmJnZvaWQgMCE9PWg/aDpzWzBdKSpBK0Isc1sxXT0obnVsbCE9PShjPW51bGw9PT0obD1lLnV2KXx8dm9pZCAwPT09bD92b2lkIDA6bFsxXSkmJnZvaWQgMCE9PWM/YzpzWzFdKSpTK0Usc1syXT0obnVsbCE9PShkPW51bGw9PT0odT1lLnV2KXx8dm9pZCAwPT09dT92b2lkIDA6dVsyXSkmJnZvaWQgMCE9PWQ/ZDpzWzJdKSpBLUIsc1szXT0obnVsbCE9PShnPW51bGw9PT0oZj1lLnV2KXx8dm9pZCAwPT09Zj92b2lkIDA6ZlszXSkmJnZvaWQgMCE9PWc/ZzpzWzNdKSpTLUU7Y29uc3QgRj1hdFtudWxsIT09KHA9ZS5yb3RhdGlvbikmJnZvaWQgMCE9PXA/cDowXTtrLnB1c2goYitzW0ZbMF1dLFArc1tGWzFdXSxiK3NbRlsyXV0sUCtzW0ZbM11dLGIrc1tGWzRdXSxQK3NbRls1XV0sYitzW0ZbNl1dLFArc1tGWzddXSk7Y29uc3QgTT0obnVsbCE9PShtPWUudGludGluZGV4KSYmdm9pZCAwIT09bT9tOi0xKT49MCYmbnVsbCE9PSh3PW51bGw9PT0odj1zdFt0LnNsaWNlKDEwKV0pfHx2b2lkIDA9PT12P3ZvaWQgMDp2LmNhbGwoc3QsbikpJiZ2b2lkIDAhPT13P3c6WzEsMSwxXTtJLnB1c2goLi4uTSwuLi5NLC4uLk0sLi4uTSksQy5wdXNoKC4uLmkpLFIucHVzaChvLG8rMSxvKzIsbyxvKzIsbyszKSxvKz00fTshKG51bGw9PT0oYz1udWxsPT09KGw9ci5mYWNlcyl8fHZvaWQgMD09PWw/dm9pZCAwOmwudXApfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLnRleHR1cmUpfHxyLmZhY2VzLnVwLmN1bGxmYWNlJiZoW3IuZmFjZXMudXAuY3VsbGZhY2VdfHxGKHIuZmFjZXMudXAsW3gsMTYtRSxTLDE2LUFdLFt4LEIsRSxTLEIsRSxTLEIsQSx4LEIsQV0pLCEobnVsbD09PShkPW51bGw9PT0odT1yLmZhY2VzKXx8dm9pZCAwPT09dT92b2lkIDA6dS5kb3duKXx8dm9pZCAwPT09ZD92b2lkIDA6ZC50ZXh0dXJlKXx8ci5mYWNlcy5kb3duLmN1bGxmYWNlJiZoW3IuZmFjZXMuZG93bi5jdWxsZmFjZV18fEYoci5mYWNlcy5kb3duLFsxNi1FLDE2LVMsMTYtQSwxNi14XSxbeCx5LEEsUyx5LEEsUyx5LEUseCx5LEVdKSwhKG51bGw9PT0oZz1udWxsPT09KGY9ci5mYWNlcyl8fHZvaWQgMD09PWY/dm9pZCAwOmYuc291dGgpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnRleHR1cmUpfHxyLmZhY2VzLnNvdXRoLmN1bGxmYWNlJiZoW3IuZmFjZXMuc291dGguY3VsbGZhY2VdfHxGKHIuZmFjZXMuc291dGgsW3gsMTYtQixTLDE2LXldLFt4LHksRSxTLHksRSxTLEIsRSx4LEIsRV0pLCEobnVsbD09PShtPW51bGw9PT0ocD1yLmZhY2VzKXx8dm9pZCAwPT09cD92b2lkIDA6cC5ub3J0aCl8fHZvaWQgMD09PW0/dm9pZCAwOm0udGV4dHVyZSl8fHIuZmFjZXMubm9ydGguY3VsbGZhY2UmJmhbci5mYWNlcy5ub3J0aC5jdWxsZmFjZV18fEYoci5mYWNlcy5ub3J0aCxbMTYtUywxNi1CLDE2LXgsMTYteV0sW1MseSxBLHgseSxBLHgsQixBLFMsQixBXSksIShudWxsPT09KHc9bnVsbD09PSh2PXIuZmFjZXMpfHx2b2lkIDA9PT12P3ZvaWQgMDp2LmVhc3QpfHx2b2lkIDA9PT13P3ZvaWQgMDp3LnRleHR1cmUpfHxyLmZhY2VzLmVhc3QuY3VsbGZhY2UmJmhbci5mYWNlcy5lYXN0LmN1bGxmYWNlXXx8RihyLmZhY2VzLmVhc3QsWzE2LUUsMTYtQiwxNi1BLDE2LXldLFtTLHksRSxTLHksQSxTLEIsQSxTLEIsRV0pLCEobnVsbD09PShQPW51bGw9PT0oYj1yLmZhY2VzKXx8dm9pZCAwPT09Yj92b2lkIDA6Yi53ZXN0KXx8dm9pZCAwPT09UD92b2lkIDA6UC50ZXh0dXJlKXx8ci5mYWNlcy53ZXN0LmN1bGxmYWNlJiZoW3IuZmFjZXMud2VzdC5jdWxsZmFjZV18fEYoci5mYWNlcy53ZXN0LFtBLDE2LUIsRSwxNi15XSxbeCx5LEEseCx5LEUseCxCLEUseCxCLEFdKTtjb25zdCBNPXMuY3JlYXRlKCk7aWYocy5pZGVudGl0eShNKSxyLnJvdGF0aW9uKXtjb25zdCB0PWUuZnJvbVZhbHVlcyguLi5yLnJvdGF0aW9uLm9yaWdpbik7cy50cmFuc2xhdGUoTSxNLHQpLHMucm90YXRlKE0sTSxpLnRvUmFkaWFuKHIucm90YXRpb24uYW5nbGUpLGh0W3Iucm90YXRpb24uYXhpc10pLHIucm90YXRpb24ucmVzY2FsZSYmcy5zY2FsZShNLE0sY3Rbci5yb3RhdGlvbi5heGlzXSksZS5uZWdhdGUodCx0KSxzLnRyYW5zbGF0ZShNLE0sdCl9Y29uc3QgVD1uZXcgRmxvYXQzMkFycmF5KEMpO3JldHVybiBydChULE0pLHtwb3NpdGlvbjpULHRleENvb3JkOmssdGludENvbG9yOkksaW5kZXg6Un19Z2V0VGV4dHVyZSh0KXtmb3IodmFyIGUsczt0LnN0YXJ0c1dpdGgoXCIjXCIpOyl0PW51bGwhPT0ocz1udWxsPT09KGU9dGhpcy50ZXh0dXJlcyl8fHZvaWQgMD09PWU/dm9pZCAwOmVbdC5zbGljZSgxKV0pJiZ2b2lkIDAhPT1zP3M6XCJcIjtyZXR1cm4gdC5zdGFydHNXaXRoKFwibWluZWNyYWZ0OlwiKXx8KHQ9XCJtaW5lY3JhZnQ6XCIrdCksdH1mbGF0dGVuKHQpe3ZhciBlO2lmKCF0aGlzLmZsYXR0ZW5lZCYmdGhpcy5wYXJlbnQpe2NvbnN0IHM9dC5nZXRCbG9ja01vZGVsKHRoaXMucGFyZW50KTtpZighcylyZXR1cm4gY29uc29sZS53YXJuKGBwYXJlbnQgJHt0aGlzLnBhcmVudH0gZG9lcyBub3QgZXhpc3QhYCksdm9pZCh0aGlzLmZsYXR0ZW5lZD0hMCk7cy5mbGF0dGVuKHQpLHRoaXMuZWxlbWVudHN8fCh0aGlzLmVsZW1lbnRzPXMuZWxlbWVudHMpLHRoaXMudGV4dHVyZXN8fCh0aGlzLnRleHR1cmVzPXt9KSxPYmplY3Qua2V5cyhudWxsIT09KGU9cy50ZXh0dXJlcykmJnZvaWQgMCE9PWU/ZTp7fSkuZm9yRWFjaCgodD0+e3RoaXMudGV4dHVyZXNbdF18fCh0aGlzLnRleHR1cmVzW3RdPXMudGV4dHVyZXNbdF0pfSkpLHRoaXMuZmxhdHRlbmVkPSEwfX1zdGF0aWMgZnJvbUpzb24odCxlKXtsZXQgcz1lLnBhcmVudDtyZXR1cm4gcyYmIXMuc3RhcnRzV2l0aChcIm1pbmVjcmFmdDpcIikmJihzPVwibWluZWNyYWZ0OlwiK3MpLG5ldyB1dCh0LHMsZS50ZXh0dXJlcyxlLmVsZW1lbnRzKX19Y2xhc3MgZHR7Y29uc3RydWN0b3IodCxlLHMpe3RoaXMuZ2w9dCx0aGlzLnByb2dyYW09dGhpcy5pbml0U2hhZGVyUHJvZ3JhbShlLHMpfWdldFByb2dyYW0oKXtyZXR1cm4gdGhpcy5wcm9ncmFtfWluaXRTaGFkZXJQcm9ncmFtKHQsZSl7Y29uc3Qgcz10aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLHQpLGk9dGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLGUpLG49dGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7aWYodGhpcy5nbC5hdHRhY2hTaGFkZXIobixzKSx0aGlzLmdsLmF0dGFjaFNoYWRlcihuLGkpLHRoaXMuZ2wubGlua1Byb2dyYW0obiksIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHRoaXMuZ2wuTElOS19TVEFUVVMpKXRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxpbmsgc2hhZGVyIHByb2dyYW06ICR7dGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhuKX1gKTtyZXR1cm4gbn1sb2FkU2hhZGVyKHQsZSl7Y29uc3Qgcz10aGlzLmdsLmNyZWF0ZVNoYWRlcih0KTtpZih0aGlzLmdsLnNoYWRlclNvdXJjZShzLGUpLHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzKSwhdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIocyx0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgZT1uZXcgRXJyb3IoYENvbXBpbGluZyAke3Q9PT10aGlzLmdsLlZFUlRFWF9TSEFERVI/XCJ2ZXJ0ZXhcIjpcImZyYWdtZW50XCJ9IHNoYWRlcjogJHt0aGlzLmdsLmdldFNoYWRlckluZm9Mb2cocyl9YCk7dGhyb3cgdGhpcy5nbC5kZWxldGVTaGFkZXIocyksZX1yZXR1cm4gc319ZnVuY3Rpb24gZnQodCxlLHMsaSxuKXtjb25zdCByPW5ldyBvdChcIlwiLHtcIlwiOnttb2RlbDpcIlwifX0sdm9pZCAwKSxvPXtnZXRCbG9ja01vZGVsOigpPT5ufTtyZXR1cm4gbi5mbGF0dGVuKG8pLHIuZ2V0QnVmZmVycyh0LHt9LGUsbyxzLGkpfWZ1bmN0aW9uIGd0KHQsZSxzLGkscixvKXtjb25zdCBhPXIudXA/MTY6WzE0LjIsMTIuNSwxMC41LDksNyw1LjMsMy43LDEuOSwxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNl1bc107cmV0dXJuIGZ0KGBtaW5lY3JhZnQ6JHt0fWAsaSxlLHIsbmV3IHV0KFwiXCIsXCJcIix7c3RpbGw6YG1pbmVjcmFmdDpibG9jay8ke3R9X3N0aWxsYCxmbG93OmBtaW5lY3JhZnQ6YmxvY2svJHt0fV9mbG93YH0sW3tmcm9tOlswLDAsMF0sdG86WzE2LGEsMTZdLGZhY2VzOnt1cDp7dGV4dHVyZTpcIiNzdGlsbFwiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uVVB9LGRvd246e3RleHR1cmU6XCIjc3RpbGxcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLkRPV059LG5vcnRoOnt0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLk5PUlRIfSxlYXN0Ont0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLkVBU1R9LHNvdXRoOnt0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLlNPVVRIfSx3ZXN0Ont0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLldFU1R9fX1dKSl9Y29uc3QgcHQ9e1wibWluZWNyYWZ0OndhdGVyXCI6KHQsZSxzLGkpPT5ndChcIndhdGVyXCIsdCxwYXJzZUludChlLmxldmVsKSxzLGksMCksXCJtaW5lY3JhZnQ6bGF2YVwiOih0LGUscyxpKT0+Z3QoXCJsYXZhXCIsdCxwYXJzZUludChlLmxldmVsKSxzLGkpLFwibWluZWNyYWZ0OmNoZXN0XCI6KHQsZSxzKT0+ZnVuY3Rpb24odCxlLHMsaSl7cmV0dXJuIGZ0KFwibWluZWNyYWZ0OmNoZXN0XCIsaSx0LHt9LG5ldyB1dChcIlwiLFwiXCIsezA6XCJtaW5lY3JhZnQ6YmxvY2svY2hlc3RcIn0sW3tmcm9tOlsxLDAsMV0sdG86WzE1LDE0LDE1XSxmYWNlczp7dXA6e3RleHR1cmU6XCIjMFwifSxkb3duOnt0ZXh0dXJlOlwiIzBcIn0sbm9ydGg6e3RleHR1cmU6XCIjMFwifSxlYXN0Ont0ZXh0dXJlOlwiIzBcIn0sc291dGg6e3RleHR1cmU6XCIjMFwifSx3ZXN0Ont0ZXh0dXJlOlwiIzBcIn19fV0pKX0odCxlLmZhY2luZyxlLnR5cGUscyl9LG10PW5ldyBTZXQoT2JqZWN0LmtleXMocHQpKTtjbGFzcyB2dHtjb25zdHJ1Y3Rvcih0LGUscyxpKXt2YXIgbixyO3RoaXMuZ2w9dCx0aGlzLnN0cnVjdHVyZT1lLHRoaXMucmVzb3VyY2VzPXMsdGhpcy5jaHVua3M9W10sKG51bGw9PWk/dm9pZCAwOmkuZmFjZXNQZXJCdWZmZXIpJiZjb25zb2xlLndhcm4oXCJ3ZWJnbCByZW5kZXIgd2FybmluZzogZmFjZXNQZXJCdWZmZXIgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgY2h1bmtTaXplXCIpLHRoaXMuY2h1bmtTaXplPW51bGwhPT0obj1udWxsPT1pP3ZvaWQgMDppLmNodW5rU2l6ZSkmJnZvaWQgMCE9PW4/bjoxNix0aGlzLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyPW51bGw9PT0ocj1udWxsPT1pP3ZvaWQgMDppLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyKXx8dm9pZCAwPT09cnx8cix0aGlzLnNoYWRlclByb2dyYW09bmV3IGR0KHQsXCJcXG4gIGF0dHJpYnV0ZSB2ZWM0IHZlcnRQb3M7XFxuICBhdHRyaWJ1dGUgdmVjMiB0ZXhDb29yZDtcXG4gIGF0dHJpYnV0ZSB2ZWMzIHRpbnRDb2xvcjtcXG4gIGF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5cXG4gIHVuaWZvcm0gbWF0NCBtVmlldztcXG4gIHVuaWZvcm0gbWF0NCBtUHJvajtcXG5cXG4gIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4Q29vcmQ7XFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdlRpbnRDb2xvcjtcXG4gIHZhcnlpbmcgaGlnaHAgZmxvYXQgdkxpZ2h0aW5nO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBtUHJvaiAqIG1WaWV3ICogdmVydFBvcztcXG4gICAgdlRleENvb3JkID0gdGV4Q29vcmQ7XFxuICAgIHZUaW50Q29sb3IgPSB0aW50Q29sb3I7XFxuICAgIHZMaWdodGluZyA9IG5vcm1hbC55ICogMC4yICsgYWJzKG5vcm1hbC56KSAqIDAuMSArIDAuODtcXG4gIH1cXG5cIixcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2VGludENvbG9yO1xcbiAgdmFyeWluZyBoaWdocCBmbG9hdCB2TGlnaHRpbmc7XFxuXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChzYW1wbGVyLCB2VGV4Q29vcmQpO1xcbiAgICBpZih0ZXhDb2xvci5hIDwgMC4wMSkgZGlzY2FyZDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXhDb2xvci54eXogKiB2VGludENvbG9yICogdkxpZ2h0aW5nLCB0ZXhDb2xvci5hKTtcXG4gIH1cXG5cIikuZ2V0UHJvZ3JhbSgpLHRoaXMuZ3JpZFNoYWRlclByb2dyYW09bmV3IGR0KHQsXCJcXG4gIGF0dHJpYnV0ZSB2ZWM0IHZlcnRQb3M7XFxuICBhdHRyaWJ1dGUgdmVjMyB2ZXJ0Q29sb3I7XFxuXFxuICB1bmlmb3JtIG1hdDQgbVZpZXc7XFxuICB1bmlmb3JtIG1hdDQgbVByb2o7XFxuXFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkNvbG9yO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBtUHJvaiAqIG1WaWV3ICogdmVydFBvcztcXG4gICAgdkNvbG9yID0gdmVydENvbG9yO1xcbiAgfVxcblwiLFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkNvbG9yO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XFxuICB9XFxuXCIpLmdldFByb2dyYW0oKSx0aGlzLmNvbG9yU2hhZGVyUHJvZ3JhbT1uZXcgZHQodCxcIlxcbiAgYXR0cmlidXRlIHZlYzQgdmVydFBvcztcXG4gIGF0dHJpYnV0ZSB2ZWMzIGJsb2NrUG9zO1xcblxcbiAgdW5pZm9ybSBtYXQ0IG1WaWV3O1xcbiAgdW5pZm9ybSBtYXQ0IG1Qcm9qO1xcblxcbiAgdmFyeWluZyBoaWdocCB2ZWMzIHZDb2xvcjtcXG5cXG4gIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gbVByb2ogKiBtVmlldyAqIHZlcnRQb3M7XFxuICAgIHZDb2xvciA9IGJsb2NrUG9zIC8gMjU2LjA7XFxuICB9XFxuXCIsXCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2Q29sb3I7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4wKTtcXG4gIH1cXG5cIikuZ2V0UHJvZ3JhbSgpLHRoaXMudXBkYXRlU3RydWN0dXJlQnVmZmVycygpLHRoaXMuZ3JpZEJ1ZmZlcnM9dGhpcy5nZXRHcmlkQnVmZmVycygpLHRoaXMub3V0bGluZUJ1ZmZlcnM9dGhpcy5nZXRPdXRsaW5lQnVmZmVycygpLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzPXRoaXMuZ2V0SW52aXNpYmxlQmxvY2tCdWZmZXJzKCksdGhpcy5hdGxhc1RleHR1cmU9dGhpcy5nZXRCbG9ja1RleHR1cmUoKSx0aGlzLnByb2pNYXRyaXg9dGhpcy5nZXRQZXJzcGVjdGl2ZSgpLHRoaXMuYWN0aXZlU2hhZGVyPXRoaXMuc2hhZGVyUHJvZ3JhbSx0aGlzLmluaXRpYWxpemUoKX1zZXRTdHJ1Y3R1cmUodCl7dGhpcy5zdHJ1Y3R1cmU9dCx0aGlzLnVwZGF0ZVN0cnVjdHVyZUJ1ZmZlcnMoKSx0aGlzLmdyaWRCdWZmZXJzPXRoaXMuZ2V0R3JpZEJ1ZmZlcnMoKSx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycz10aGlzLmdldEludmlzaWJsZUJsb2NrQnVmZmVycygpfWluaXRpYWxpemUoKXt0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpLHRoaXMuZ2wuZGVwdGhGdW5jKHRoaXMuZ2wuTEVRVUFMKSx0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKSx0aGlzLmdsLmJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSx0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKSx0aGlzLmdsLmN1bGxGYWNlKHRoaXMuZ2wuQkFDSyl9Z2V0QmxvY2tUZXh0dXJlKCl7Y29uc3QgdD10aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtyZXR1cm4gdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsdCksdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwwLHRoaXMuZ2wuUkdCQSx0aGlzLmdsLlJHQkEsdGhpcy5nbC5VTlNJR05FRF9CWVRFLHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmVBdGxhcygpKSx0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRCksdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCx0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUix0aGlzLmdsLk5FQVJFU1QpLHR9Z2V0UGVyc3BlY3RpdmUoKXtjb25zdCB0PTcwKk1hdGguUEkvMTgwLGU9dGhpcy5nbC5jYW52YXMuY2xpZW50V2lkdGgvdGhpcy5nbC5jYW52YXMuY2xpZW50SGVpZ2h0LGk9cy5jcmVhdGUoKTtyZXR1cm4gcy5wZXJzcGVjdGl2ZShpLHQsZSwuMSw1MDApLGl9Z2V0Q2h1bmsodCl7Y29uc3QgZT0yKk1hdGguYWJzKHRbMF0pKyh0WzBdPDA/MTowKSxzPTIqTWF0aC5hYnModFsxXSkrKHRbMV08MD8xOjApLGk9MipNYXRoLmFicyh0WzJdKSsodFsyXTwwPzE6MCk7cmV0dXJuIHRoaXMuY2h1bmtzW2VdfHwodGhpcy5jaHVua3NbZV09W10pLHRoaXMuY2h1bmtzW2VdW3NdfHwodGhpcy5jaHVua3NbZV1bc109W10pLHRoaXMuY2h1bmtzW2VdW3NdW2ldfHwodGhpcy5jaHVua3NbZV1bc11baV09e3Bvc2l0aW9uczpbXSx0ZXh0dXJlQ29vcmRpbmF0ZXM6W10sdGludENvbG9yczpbXSxibG9ja1Bvc2l0aW9uczpbXSxub3JtYWxzOltdLGluZGljZXM6W10saW5kZXhPZmZzZXQ6MH0pLHRoaXMuY2h1bmtzW2VdW3NdW2ldfXVwZGF0ZVN0cnVjdHVyZUJ1ZmZlcnModCl7dmFyIGk7Y29uc3Qgcj0odCxpLG4pPT57Y29uc3Qgcj1zLmNyZWF0ZSgpO3MudHJhbnNsYXRlKHIscixpKSxydCh0LnBvc2l0aW9uLHIpLG4ucG9zaXRpb25zLnB1c2godC5wb3NpdGlvbiksbi50ZXh0dXJlQ29vcmRpbmF0ZXMucHVzaCguLi50LnRleENvb3JkKSxuLnRpbnRDb2xvcnMucHVzaCguLi50LnRpbnRDb2xvcik7Zm9yKGxldCBzPTA7czx0LnBvc2l0aW9uLmxlbmd0aDtzKz0xMil7Y29uc3QgaT1lLmZyb21WYWx1ZXModC5wb3NpdGlvbltzXSx0LnBvc2l0aW9uW3MrMV0sdC5wb3NpdGlvbltzKzJdKSxyPWUuZnJvbVZhbHVlcyh0LnBvc2l0aW9uW3MrM10sdC5wb3NpdGlvbltzKzRdLHQucG9zaXRpb25bcys1XSksbz1lLmZyb21WYWx1ZXModC5wb3NpdGlvbltzKzZdLHQucG9zaXRpb25bcys3XSx0LnBvc2l0aW9uW3MrOF0pO2Uuc3VidHJhY3QocixyLGkpLGUuc3VidHJhY3QobyxvLGkpLGUuY3Jvc3MocixyLG8pLGUubm9ybWFsaXplKHIsciksbi5ub3JtYWxzLnB1c2goLi4uciwuLi5yLC4uLnIsLi4ucil9Zm9yKGxldCBlPTA7ZTx0LnRleENvb3JkLmxlbmd0aC8yO2UrPTEpbi5ibG9ja1Bvc2l0aW9ucy5wdXNoKC4uLmkpO24uaW5kaWNlcy5wdXNoKC4uLnQuaW5kZXgpLG4uaW5kZXhPZmZzZXQrPXQudGV4Q29vcmQubGVuZ3RoLzJ9LG89dD0+e3QucG9zaXRpb25zPVtdLHQudGV4dHVyZUNvb3JkaW5hdGVzPVtdLHQudGludENvbG9ycz1bXSx0LmJsb2NrUG9zaXRpb25zPVtdLHQubm9ybWFscz1bXSx0LmluZGljZXM9W10sdC5pbmRleE9mZnNldD0wfSxhPXQ9Pnt0LmJ1ZmZlcj8odGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIucG9zaXRpb24sdGhpcy5nbC5BUlJBWV9CVUZGRVIsbnQoLi4udC5wb3NpdGlvbnMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci50ZXhDb29yZCx0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQudGV4dHVyZUNvb3JkaW5hdGVzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIudGludENvbG9yLHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC50aW50Q29sb3JzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIubm9ybWFsLHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC5ub3JtYWxzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIuYmxvY2tQb3MsdGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LmJsb2NrUG9zaXRpb25zKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIuaW5kZXgsdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixuZXcgVWludDE2QXJyYXkodC5pbmRpY2VzKSksdC5idWZmZXIubGVuZ3RoPXQuaW5kaWNlcy5sZW5ndGgpOnQuYnVmZmVyPXtwb3NpdGlvbjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixudCguLi50LnBvc2l0aW9ucykpLHRleENvb3JkOnRoaXMuY3JlYXRlQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC50ZXh0dXJlQ29vcmRpbmF0ZXMpKSx0aW50Q29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LnRpbnRDb2xvcnMpKSxibG9ja1Bvczp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQuYmxvY2tQb3NpdGlvbnMpKSxub3JtYWw6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0Lm5vcm1hbHMpKSxpbmRleDp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG5ldyBVaW50MTZBcnJheSh0LmluZGljZXMpKSxsZW5ndGg6dC5pbmRpY2VzLmxlbmd0aH19O2xldCBoO3Q/dC5mb3JFYWNoKCh0PT57Y29uc3QgZT10aGlzLmdldENodW5rKHQpO28oZSl9KSk6dGhpcy5jaHVua3MuZm9yRWFjaCgodD0+dC5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PntvKHQpfSkpKSkpKTtmb3IoY29uc3QgcyBvZiB0aGlzLnN0cnVjdHVyZS5nZXRCbG9ja3MoKSl7Y29uc3Qgbz1zLnN0YXRlLmdldE5hbWUoKSxhPXMuc3RhdGUuZ2V0UHJvcGVydGllcygpLGw9bnVsbCE9PShpPXRoaXMucmVzb3VyY2VzLmdldERlZmF1bHRCbG9ja1Byb3BlcnRpZXMobykpJiZ2b2lkIDAhPT1pP2k6e307T2JqZWN0LmVudHJpZXMobCkuZm9yRWFjaCgoKFt0LGVdKT0+e2FbdF18fChhW3RdPWUpfSkpO2NvbnN0IGM9W01hdGguZmxvb3Iocy5wb3NbMF0vdGhpcy5jaHVua1NpemUpLE1hdGguZmxvb3Iocy5wb3NbMV0vdGhpcy5jaHVua1NpemUpLE1hdGguZmxvb3Iocy5wb3NbMl0vdGhpcy5jaHVua1NpemUpXTtpZih0JiYhdC5zb21lKCh0PT5lLmVxdWFscyh0LGMpKSkpY29udGludWU7Y29uc3QgdT10aGlzLmdldENodW5rKGMpO3RyeXtjb25zdCB0PXRoaXMucmVzb3VyY2VzLmdldEJsb2NrRGVmaW5pdGlvbihvKSxlPXt1cDp0aGlzLm5lZWRzQ3VsbChzLG4uVVApLGRvd246dGhpcy5uZWVkc0N1bGwocyxuLkRPV04pLHdlc3Q6dGhpcy5uZWVkc0N1bGwocyxuLldFU1QpLGVhc3Q6dGhpcy5uZWVkc0N1bGwocyxuLkVBU1QpLG5vcnRoOnRoaXMubmVlZHNDdWxsKHMsbi5OT1JUSCksc291dGg6dGhpcy5uZWVkc0N1bGwocyxuLlNPVVRIKX07dCYmKGg9dC5nZXRCdWZmZXJzKG8sYSx0aGlzLnJlc291cmNlcyx0aGlzLnJlc291cmNlcyx1LmluZGV4T2Zmc2V0LGUpLHIoaCxzLnBvcyx1KSksbXQuaGFzKG8pJiYoaD1wdFtvXSh1LmluZGV4T2Zmc2V0LGEsdGhpcy5yZXNvdXJjZXMsZSkscihoLHMucG9zLHUpKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKGBFcnJvciByZW5kZXJpbmcgYmxvY2sgJHtvfWAsdCl9fXQ/dC5mb3JFYWNoKCh0PT57Y29uc3QgZT10aGlzLmdldENodW5rKHQpO2EoZSl9KSk6dGhpcy5jaHVua3MuZm9yRWFjaCgodD0+dC5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PnthKHQpfSkpKSkpKX1uZWVkc0N1bGwodCxlKXt2YXIgcyxpO2NvbnN0IHI9bnVsbD09PShzPXRoaXMuc3RydWN0dXJlLmdldEJsb2NrKG8udG93YXJkcyh0LnBvcyxlKSkpfHx2b2lkIDA9PT1zP3ZvaWQgMDpzLnN0YXRlO3JldHVybiEhciYmKChudWxsPT09KGk9dGhpcy5yZXNvdXJjZXMuZ2V0QmxvY2tGbGFncyhyLmdldE5hbWUoKSkpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLm9wYXF1ZSk/IShlPT09bi5VUCYmdC5zdGF0ZS5pc0ZsdWlkKCkpOnQuc3RhdGUuaXNGbHVpZCgpJiZyLmlzRmx1aWQoKSl9Z2V0R3JpZEJ1ZmZlcnMoKXtjb25zdFt0LGUsc109dGhpcy5zdHJ1Y3R1cmUuZ2V0U2l6ZSgpLGk9W10sbj1bXTtpLnB1c2goMCwwLDAsdCwwLDApLG4ucHVzaCgxLDAsMCwxLDAsMCksaS5wdXNoKDAsMCwwLDAsMCxzKSxuLnB1c2goMCwwLDEsMCwwLDEpLGkucHVzaCgwLDAsMCwwLGUsMCksaS5wdXNoKHQsMCwwLHQsZSwwKSxpLnB1c2goMCwwLHMsMCxlLHMpLGkucHVzaCh0LDAscyx0LGUscyksaS5wdXNoKDAsZSwwLDAsZSxzKSxpLnB1c2godCxlLDAsdCxlLHMpLGkucHVzaCgwLGUsMCx0LGUsMCksaS5wdXNoKDAsZSxzLHQsZSxzKTtmb3IobGV0IGU9MTtlPD10O2UrPTEpaS5wdXNoKGUsMCwwLGUsMCxzKTtmb3IobGV0IGU9MTtlPD1zO2UrPTEpaS5wdXNoKDAsMCxlLHQsMCxlKTtmb3IobGV0IGU9MDtlPDgrdCtzO2UrPTEpbi5wdXNoKC44LC44LC44LC44LC44LC44KTtyZXR1cm57cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShpKSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShuKSksbGVuZ3RoOmkubGVuZ3RoLzN9fWdldE91dGxpbmVCdWZmZXJzKCl7Y29uc3QgdD1bXSxlPVtdO3JldHVybiB0aGlzLmFkZEN1YmUodCxlLFsxLDEsMV0sWzAsMCwwXSxbMSwxLDFdKSx7cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0KSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShlKSksbGVuZ3RoOnQubGVuZ3RoLzN9fWdldEludmlzaWJsZUJsb2NrQnVmZmVycygpe2lmKCF0aGlzLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyKXJldHVybjtjb25zdCB0PXRoaXMuc3RydWN0dXJlLmdldFNpemUoKSxlPVtdLHM9W107Zm9yKGxldCBpPTA7aTx0WzBdO2krPTEpZm9yKGxldCBuPTA7bjx0WzFdO24rPTEpZm9yKGxldCByPTA7cjx0WzJdO3IrPTEpe2NvbnN0IHQ9dGhpcy5zdHJ1Y3R1cmUuZ2V0QmxvY2soW2ksbixyXSk7dm9pZCAwIT09dCYmKG51bGw9PT10P3RoaXMuYWRkQ3ViZShlLHMsWzEsLjI1LC4yNV0sW2krLjQzNzUsbisuNDM3NSxyKy40Mzc1XSxbaSsuNTYyNSxuKy41NjI1LHIrLjU2MjVdKTpcIm1pbmVjcmFmdDphaXJcIj09PXQuc3RhdGUuZ2V0TmFtZSgpP3RoaXMuYWRkQ3ViZShlLHMsWy41LC41LDFdLFtpKy4zNzUsbisuMzc1LHIrLjM3NV0sW2krLjYyNSxuKy42MjUscisuNjI1XSk6XCJtaW5lY3JhZnQ6Y2F2ZV9haXJcIj09PXQuc3RhdGUuZ2V0TmFtZSgpJiZ0aGlzLmFkZEN1YmUoZSxzLFsuNSwxLC41XSxbaSsuMzc1LG4rLjM3NSxyKy4zNzVdLFtpKy42MjUsbisuNjI1LHIrLjYyNV0pKX1yZXR1cm57cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShlKSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShzKSksbGVuZ3RoOmUubGVuZ3RoLzN9fWFkZEN1YmUodCxlLHMsaSxuKXt0LnB1c2goaVswXSxpWzFdLGlbMl0saVswXSxpWzFdLG5bMl0pLHQucHVzaChuWzBdLGlbMV0saVsyXSxuWzBdLGlbMV0sblsyXSksdC5wdXNoKGlbMF0saVsxXSxpWzJdLG5bMF0saVsxXSxpWzJdKSx0LnB1c2goaVswXSxpWzFdLG5bMl0sblswXSxpWzFdLG5bMl0pLHQucHVzaChpWzBdLGlbMV0saVsyXSxpWzBdLG5bMV0saVsyXSksdC5wdXNoKG5bMF0saVsxXSxpWzJdLG5bMF0sblsxXSxpWzJdKSx0LnB1c2goaVswXSxpWzFdLG5bMl0saVswXSxuWzFdLG5bMl0pLHQucHVzaChuWzBdLGlbMV0sblsyXSxuWzBdLG5bMV0sblsyXSksdC5wdXNoKGlbMF0sblsxXSxpWzJdLGlbMF0sblsxXSxuWzJdKSx0LnB1c2goblswXSxuWzFdLGlbMl0sblswXSxuWzFdLG5bMl0pLHQucHVzaChpWzBdLG5bMV0saVsyXSxuWzBdLG5bMV0saVsyXSksdC5wdXNoKGlbMF0sblsxXSxuWzJdLG5bMF0sblsxXSxuWzJdKTtmb3IobGV0IHQ9MDt0PDI0O3QrPTEpZS5wdXNoKC4uLnMpfWNyZWF0ZUJ1ZmZlcih0LGUpe2NvbnN0IHM9dGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gdGhpcy5nbC5iaW5kQnVmZmVyKHQscyksdGhpcy5nbC5idWZmZXJEYXRhKHQsZSx0aGlzLmdsLkRZTkFNSUNfRFJBVyksc311cGRhdGVCdWZmZXIodCxlLHMpe3RoaXMuZ2wuYmluZEJ1ZmZlcihlLHQpLHRoaXMuZ2wuYnVmZmVyRGF0YShlLHMsdGhpcy5nbC5TVEFUSUNfRFJBVyl9ZHJhd0dyaWQodCl7dGhpcy5zZXRTaGFkZXIodGhpcy5ncmlkU2hhZGVyUHJvZ3JhbSksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydFBvc1wiLDMsdGhpcy5ncmlkQnVmZmVycy5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydENvbG9yXCIsMyx0aGlzLmdyaWRCdWZmZXJzLmNvbG9yKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLHQpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5MSU5FUywwLHRoaXMuZ3JpZEJ1ZmZlcnMubGVuZ3RoKX1kcmF3SW52aXNpYmxlQmxvY2tzKHQpe3RoaXMudXNlSW52aXNpYmxlQmxvY2tCdWZmZXImJih0aGlzLnNldFNoYWRlcih0aGlzLmdyaWRTaGFkZXJQcm9ncmFtKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydENvbG9yXCIsMyx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5jb2xvciksdGhpcy5zZXRVbmlmb3JtKFwibVZpZXdcIix0KSx0aGlzLnNldFVuaWZvcm0oXCJtUHJvalwiLHRoaXMucHJvak1hdHJpeCksdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuTElORVMsMCx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5sZW5ndGgpKX1kcmF3U3RydWN0dXJlKHQpe3RoaXMuc2V0U2hhZGVyKHRoaXMuc2hhZGVyUHJvZ3JhbSksdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTApLHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELHRoaXMuYXRsYXNUZXh0dXJlKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLHQpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmNodW5rcy5mb3JFYWNoKCh0PT57dC5mb3JFYWNoKCh0PT57dC5mb3JFYWNoKCh0PT57dC5idWZmZXImJih0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0LmJ1ZmZlci5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidGV4Q29vcmRcIiwyLHQuYnVmZmVyLnRleENvb3JkKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ0aW50Q29sb3JcIiwzLHQuYnVmZmVyLnRpbnRDb2xvciksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwibm9ybWFsXCIsMyx0LmJ1ZmZlci5ub3JtYWwpLHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHQuYnVmZmVyLmluZGV4KSx0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUyx0LmJ1ZmZlci5sZW5ndGgsdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwwKSl9KSl9KSl9KSl9ZHJhd0NvbG9yZWRTdHJ1Y3R1cmUodCl7dGhpcy5zZXRTaGFkZXIodGhpcy5jb2xvclNoYWRlclByb2dyYW0pLHRoaXMuc2V0VW5pZm9ybShcIm1WaWV3XCIsdCksdGhpcy5zZXRVbmlmb3JtKFwibVByb2pcIix0aGlzLnByb2pNYXRyaXgpLHRoaXMuY2h1bmtzLmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmJ1ZmZlciYmKHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRQb3NcIiwzLHQuYnVmZmVyLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJibG9ja1Bvc1wiLDMsdC5idWZmZXIuYmxvY2tQb3MpLHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHQuYnVmZmVyLmluZGV4KSx0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUyx0LmJ1ZmZlci5sZW5ndGgsdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwwKSl9KSl9KSl9KSl9ZHJhd091dGxpbmUodCxlKXt0aGlzLnNldFNoYWRlcih0aGlzLmdyaWRTaGFkZXJQcm9ncmFtKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0aGlzLm91dGxpbmVCdWZmZXJzLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0Q29sb3JcIiwzLHRoaXMub3V0bGluZUJ1ZmZlcnMuY29sb3IpO2NvbnN0IGk9cy5jcmVhdGUoKTtzLmNvcHkoaSx0KSxzLnRyYW5zbGF0ZShpLGksZSksdGhpcy5zZXRVbmlmb3JtKFwibVZpZXdcIixpKSx0aGlzLnNldFVuaWZvcm0oXCJtUHJvalwiLHRoaXMucHJvak1hdHJpeCksdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuTElORVMsMCx0aGlzLm91dGxpbmVCdWZmZXJzLmxlbmd0aCl9c2V0Vmlld3BvcnQodCxlLHMsaSl7dGhpcy5nbC52aWV3cG9ydCh0LGUscyxpKSx0aGlzLnByb2pNYXRyaXg9dGhpcy5nZXRQZXJzcGVjdGl2ZSgpfXNldFNoYWRlcih0KXt0aGlzLmdsLnVzZVByb2dyYW0odCksdGhpcy5hY3RpdmVTaGFkZXI9dH1zZXRWZXJ0ZXhBdHRyKHQsZSxzKXtjb25zdCBpPXRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5hY3RpdmVTaGFkZXIsdCk7dGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLHMpLHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLGUsdGhpcy5nbC5GTE9BVCwhMSwwLDApLHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSl9c2V0VW5pZm9ybSh0LGUpe2NvbnN0IHM9dGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5hY3RpdmVTaGFkZXIsdCk7dGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHMsITEsZSl9fVxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovZnVuY3Rpb24gd3QodCxlLHMsaSl7cmV0dXJuIG5ldyhzfHwocz1Qcm9taXNlKSkoKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gbyh0KXt0cnl7aChpLm5leHQodCkpfWNhdGNoKHQpe3IodCl9fWZ1bmN0aW9uIGEodCl7dHJ5e2goaS50aHJvdyh0KSl9Y2F0Y2godCl7cih0KX19ZnVuY3Rpb24gaCh0KXt2YXIgZTt0LmRvbmU/bih0LnZhbHVlKTooZT10LnZhbHVlLGUgaW5zdGFuY2VvZiBzP2U6bmV3IHMoKGZ1bmN0aW9uKHQpe3QoZSl9KSkpLnRoZW4obyxhKX1oKChpPWkuYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KSl9Y2xhc3MgYnR7Y29uc3RydWN0b3IodCxlKXt0aGlzLmltZz10LHRoaXMuaWRNYXA9ZSx0aGlzLnBhcnQ9MTYvdC53aWR0aH1nZXRUZXh0dXJlQXRsYXMoKXtyZXR1cm4gdGhpcy5pbWd9Z2V0VGV4dHVyZVVWKHQpe3ZhciBlO3JldHVybiBudWxsIT09KGU9dGhpcy5pZE1hcFt0XSkmJnZvaWQgMCE9PWU/ZTpbMCwwLHRoaXMucGFydCx0aGlzLnBhcnRdfXN0YXRpYyBmcm9tQmxvYnModCl7cmV0dXJuIHd0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgZT1NYXRoLnNxcnQoT2JqZWN0LmtleXModCkubGVuZ3RoKzEpLHM9TWF0aC5wb3coMixNYXRoLmNlaWwoTWF0aC5sb2coZSkvTWF0aC5sb2coMikpKSxpPTE2KnMsbj0xL3Mscj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Iud2lkdGg9aSxyLmhlaWdodD1pO2NvbnN0IG89ci5nZXRDb250ZXh0KFwiMmRcIik7dGhpcy5kcmF3SW52YWxpZFRleHR1cmUobyk7Y29uc3QgYT17fTtsZXQgaD0xO3JldHVybiB5aWVsZCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0KS5tYXAoKGU9Pnd0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgaT1oJXMscj1NYXRoLmZsb29yKGgvcyk7aCs9MSxhW2VdPVtuKmksbipyLG4qaStuLG4qcituXTtjb25zdCBsPXlpZWxkIGNyZWF0ZUltYWdlQml0bWFwKHRbZV0pO28uZHJhd0ltYWdlKGwsMCwwLDE2LDE2LDE2KmksMTYqciwxNiwxNil9KSkpKSksbmV3IGJ0KG8uZ2V0SW1hZ2VEYXRhKDAsMCxpLGkpLGEpfSkpfXN0YXRpYyBlbXB0eSgpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0LndpZHRoPTE2LHQuaGVpZ2h0PTE2O2NvbnN0IGU9dC5nZXRDb250ZXh0KFwiMmRcIik7cmV0dXJuIGJ0LmRyYXdJbnZhbGlkVGV4dHVyZShlKSxuZXcgYnQoZS5nZXRJbWFnZURhdGEoMCwwLDE2LDE2KSx7fSl9c3RhdGljIGRyYXdJbnZhbGlkVGV4dHVyZSh0KXt0LmZpbGxTdHlsZT1cImJsYWNrXCIsdC5maWxsUmVjdCgwLDAsMTYsMTYpLHQuZmlsbFN0eWxlPVwibWFnZW50YVwiLHQuZmlsbFJlY3QoMCwwLDgsOCksdC5maWxsUmVjdCg4LDgsOCw4KX19dmFyIFB0LHh0OyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P25ldyBzKHQsdCk6dH10LnRhcmdldD1mdW5jdGlvbih0LGUscyxpLHIsbyl7cmV0dXJuIG5ldyBuKHQsZSxzLGkscixvKX0sdC5wYXJhbWV0ZXJzPWZ1bmN0aW9uKHQscyxuLHIsbyxhLGgpe3JldHVybiBuZXcgaShlKHQpLGUocyksZShuKSxlKHIpLGUobyksZShhKSxoKX0sdC5wYXJhbT1lLHQucmFuZ2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHModCxlKX07Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubWluPXQsdGhpcy5tYXg9ZX1kaXN0YW5jZSh0KXtjb25zdCBlPShcIm51bWJlclwiPT10eXBlb2YgdD90OnQubWluKS10aGlzLm1heCxzPXRoaXMubWluLShcIm51bWJlclwiPT10eXBlb2YgdD90OnQubWF4KTtyZXR1cm4gZT4wP2U6TWF0aC5tYXgocywwKX11bmlvbih0KXtyZXR1cm4gbmV3IHMoTWF0aC5taW4odGhpcy5taW4sdC5taW4pLE1hdGgubWF4KHRoaXMubWF4LHQubWF4KSl9fXQuUGFyYW09cztjbGFzcyBpe2NvbnN0cnVjdG9yKHQsZSxzLGksbixyLG8pe3RoaXMudGVtcGVyYXR1cmU9dCx0aGlzLmh1bWlkaXR5PWUsdGhpcy5jb250aW5lbnRhbG5lc3M9cyx0aGlzLmVyb3Npb249aSx0aGlzLmRlcHRoPW4sdGhpcy53ZWlyZG5lc3M9cix0aGlzLm9mZnNldD1vfWZpdHRuZXNzKHQpe3JldHVybiBSKHRoaXMudGVtcGVyYXR1cmUuZGlzdGFuY2UodC50ZW1wZXJhdHVyZSkpK1IodGhpcy5odW1pZGl0eS5kaXN0YW5jZSh0Lmh1bWlkaXR5KSkrUih0aGlzLmNvbnRpbmVudGFsbmVzcy5kaXN0YW5jZSh0LmNvbnRpbmVudGFsbmVzcykpK1IodGhpcy5lcm9zaW9uLmRpc3RhbmNlKHQuZXJvc2lvbikpK1IodGhpcy5kZXB0aC5kaXN0YW5jZSh0LmRlcHRoKSkrUih0aGlzLndlaXJkbmVzcy5kaXN0YW5jZSh0LndlaXJkbmVzcykpK1IodGhpcy5vZmZzZXQtdC5vZmZzZXQpfXNwYWNlKCl7cmV0dXJuW3RoaXMudGVtcGVyYXR1cmUsdGhpcy5odW1pZGl0eSx0aGlzLmNvbnRpbmVudGFsbmVzcyx0aGlzLmVyb3Npb24sdGhpcy5kZXB0aCx0aGlzLndlaXJkbmVzcyxuZXcgcyh0aGlzLm9mZnNldCx0aGlzLm9mZnNldCldfX10LlBhcmFtUG9pbnQ9aTtjbGFzcyBue2NvbnN0cnVjdG9yKHQsZSxzLGksbixyKXt0aGlzLnRlbXBlcmF0dXJlPXQsdGhpcy5odW1pZGl0eT1lLHRoaXMuY29udGluZW50YWxuZXNzPXMsdGhpcy5lcm9zaW9uPWksdGhpcy5kZXB0aD1uLHRoaXMud2VpcmRuZXNzPXJ9Z2V0IG9mZnNldCgpe3JldHVybiAwfXRvQXJyYXkoKXtyZXR1cm5bdGhpcy50ZW1wZXJhdHVyZSx0aGlzLmh1bWlkaXR5LHRoaXMuY29udGluZW50YWxuZXNzLHRoaXMuZXJvc2lvbix0aGlzLmRlcHRoLHRoaXMud2VpcmRuZXNzLHRoaXMub2Zmc2V0XX19dC5UYXJnZXRQb2ludD1uO3QuUGFyYW1ldGVycz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRoaW5ncz10LHRoaXMuaW5kZXg9bmV3IHIodCl9ZmluZCh0KXtyZXR1cm4gdGhpcy5pbmRleC5zZWFyY2godCwoKHQsZSk9PnQuZGlzdGFuY2UoZSkpKX19O2NsYXNzIHJ7Y29uc3RydWN0b3IodCl7dGhpcy5yb290PXIuYnVpbGQodC5tYXAoKChbdCxlXSk9Pm5ldyBoKHQsZSkpKSl9c3RhdGljIGJ1aWxkKHQpe2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aDw9ci5DSElMRFJFTl9QRVJfTk9ERSl7Y29uc3QgZT10Lm1hcCgodD0+e2xldCBlPTA7Zm9yKGxldCBzPTA7czw3O3MrPTEpe2NvbnN0IGk9dC5zcGFjZVtzXTtlKz1NYXRoLmFicygoaS5taW4raS5tYXgpLzIpfXJldHVybntrZXk6ZSxub2RlOnR9fSkpLnNvcnQoKCh0LGUpPT50LmtleS1lLmtleSkpLm1hcCgoKHtub2RlOnR9KT0+dCkpO3JldHVybiBuZXcgYShlKX1sZXQgZT0xLzAscz0tMSxpPVtdO2ZvcihsZXQgbj0wO248NzsrK24pe3Iuc29ydCh0LG4sITEpLGk9ci5idWNrZXRpemUodCk7bGV0IG89MDtmb3IoY29uc3QgdCBvZiBpKW8rPXIuYXJlYSh0LnNwYWNlKTtlPm8mJihlPW8scz1uKX1yZXR1cm4gdD1yLnNvcnQodCxzLCExKSxpPXIuYnVja2V0aXplKHQpLGk9ci5zb3J0KGkscywhMCksbmV3IGEoaS5tYXAoKHQ9PnIuYnVpbGQodC5jaGlsZHJlbikpKSl9c3RhdGljIHNvcnQodCxlLHMpe3JldHVybiB0Lm1hcCgodD0+e2NvbnN0IGk9dC5zcGFjZVtlXSxuPShpLm1pbitpLm1heCkvMjtyZXR1cm57a2V5OnM/TWF0aC5hYnMobik6bixub2RlOnR9fSkpLnNvcnQoKCh0LGUpPT50LmtleS1lLmtleSkpLm1hcCgoKHtub2RlOnR9KT0+dCkpfXN0YXRpYyBidWNrZXRpemUodCl7Y29uc3QgZT1bXTtsZXQgcz1bXTtjb25zdCBpPU1hdGgucG93KDEwLE1hdGguZmxvb3IoTWF0aC5sb2codC5sZW5ndGgtLjAxKS9NYXRoLmxvZygxMCkpKTtmb3IoY29uc3QgbiBvZiB0KXMucHVzaChuKSxzLmxlbmd0aDxpfHwoZS5wdXNoKG5ldyBhKHMpKSxzPVtdKTtyZXR1cm4gMCE9PXMubGVuZ3RoJiZlLnB1c2gobmV3IGEocykpLGV9c3RhdGljIGFyZWEodCl7bGV0IGU9MDtmb3IoY29uc3QgcyBvZiB0KWUrPU1hdGguYWJzKHMubWF4LXMubWluKTtyZXR1cm4gZX1zZWFyY2godCxlKXtyZXR1cm4gdGhpcy5yb290LnNlYXJjaCh0LnRvQXJyYXkoKSxlKS50aGluZygpfX1yLkNISUxEUkVOX1BFUl9OT0RFPTEwLHQuUlRyZWU9cjtjbGFzcyBve2NvbnN0cnVjdG9yKHQpe3RoaXMuc3BhY2U9dH1kaXN0YW5jZSh0KXtsZXQgZT0wO2ZvcihsZXQgcz0wO3M8NztzKz0xKWUrPVIodGhpcy5zcGFjZVtzXS5kaXN0YW5jZSh0W3NdKSk7cmV0dXJuIGV9fXQuUk5vZGU9bztjbGFzcyBhIGV4dGVuZHMgb3tjb25zdHJ1Y3Rvcih0KXtzdXBlcihhLmJ1aWxkU3BhY2UodCkpLHRoaXMuY2hpbGRyZW49dH1zdGF0aWMgYnVpbGRTcGFjZSh0KXtsZXQgZT1bLi4uQXJyYXkoNyldLm1hcCgoKCk9Pm5ldyBzKDEvMCwtMS8wKSkpO2Zvcihjb25zdCBzIG9mIHQpZT1bLi4uQXJyYXkoNyldLm1hcCgoKHQsaSk9PmVbaV0udW5pb24ocy5zcGFjZVtpXSkpKTtyZXR1cm4gZX1zZWFyY2godCxlKXtsZXQgcz0xLzAsaT1udWxsO2Zvcihjb25zdCBuIG9mIHRoaXMuY2hpbGRyZW4pe2NvbnN0IHI9ZShuLHQpO2lmKHM8PXIpY29udGludWU7Y29uc3Qgbz1uLnNlYXJjaCh0LGUpLGE9bj09bz9yOmUobyx0KTtzPD1hfHwocz1hLGk9byl9cmV0dXJuIGl9fXQuUlN1YlRyZWU9YTtjbGFzcyBoIGV4dGVuZHMgb3tjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQuc3BhY2UoKSksdGhpcy50aGluZz1lfXNlYXJjaCgpe3JldHVybiB0aGlzfX10LlJMZWFmPWh9KFB0fHwoUHQ9e30pKTtjbGFzcyB5dHtjb25zdHJ1Y3Rvcih0LGU9e29mZnNldDowLGZhY3RvcjoxLHBlYWtzOjEsbmVhcldhdGVyOiExfSl7dGhpcy5iaW9tZT10LHRoaXMuc2hhcGU9ZX1nZXRCaW9tZSh0LGUscyl7cmV0dXJuIHRoaXMuYmlvbWV9Z2V0VGVycmFpblNoYXBlKHQsZSl7cmV0dXJuIHRoaXMuc2hhcGV9fWNsYXNzIEF0e2NvbnN0cnVjdG9yKHQsZSxzLGksbixyKXt0aGlzLmNlbGxXaWR0aD10LHRoaXMuY2VsbEhlaWdodD1lLHRoaXMuY2VsbENvdW50WT1zLHRoaXMuYmlvbWVTb3VyY2U9aSx0aGlzLnNldHRpbmdzPW4sdGhpcy5ibGVuZGVkTm9pc2U9cix0aGlzLm1vdW50YWluUGVha05vaXNlPW5ldyBZKG5ldyBXKEJpZ0ludCg0MikpLC0xNixbMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0pfWZpbGxOb2lzZUNvbHVtbih0LGUscyxpLG4pe2NvbnN0IHI9ZSp0aGlzLmNlbGxXaWR0aD4+MixvPXMqdGhpcy5jZWxsV2lkdGg+PjIse29mZnNldDphLGZhY3RvcjpoLHBlYWtzOmx9PXRoaXMuYmlvbWVTb3VyY2UuZ2V0VGVycmFpblNoYXBlKHIsbyksYz02ODQuNDEyKnRoaXMuc2V0dGluZ3Muc2FtcGxpbmcueHpTY2FsZSx1PTY4NC40MTIqdGhpcy5zZXR0aW5ncy5zYW1wbGluZy55U2NhbGUsZD1jL3RoaXMuc2V0dGluZ3Muc2FtcGxpbmcueHpGYWN0b3IsZj11L3RoaXMuc2V0dGluZ3Muc2FtcGxpbmcueUZhY3Rvcjtmb3IobGV0IHI9MDtyPD1uO3IrPTEpe2NvbnN0IG49citpLG89dGhpcy5ibGVuZGVkTm9pc2Uuc2FtcGxlKGUsbixzLGMsdSxkLGYpLGc9dGhpcy5zYW1wbGVQZWFrTm9pc2UobCxlKnRoaXMuY2VsbEhlaWdodCxzKnRoaXMuY2VsbEhlaWdodCkvMTI4LHA9dGhpcy5jb21wdXRlSW5pdGlhbERlbnNpdHkobip0aGlzLmNlbGxIZWlnaHQsYSxoLDAsZykrbzt0W3JdPXRoaXMuYXBwbHlTbGlkZShwLG4pfX1zYW1wbGVQZWFrTm9pc2UodCxlLHMpe2lmKDA9PT10KXJldHVybiAwO2NvbnN0IGk9M2UzL3RoaXMuY2VsbFdpZHRoLG49dGhpcy5tb3VudGFpblBlYWtOb2lzZS5zYW1wbGUoZSppLDAscyppKTtyZXR1cm4gbj4wP3Qqbjp0LzIqbn1jb21wdXRlSW5pdGlhbERlbnNpdHkodCxlLHMsaSxuKXtjb25zdCByPShBdC5jb21wdXRlRGltZW5zaW9uRGVuc2l0eSh0aGlzLnNldHRpbmdzLmRlbnNpdHlGYWN0b3IsdGhpcy5zZXR0aW5ncy5kZW5zaXR5T2Zmc2V0LHQsaSkrZStuKSpzO3JldHVybiByKihyPjA/NDoxKX1hcHBseVNsaWRlKHQsZSl7Y29uc3Qgcz1lLU1hdGguZmxvb3IodGhpcy5zZXR0aW5ncy5taW5ZL3RoaXMuY2VsbEhlaWdodCk7aWYodGhpcy5zZXR0aW5ncy50b3BTbGlkZS5zaXplPjApe2NvbnN0IGU9KHRoaXMuY2VsbENvdW50WS1zLXRoaXMuc2V0dGluZ3MudG9wU2xpZGUub2Zmc2V0KS90aGlzLnNldHRpbmdzLnRvcFNsaWRlLnNpemU7dD1fKHRoaXMuc2V0dGluZ3MudG9wU2xpZGUudGFyZ2V0LHQsZSl9aWYodGhpcy5zZXR0aW5ncy5ib3R0b21TbGlkZS5zaXplPjApe2NvbnN0IGU9KHMtdGhpcy5zZXR0aW5ncy5ib3R0b21TbGlkZS5vZmZzZXQpL3RoaXMuc2V0dGluZ3MuYm90dG9tU2xpZGUuc2l6ZTt0PV8odGhpcy5zZXR0aW5ncy5ib3R0b21TbGlkZS50YXJnZXQsdCxlKX1yZXR1cm4gdH1zdGF0aWMgY29tcHV0ZURpbWVuc2lvbkRlbnNpdHkodCxlLHMsaT0wKXtyZXR1cm4gdCooMS1zLzEyOCtpKStlfX0hZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gbC5hcHBseSh0KSsuMDE1fWZ1bmN0aW9uIHModCl7cmV0dXJuIGMuYXBwbHkodCl9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gdS5hcHBseSh0KX1mdW5jdGlvbiBuKHQpe3JldHVybiAzKi0oTWF0aC5hYnMoTWF0aC5hYnModCktLjY2NjY2NjcpLS4zMzMzMzMzNCl9dC5vZmZzZXQ9ZSx0LmZhY3Rvcj1zLHQucGVha3M9aSx0LnBlYWtzQW5kVmFsbGV5cz1uLHQucG9pbnQ9ZnVuY3Rpb24odCxlLHMpe3JldHVybntjb250aW5lbnRzOnQsZXJvc2lvbjplLHdlaXJkbmVzczpzLHJpZGdlczpuKHMpfX0sdC5uZWFyV2F0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHQ8LS4yKSYmKHQ8LS4wNXx8TWF0aC5hYnMoZSk8LjE1KX0sdC5zaGFwZT1mdW5jdGlvbih0LG4pe3JldHVybntvZmZzZXQ6ZSh0KSxmYWN0b3I6cyh0KSxwZWFrczppKHQpLG5lYXJXYXRlcjpufX07Y29uc3Qgcj1mKFwiYmVhY2hTcGxpbmVcIiwtLjE1LC0uMDUsMCwwLC4xLDAsLS4wMywhMSwhMSksbz1mKFwibG93U3BsaW5lXCIsLS4xLC0uMSwuMDMsLjEsLjEsLjAxLC0uMDMsITEsITEpLGE9ZihcIm1pZFNwbGluZVwiLC0uMSwtLjEsLjAzLC4xLC43LC4wMSwtLjAzLCEwLCEwKSxoPWYoXCJoaWdoU3BsaW5lXCIsLS4wNSwuMywuMDMsLjEsMSwuMDEsLjAxLCEwLCEwKSxsPW5ldyBaKFwib2Zmc2V0U2FtcGxlclwiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCgtMS4xLC4wNDQpLmFkZFBvaW50KC0xLjAyLC0uMjIyMikuYWRkUG9pbnQoLS41MSwtLjIyMjIpLmFkZFBvaW50KC0uNDQsLS4xMikuYWRkUG9pbnQoLS4xOCwtLjEyKS5hZGRQb2ludCgtLjE2LHIpLmFkZFBvaW50KC0uMTUscikuYWRkUG9pbnQoLS4xLG8pLmFkZFBvaW50KC4yNSxhKS5hZGRQb2ludCgxLGgpLGM9bmV3IFooXCJGYWN0b3ItQ29udGluZW50c1wiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCgtLjE5LDUwNSkuYWRkUG9pbnQoLS4xNSxkKFwiZXJvc2lvbkNvYXN0XCIsODAwLCEwLFwicmlkZ2VDb2FzdC1PbGRNb3VudGFpbnNcIikpLmFkZFBvaW50KC0uMSxkKFwiZXJvc2lvbklubGFuZFwiLDcwMCwhMCxcInJpZGdlSW5sYW5kLU9sZE1vdW50YWluc1wiKSkuYWRkUG9pbnQoLjAzLGQoXCJlcm9zaW9uTWlkSW5sYW5kXCIsNjUwLCEwLFwicmlkZ2VNaWRJbmxhbmQtT2xkTW91bnRhaW5zXCIpKS5hZGRQb2ludCguMDYsZChcImVyb3Npb25GYXJJbmxhbmRcIiw2MDAsITEsXCJyaWRnZUZhcklubGFuZC1PbGRNb3VudGFpbnNcIikpLHU9bmV3IFooXCJQZWFrc1wiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCguMSwwKS5hZGRQb2ludCguMixuZXcgWihcIlBlYWtzLWVyb3Npb25cIiwodD0+dC5lcm9zaW9uKSkuYWRkUG9pbnQoLS44LG5ldyBaKFwiUGVha3MtZXJvc2lvbi1yaWRnZXNcIiwodD0+dC5yaWRnZXMpKS5hZGRQb2ludCgtMSwwKS5hZGRQb2ludCguMiwwKS5hZGRQb2ludCgxLG5ldyBaKFwiUGVha3MtZXJvc2lvbi1yaWRnZXMtd2VpcmRuZXNzXCIsKHQ9PnQud2VpcmRuZXNzKSkuYWRkUG9pbnQoLS4wMSw4MCkuYWRkUG9pbnQoLjAxLDIwKSkpLmFkZFBvaW50KC0uNCwwKSk7ZnVuY3Rpb24gZCh0LGUscyxpKXtjb25zdCBuPW5ldyBaKHQsKHQ9PnQuZXJvc2lvbikpLmFkZFBvaW50KC0uNixlKS5hZGRQb2ludCgtLjUsMzQyKS5hZGRQb2ludCgtLjM1LGUpLmFkZFBvaW50KC0uMjUsZSkuYWRkUG9pbnQoLS4xLDM0MikuYWRkUG9pbnQoLjAzLGUpO2lmKHMpe2NvbnN0IHQ9bmV3IFooXCJ3ZWlyZG5lc3NTaGF0dGVyZWRcIiwodD0+dC53ZWlyZG5lc3MpKS5hZGRQb2ludCgwLGUpLmFkZFBvaW50KC4xLDgwKSxzPW5ldyBaKFwicmlkZ2VzU2hhdHRlcmVkXCIsKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLS45LGUpLmFkZFBvaW50KC0uNjksdCk7bi5hZGRQb2ludCguMzUsZSkuYWRkUG9pbnQoLjQ1LHMpLmFkZFBvaW50KC41NSxzKS5hZGRQb2ludCguNjIsZSl9ZWxzZXtjb25zdCB0PW5ldyBaKGksKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLS43LGUpLmFkZFBvaW50KC0uMTUsMTc1KSxzPW5ldyBaKGksKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLjQ1LGUpLmFkZFBvaW50KC43LDIwMCk7bi5hZGRQb2ludCguMDUscykuYWRkUG9pbnQoLjQscykuYWRkUG9pbnQoLjQ1LHQpLmFkZFBvaW50KC41NSx0KS5hZGRQb2ludCguNTgsZSl9cmV0dXJuIG59ZnVuY3Rpb24gZih0LGUscyxpLG4scixvLGEsaCxsKXtjb25zdCBjPWcoTShyLC42LDEuNSksbCksdT1nKE0ociwuNiwxKSxsKSxkPWcocixsKSxmPXYodCtcIi13aWRlUGxhdGVhdVwiLGUtLjE1LC41KnIsTSguNSwuNSwuNSkqciwuNSpyLC42KnIsLjUpLHA9dih0K1wiLW5hcnJvd1BsYXRlYXVcIixlLG8qcixpKnIsLjUqciwuNipyLC41KSxtPXYodCtcIi1wbGFpbnNcIixlLG8sbyxpLG4sLjUpLHc9dih0K1wiLXBsYWluc0ZhcklubGFuZFwiLGUsbyxvLGksbiwuNSksYj1uZXcgWih0LCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0xLGUpLmFkZFBvaW50KC0uNCxtKS5hZGRQb2ludCgwLG4rLjA3KSxQPXYodCtcIi1zd2FtcHNcIiwtLjAyLGEsYSxpLG4sMCkseD1uZXcgWih0LCh0PT50LmVyb3Npb24pKS5hZGRQb2ludCgtLjg1LGMpLmFkZFBvaW50KC0uNyx1KS5hZGRQb2ludCgtLjQsZCkuYWRkUG9pbnQoLS4zNSxmKS5hZGRQb2ludCgtLjEscCkuYWRkUG9pbnQoLjIsbSk7cmV0dXJuIGgmJnguYWRkUG9pbnQoLjQsdykuYWRkUG9pbnQoLjQ1LGIpLmFkZFBvaW50KC41NSxiKS5hZGRQb2ludCguNTgsdykseC5hZGRQb2ludCguNyxQKSx4fWZ1bmN0aW9uIGcodCxlKXtjb25zdCBzPW5ldyBaKGBNLXNwbGluZSBmb3IgY29udGluZW50YWxuZXNzOiAke3R9ICR7ZX1gLCh0PT50LnJpZGdlcykpLGk9cCgtMSx0LC0uNyksbj1wKDEsdCwtLjcpLHI9ZnVuY3Rpb24odCl7cmV0dXJuLjUqKDEtdCkvKC40NjA4Mjk0NyooMS0uNSooMS10KSkpLTEuMTd9KHQpO2lmKC0uNjU8ciYmcjwxKXtjb25zdCBlPXAoLS42NSx0LC0uNyksbz1wKC0uNzUsdCwtLjcpLGE9bShpLG8sLTEsLS43NSk7cy5hZGRQb2ludCgtMSxpLGEpLHMuYWRkUG9pbnQoLS43NSxvKSxzLmFkZFBvaW50KC0uNjUsZSk7Y29uc3QgaD1wKHIsdCwtLjcpLGw9bShoLG4sciwxKTtzLmFkZFBvaW50KHItLjAxLGgpLHMuYWRkUG9pbnQocixoLGwpLHMuYWRkUG9pbnQoMSxuLGwpfWVsc2V7Y29uc3QgdD1tKGksbiwtMSwxKTtlPyhzLmFkZFBvaW50KC0xLE1hdGgubWF4KC4yLGkpKSxzLmFkZFBvaW50KDAsTSguNSxpLG4pLHQpKTpzLmFkZFBvaW50KC0xLGksdCkscy5hZGRQb2ludCgxLG4sdCl9cmV0dXJuIHN9ZnVuY3Rpb24gcCh0LGUscyl7Y29uc3QgaT0uNDYwODI5NDcqKHQrMS4xNykqKDEtLjUqKDEtZSkpLS41KigxLWUpO3JldHVybiB0PHM/TWF0aC5tYXgoaSwtLjIyMjIpOk1hdGgubWF4KGksMCl9ZnVuY3Rpb24gbSh0LGUscyxpKXtyZXR1cm4oZS10KS8oaS1zKX1mdW5jdGlvbiB2KHQsZSxzLGksbixyLG8pe2NvbnN0IGE9TWF0aC5tYXgoLjUqKHMtZSksbyksaD01KihpLXMpO3JldHVybiBuZXcgWih0LCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0xLGUsYSkuYWRkUG9pbnQoLS40LHMsTWF0aC5taW4oYSxoKSkuYWRkUG9pbnQoMCxpLGgpLmFkZFBvaW50KC40LG4sMioobi1pKSkuYWRkUG9pbnQoMSxyLC43KihyLW4pKX19KHh0fHwoeHQ9e30pKTtjbGFzcyBTdHtjb25zdHJ1Y3Rvcih0LGUscyxpLG4scixvKXt0aGlzLnBhcmFtZXRlcnM9ZSx0aGlzLnRlbXBlcmF0dXJlPW5ldyBZKG5ldyBXKHQpLHMuZmlyc3RPY3RhdmUscy5hbXBsaXR1ZGVzKSx0aGlzLmh1bWlkaXR5PW5ldyBZKG5ldyBXKHQrQmlnSW50KDEpKSxpLmZpcnN0T2N0YXZlLGkuYW1wbGl0dWRlcyksdGhpcy5jb250aW5lbnRhbG5lc3M9bmV3IFkobmV3IFcodCtCaWdJbnQoMikpLG4uZmlyc3RPY3RhdmUsbi5hbXBsaXR1ZGVzKSx0aGlzLmVyb3Npb249bmV3IFkobmV3IFcodCtCaWdJbnQoMykpLHIuZmlyc3RPY3RhdmUsci5hbXBsaXR1ZGVzKSx0aGlzLndlaXJkbmVzcz1uZXcgWShuZXcgVyh0K0JpZ0ludCg0KSksby5maXJzdE9jdGF2ZSxvLmFtcGxpdHVkZXMpLHRoaXMub2Zmc2V0PW5ldyBZKG5ldyBXKHQrQmlnSW50KDUpKSwtMyxbMSwxLDEsMV0pfWdldEJpb21lKHQsZSxzKXtjb25zdCBpPXQrdGhpcy5nZXRPZmZzZXQodCwwLHMpLG49ZSt0aGlzLmdldE9mZnNldChlLHMsdCkscj1zK3RoaXMuZ2V0T2Zmc2V0KHMsdCwwKSxvPXRoaXMudGVtcGVyYXR1cmUuc2FtcGxlKGksbixyKSxhPXRoaXMuaHVtaWRpdHkuc2FtcGxlKGksbixyKSxoPXRoaXMuY29udGluZW50YWxuZXNzLnNhbXBsZShpLDAsciksbD10aGlzLmVyb3Npb24uc2FtcGxlKGksMCxyKSxjPXRoaXMud2VpcmRuZXNzLnNhbXBsZShpLDAsciksdT14dC5vZmZzZXQoeHQucG9pbnQoaCxsLGMpKSxkPUF0LmNvbXB1dGVEaW1lbnNpb25EZW5zaXR5KDEsLS41MTg3NSw0KmUpK3UsZj1uZXcgUHQuVGFyZ2V0UG9pbnQobyxhLGgsbCxkLGMpO3JldHVybiB0aGlzLnBhcmFtZXRlcnMuZmluZChmKX1nZXRUZXJyYWluU2hhcGUodCxlKXtjb25zdCBzPXQrdGhpcy5nZXRPZmZzZXQodCwwLGUpLGk9ZSt0aGlzLmdldE9mZnNldChlLHQsMCksbj10aGlzLmNvbnRpbmVudGFsbmVzcy5zYW1wbGUocywwLGkpLHI9dGhpcy5lcm9zaW9uLnNhbXBsZShzLDAsaSksbz10aGlzLndlaXJkbmVzcy5zYW1wbGUocywwLGkpLGE9eHQucG9pbnQobixyLG8pLGg9eHQubmVhcldhdGVyKG4sbyk7cmV0dXJuIHh0LnNoYXBlKGEsaCl9Z2V0T2Zmc2V0KHQsZSxzKXtyZXR1cm4gNCp0aGlzLm9mZnNldC5zYW1wbGUodCxlLHMpfX1jbGFzcyBCdHtjb25zdHJ1Y3Rvcih0LGUscyxpLG4scil7dGhpcy5jZWxsQ291bnRZPWUsdGhpcy5jZWxsQ291bnRaPXMsdGhpcy5jZWxsTWluWT1uLHRoaXMuZmlsbGVyPXIsdGhpcy5ub2lzZTAwMD0wLHRoaXMubm9pc2UwMDE9MCx0aGlzLm5vaXNlMTAwPTAsdGhpcy5ub2lzZTEwMT0wLHRoaXMubm9pc2UwMTA9MCx0aGlzLm5vaXNlMDExPTAsdGhpcy5ub2lzZTExMD0wLHRoaXMubm9pc2UxMTE9MCx0aGlzLnZhbHVlWFowMD0wLHRoaXMudmFsdWVYWjEwPTAsdGhpcy52YWx1ZVhaMDE9MCx0aGlzLnZhbHVlWFoxMT0wLHRoaXMudmFsdWVaMD0wLHRoaXMudmFsdWVaMT0wLHRoaXMubWluQ2VsbFg9aVswXSp0LHRoaXMubWluQ2VsbFo9aVsxXSpzLHRoaXMuc2xpY2UwPUJ0LmFsbG9jYXRlU2xpY2UoZSxzKSx0aGlzLnNsaWNlMT1CdC5hbGxvY2F0ZVNsaWNlKGUscyl9c3RhdGljIGFsbG9jYXRlU2xpY2UodCxlKXtjb25zdCBzPUFycmF5KGUrMSk7Zm9yKGxldCBpPTA7aTxlKzE7aSs9MSlzW2ldPUFycmF5KHQrMSk7cmV0dXJuIHN9aW5pdGlhbGl6ZUZvckZpcnN0Q2VsbFgoKXt0aGlzLmZpbGxTbGljZSh0aGlzLnNsaWNlMCx0aGlzLm1pbkNlbGxYKX1hZHZhbmNlQ2VsbFgodCl7dGhpcy5maWxsU2xpY2UodGhpcy5zbGljZTEsdGhpcy5taW5DZWxsWCt0KzEpfWZpbGxTbGljZSh0LGUpe2ZvcihsZXQgcz0wO3M8dGhpcy5jZWxsQ291bnRaKzE7cys9MSl0aGlzLmZpbGxlcih0W3NdLGUsdGhpcy5taW5DZWxsWitzLHRoaXMuY2VsbE1pblksdGhpcy5jZWxsQ291bnRZKX1zZWxlY3RDZWxsWVoodCxlKXt0aGlzLm5vaXNlMDAwPXRoaXMuc2xpY2UwW2VdW3RdLHRoaXMubm9pc2UwMDE9dGhpcy5zbGljZTBbZSsxXVt0XSx0aGlzLm5vaXNlMTAwPXRoaXMuc2xpY2UxW2VdW3RdLHRoaXMubm9pc2UxMDE9dGhpcy5zbGljZTFbZSsxXVt0XSx0aGlzLm5vaXNlMDEwPXRoaXMuc2xpY2UwW2VdW3QrMV0sdGhpcy5ub2lzZTAxMT10aGlzLnNsaWNlMFtlKzFdW3QrMV0sdGhpcy5ub2lzZTExMD10aGlzLnNsaWNlMVtlXVt0KzFdLHRoaXMubm9pc2UxMTE9dGhpcy5zbGljZTFbZSsxXVt0KzFdfXVwZGF0ZUZvclkodCl7dGhpcy52YWx1ZVhaMDA9TSh0LHRoaXMubm9pc2UwMDAsdGhpcy5ub2lzZTAxMCksdGhpcy52YWx1ZVhaMTA9TSh0LHRoaXMubm9pc2UxMDAsdGhpcy5ub2lzZTExMCksdGhpcy52YWx1ZVhaMDE9TSh0LHRoaXMubm9pc2UwMDEsdGhpcy5ub2lzZTAxMSksdGhpcy52YWx1ZVhaMTE9TSh0LHRoaXMubm9pc2UxMDEsdGhpcy5ub2lzZTExMSl9dXBkYXRlRm9yWCh0KXt0aGlzLnZhbHVlWjA9TSh0LHRoaXMudmFsdWVYWjAwLHRoaXMudmFsdWVYWjEwKSx0aGlzLnZhbHVlWjE9TSh0LHRoaXMudmFsdWVYWjAxLHRoaXMudmFsdWVYWjExKX1jYWxjdWxhdGVWYWx1ZSh0KXtyZXR1cm4gTSh0LHRoaXMudmFsdWVaMCx0aGlzLnZhbHVlWjEpfXN3YXBTbGljZXMoKXtbdGhpcy5zbGljZTAsdGhpcy5zbGljZTFdPVt0aGlzLnNsaWNlMSx0aGlzLnNsaWNlMF19fWNsYXNzIEV0e2NvbnN0cnVjdG9yKHQsZSxzKXt0aGlzLnNlZWQ9dCx0aGlzLmJpb21lU291cmNlPWUsdGhpcy5zZXR0aW5ncz1zLHRoaXMuY2VsbEhlaWdodD1zLm5vaXNlLnlTaXplPDwyLHRoaXMuY2VsbFdpZHRoPXMubm9pc2UueHpTaXplPDwyLHRoaXMuY2VsbENvdW50WFo9TWF0aC5mbG9vcigxNi90aGlzLmNlbGxXaWR0aCksdGhpcy5jZWxsQ291bnRZPU1hdGguZmxvb3Iocy5ub2lzZS5oZWlnaHQvdGhpcy5jZWxsSGVpZ2h0KTtjb25zdCBpPW5ldyBXKHQpLG49bmV3IHooaSk7cy5ub2lzZS51c2VTaW1wbGV4U3VyZmFjZU5vaXNlP25ldyBYKGksWy0zLC0yLC0xLDBdKTpuZXcgVihpLC0zLFsxLDEsMSwxXSksaS5jb25zdW1lKDI2MjApLG5ldyBWKGksLTE1LFsxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSksdGhpcy5zYW1wbGVyPW5ldyBBdCh0aGlzLmNlbGxXaWR0aCx0aGlzLmNlbGxIZWlnaHQsdGhpcy5jZWxsQ291bnRZLGUscy5ub2lzZSxuKX1maWxsKHQpe2NvbnN0IGU9TWF0aC5tYXgodC5taW5ZLHRoaXMuc2V0dGluZ3Mubm9pc2UubWluWSkscz1NYXRoLm1pbih0Lm1heFksdGhpcy5zZXR0aW5ncy5ub2lzZS5taW5ZK3RoaXMuc2V0dGluZ3Mubm9pc2UuaGVpZ2h0KSxpPU1hdGguZmxvb3IoZS90aGlzLmNlbGxIZWlnaHQpLG49TWF0aC5mbG9vcigocy1lKS90aGlzLmNlbGxIZWlnaHQpLHI9ay5taW5CbG9ja1godC5wb3MpLG89ay5taW5CbG9ja1oodC5wb3MpLGE9bmV3IEJ0KHRoaXMuY2VsbENvdW50WFosbix0aGlzLmNlbGxDb3VudFhaLHQucG9zLGksdGhpcy5zYW1wbGVyLmZpbGxOb2lzZUNvbHVtbi5iaW5kKHRoaXMuc2FtcGxlcikpLGg9QXJyYXkoYSk7aC5mb3JFYWNoKCh0PT50LmluaXRpYWxpemVGb3JGaXJzdENlbGxYKCkpKTtmb3IobGV0IGU9MDtlPHRoaXMuY2VsbENvdW50WFo7ZSs9MSl7aC5mb3JFYWNoKCh0PT50LmFkdmFuY2VDZWxsWChlKSkpO2ZvcihsZXQgcz0wO3M8dGhpcy5jZWxsQ291bnRYWjtzKz0xKXtsZXQgbD10LmdldE9yQ3JlYXRlU2VjdGlvbih0LnNlY3Rpb25zQ291bnQtMSk7Zm9yKGxldCBjPW4tMTtjPj0wO2MtPTEpe2guZm9yRWFjaCgodD0+dC5zZWxlY3RDZWxsWVooYyxzKSkpO2ZvcihsZXQgbj10aGlzLmNlbGxIZWlnaHQtMTtuPj0wO24tPTEpe2NvbnN0IHU9KGkrYykqdGhpcy5jZWxsSGVpZ2h0K24sZD0xNSZ1LGY9dC5nZXRTZWN0aW9uSW5kZXgodSk7dC5nZXRTZWN0aW9uSW5kZXgobC5taW5CbG9ja1kpIT09ZiYmKGw9dC5nZXRPckNyZWF0ZVNlY3Rpb24oZikpO2NvbnN0IGc9bi90aGlzLmNlbGxIZWlnaHQ7aC5mb3JFYWNoKCh0PT50LnVwZGF0ZUZvclkoZykpKTtmb3IobGV0IHQ9MDt0PHRoaXMuY2VsbFdpZHRoO3QrPTEpe2NvbnN0IGk9citlKnRoaXMuY2VsbFdpZHRoK3Qsbj0xNSZpLGM9dC90aGlzLmNlbGxXaWR0aDtoLmZvckVhY2goKHQ9PnQudXBkYXRlRm9yWChjKSkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jZWxsV2lkdGg7dCs9MSl7Y29uc3QgZT1vK3MqdGhpcy5jZWxsV2lkdGgrdCxyPTE1JmUsaD10L3RoaXMuY2VsbFdpZHRoLGM9YS5jYWxjdWxhdGVWYWx1ZShoKSxmPXRoaXMuYmFzZVN0YXRlKGksdSxlLGMpO2YuZXF1YWxzKEIuQUlSKXx8bC5zZXRCbG9ja1N0YXRlKG4sZCxyLGYpfX19fX1oLmZvckVhY2goKHQ9PnQuc3dhcFNsaWNlcygpKSl9fWJhc2VTdGF0ZSh0LGUscyxpKXtyZXR1cm4oaT0oaT1GKGkvMjAwLC0xLDEpKS8yLWkqaSppLzI0KT4wP3RoaXMuc2V0dGluZ3MuZGVmYXVsdEJsb2NrOmU8dGhpcy5zZXR0aW5ncy5zZWFMZXZlbD90aGlzLnNldHRpbmdzLmRlZmF1bHRGbHVpZDpCLkFJUn19ZXhwb3J0e3ogYXMgQmxlbmRlZE5vaXNlLHN0IGFzIEJsb2NrQ29sb3JzLG90IGFzIEJsb2NrRGVmaW5pdGlvbix1dCBhcyBCbG9ja01vZGVsLG8gYXMgQmxvY2tQb3MsQiBhcyBCbG9ja1N0YXRlLEMgYXMgQ2h1bmssayBhcyBDaHVua1BvcyxFIGFzIENodW5rU2VjdGlvbixQdCBhcyBDbGltYXRlLG4gYXMgRGlyZWN0aW9uLHl0IGFzIEZpeGVkQmlvbWUsTCBhcyBJbXByb3ZlZE5vaXNlLFN0IGFzIE11bHRpTm9pc2UsbCBhcyBOYnRSZWFkZXIsYyBhcyBOYnRXcml0ZXIsRXQgYXMgTm9pc2VDaHVua0dlbmVyYXRvcixCdCBhcyBOb2lzZUludGVycG9sYXRvcixBdCBhcyBOb2lzZVNhbXBsZXIsWSBhcyBOb3JtYWxOb2lzZSxWIGFzIFBlcmxpbk5vaXNlLFggYXMgUGVybGluU2ltcGxleE5vaXNlLEggYXMgUmFuZG9tLE8gYXMgU2ltcGxleE5vaXNlLFogYXMgU3BsaW5lLEkgYXMgU3RydWN0dXJlLHZ0IGFzIFN0cnVjdHVyZVJlbmRlcmVyLHh0IGFzIFRlcnJhaW5TaGFwZXIsYnQgYXMgVGV4dHVyZUF0bGFzLFcgYXMgV29ybGRnZW5SYW5kb20sRCBhcyBiaW5hcnlTZWFyY2gsRiBhcyBjbGFtcCxfIGFzIGNsYW1wZWRMZXJwLEEgYXMgZ2V0TGlzdFRhZyxTIGFzIGdldE9wdGlvbmFsLHkgYXMgZ2V0VGFnLE0gYXMgbGVycCxUIGFzIGxlcnAyLE4gYXMgbGVycDMsZiBhcyByZWFkLHAgYXMgcmVhZENodW5rLGQgYXMgcmVhZENvbXByZXNzZWQsZyBhcyByZWFkUmVnaW9uLHUgYXMgcmVhZFVuY29tcHJlc3NlZCxVIGFzIHNtb290aHN0ZXAsUiBhcyBzcXVhcmUsaCBhcyB0YWdOYW1lcyxhIGFzIHRhZ1R5cGVzLHcgYXMgd3JpdGUsUCBhcyB3cml0ZUNodW5rLHYgYXMgd3JpdGVDb21wcmVzc2VkLGIgYXMgd3JpdGVSZWdpb24sbSBhcyB3cml0ZVVuY29tcHJlc3NlZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwc2xhdGUuZXNtLmpzLm1hcFxuIiwiLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XHJcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxyXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXHJcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICB2YXIgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICB2YXIgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCB7IEFCQmlvbWVSZW5kZXJlciwgRWxlbWVudFJlbmRlcmVyIH0gZnJvbSAnLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyJ1xuaW1wb3J0IHsgQmlvbWUgfSBmcm9tICcuL0Jpb21lJ1xuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSAnLi9CaW9tZUJ1aWxkZXInXG5pbXBvcnQge0xheW91dEVsZW1lbnQsIE1vZGV9IGZyb20gJy4vTGF5b3V0RWxlbWVudCdcblxuZXhwb3J0IGNsYXNzIEFCRWxlbWVudCBpbXBsZW1lbnRzIExheW91dEVsZW1lbnR7XG4gICAgcmVhZG9ubHkgYWxsb3dFZGl0OiBib29sZWFuID0gZmFsc2VcbiAgICByZWFkb25seSBlbGVtZW50QTogc3RyaW5nXG4gICAgcmVhZG9ubHkgZWxlbWVudEI6IHN0cmluZ1xuXG4gICAgcHJpdmF0ZSBidWlsZGVyOiBCaW9tZUJ1aWxkZXJcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBBQkJpb21lUmVuZGVyZXJcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmdcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoYnVpbGRlcjogQmlvbWVCdWlsZGVyLCBlbGVtZW50QTogc3RyaW5nLCBlbGVtZW50Qjogc3RyaW5nKXtcbiAgICAgICAgdGhpcy5lbGVtZW50QSA9IGVsZW1lbnRBXG4gICAgICAgIHRoaXMuZWxlbWVudEIgPSBlbGVtZW50QlxuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyXG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZShidWlsZGVyOiBCaW9tZUJ1aWxkZXIsIGVsZW1lbnRBOiBzdHJpbmcsIGVsZW1lbnRCOiBzdHJpbmcpOiBBQkVsZW1lbnR7XG4gICAgICAgIGNvbnN0IGFiX2Jpb21lID0gbmV3IEFCRWxlbWVudChidWlsZGVyLCBlbGVtZW50QSwgZWxlbWVudEIpXG4gICAgICAgIGJ1aWxkZXIucmVnaXN0ZXJMYXlvdXRFbGVtZW50KGFiX2Jpb21lKTtcbiAgICAgICAgcmV0dXJuIGFiX2Jpb21lXG4gICAgfVxuXG4gICAgbG9va3VwS2V5KHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyKTogc3RyaW5ne1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKVxuICAgIH1cblxuICAgIGxvb2t1cCh0ZW1wZXJhdHVyZUluZGV4OiBudW1iZXIsIGh1bWlkaXR5SW5kZXg6IG51bWJlcik6IEFCRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgbG9va3VwUmVjdXJzaXZlKHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyLCBtb2RlOiBNb2RlKTogTGF5b3V0RWxlbWVudCB7XG4gICAgICAgIGlmIChtb2RlID09PSBcIkFueVwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJBXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRlci5nZXRMYXlvdXRFbGVtZW50KHRoaXMuZWxlbWVudEEpLmxvb2t1cFJlY3Vyc2l2ZSh0ZW1wZXJhdHVyZUluZGV4LCBodW1pZGl0eUluZGV4LCBtb2RlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRlci5nZXRMYXlvdXRFbGVtZW50KHRoaXMuZWxlbWVudEIpLmxvb2t1cFJlY3Vyc2l2ZSh0ZW1wZXJhdHVyZUluZGV4LCBodW1pZGl0eUluZGV4LCBtb2RlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudChtb2RlOiBcIkFcIiB8IFwiQlwiKXtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiQVwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkZXIuZ2V0TGF5b3V0RWxlbWVudCh0aGlzLmVsZW1lbnRBKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRlci5nZXRMYXlvdXRFbGVtZW50KHRoaXMuZWxlbWVudEIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSZW5kZXJlcigpOiBFbGVtZW50UmVuZGVyZXIge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBBQkJpb21lUmVuZGVyZXIodGhpcylcblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlclxuICAgIH1cblxuICAgIGdldEtleSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50QSArIFwiL1wiICsgdGhpcy5lbGVtZW50QlxuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyB1bmlxaWQgZnJvbSAndW5pcWlkJ1xuaW1wb3J0IHsgQmlvbWVSZW5kZXJlciwgRWxlbWVudFJlbmRlcmVyIH0gZnJvbSAnLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyJ1xuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSAnLi9CaW9tZUJ1aWxkZXInXG5pbXBvcnQge0xheW91dEVsZW1lbnQsIE1vZGV9IGZyb20gJy4vTGF5b3V0RWxlbWVudCdcblxuZXhwb3J0IGNsYXNzIEJpb21lIGltcGxlbWVudHMgTGF5b3V0RWxlbWVudHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICByZWFkb25seSBhbGxvd0VkaXQ6IGJvb2xlYW4gPSB0cnVlXG5cbiAgICBwdWJsaWMgY29sb3I6IHN0cmluZ1xuICAgIHByaXZhdGUgcmVuZGVyZXI6IEJpb21lUmVuZGVyZXJcbiAgICBwcml2YXRlIGlzVmFuaWxsYTogYm9vbGVhblxuXG4gICAgcHJpdmF0ZSBrZXk6IHN0cmluZ1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcsIGtleT86IHN0cmluZywgaXNWYW5pbGxhOiBib29sZWFuID0gZmFsc2Upe1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleVxuICAgICAgICBlbHNlIGlmIChpc1ZhbmlsbGEpXG4gICAgICAgICAgICB0aGlzLmtleSA9IG5hbWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5rZXkgPSB1bmlxaWQoJ2Jpb21lXycpXG4gICAgICAgIHRoaXMuYWxsb3dFZGl0ID0gIWlzVmFuaWxsYVxuICAgICAgICB0aGlzLmlzVmFuaWxsYSA9IGlzVmFuaWxsYVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUoYnVpbGRlcjogQmlvbWVCdWlsZGVyLCBuYW1lOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcsIGtleT86IHN0cmluZywgaXNWYW5pbGxhOiBib29sZWFuID0gZmFsc2UpOiBCaW9tZXtcbiAgICAgICAgY29uc3QgYmlvbWUgPSBuZXcgQmlvbWUobmFtZSwgY29sb3IsIGtleSwgaXNWYW5pbGxhKVxuICAgICAgICBpZiAoaXNWYW5pbGxhKVxuICAgICAgICAgICAgYnVpbGRlci5yZWdpc3RlclZhbmlsbGFCaW9tZShiaW9tZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnVpbGRlci5yZWdpc3RlckxheW91dEVsZW1lbnQoYmlvbWUpO1xuICAgICAgICByZXR1cm4gYmlvbWVcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUpTT04oYnVpbGRlcjogQmlvbWVCdWlsZGVyLCBqc29uOiBhbnkpe1xuICAgICAgICBpZiAoYnVpbGRlci52YW5pbGxhQmlvbWVzLmhhcyhqc29uLmtleSkpe1xuICAgICAgICAgICAgYnVpbGRlci5yZWdpc3RlckxheW91dEVsZW1lbnQoYnVpbGRlci52YW5pbGxhQmlvbWVzLmdldChqc29uLmtleSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiaW9tZSA9IG5ldyBCaW9tZShqc29uLm5hbWUsIGpzb24uY29sb3IsIGpzb24ua2V5LCBmYWxzZSlcbiAgICAgICAgICAgIGJ1aWxkZXIucmVnaXN0ZXJMYXlvdXRFbGVtZW50KGJpb21lKTtcbiAgICAgICAgICAgIHJldHVybiBiaW9tZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KU09OKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuaXNWYW5pbGxhID8gdW5kZWZpbmVkIDogdGhpcy5jb2xvclxuICAgICAgICB9XG4gICAgfSAgICBcblxuICAgIGxvb2t1cEtleSh0ZW1wZXJhdHVyZUluZGV4OiBudW1iZXIsIGh1bWlkaXR5SW5kZXg6IG51bWJlcik6IHN0cmluZ3tcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KClcbiAgICB9XG5cbiAgICBsb29rdXAodGVtcGVyYXR1cmVJbmRleDogbnVtYmVyLCBodW1pZGl0eUluZGV4OiBudW1iZXIpOiBCaW9tZSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgbG9va3VwUmVjdXJzaXZlKHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyLCBtb2RlOiBNb2RlKTogQmlvbWUge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFJlbmRlcmVyKCk6IEVsZW1lbnRSZW5kZXJlciB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IEJpb21lUmVuZGVyZXIodGhpcylcblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlclxuICAgIH1cblxuICAgIGdldEtleSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlcbiAgICB9XG5cblxufVxuXG4iLCJpbXBvcnQgeyBDbGltYXRlIH0gZnJvbSBcImRlZXBzbGF0ZVwiXG5pbXBvcnQgeyBVbmFzc2lnbmVkUmVuZGVyZXIgfSBmcm9tIFwiLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyXCJcbmltcG9ydCB7IFZhbmlsbGFCaW9tZXMgfSBmcm9tIFwiLi4vVmFuaWxsYS9WYW5pbGxhQmlvbWVzXCJcbmltcG9ydCB7IEFCRWxlbWVudCB9IGZyb20gXCIuL0FCQmlvbWVcIlxuaW1wb3J0IHsgQmlvbWUgfSBmcm9tIFwiLi9CaW9tZVwiXG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiLi9MYXlvdXRcIlxuaW1wb3J0IHsgTGF5b3V0RWxlbWVudCB9IGZyb20gXCIuL0xheW91dEVsZW1lbnRcIlxuaW1wb3J0IHsgTGF5b3V0RWxlbWVudER1bW15IH0gZnJvbSBcIi4vTGF5b3V0RWxlbWVudER1bW15XCJcbmltcG9ydCB7IExheW91dEVsZW1lbnRVbmFzc2lnbmVkIH0gZnJvbSBcIi4vTGF5b3V0RWxlbWVudFVuYXNzaWduZWRcIlxuXG5pbXBvcnQgeyBTbGljZSB9IGZyb20gXCIuL1NsaWNlXCJcblxuZXhwb3J0IGNsYXNzIEJpb21lQnVpbGRlcntcbiAgICBjb250aW5lbnRhbG5lc3NlczogW3N0cmluZywgQ2xpbWF0ZS5QYXJhbV1bXVxuICAgIGVyb3Npb25zOiBbc3RyaW5nLENsaW1hdGUuUGFyYW1dW11cbiAgICB3ZWlyZG5lc3NlczogW3N0cmluZyxDbGltYXRlLlBhcmFtLCBzdHJpbmcsIFwiQVwifFwiQlwiXVtdXG4gICAgdGVtcGVyYXR1cmVzOiBbc3RyaW5nLENsaW1hdGUuUGFyYW1dW11cbiAgICBodW1pZGl0aWVzOiBbc3RyaW5nLENsaW1hdGUuUGFyYW1dW11cblxuICAgIHJlbmRlcmVkRWxlbWVudHM6IE1hcDxzdHJpbmcsIExheW91dEVsZW1lbnQgfCBTbGljZT5cbiAgICBsYXlvdXRFbGVtZW50czogTWFwPHN0cmluZywgTGF5b3V0RWxlbWVudD5cbiAgICB2YW5pbGxhQmlvbWVzOiBNYXA8c3RyaW5nLCBCaW9tZT5cblxuICAgIHNsaWNlczogU2xpY2VbXVxuICAgIGxheW91dHM6IExheW91dFtdXG4gICAgYmlvbWVzOiBCaW9tZVtdXG5cblxuICAgIGxheW91dEVsZW1lbnREdW1teTogTGF5b3V0RWxlbWVudER1bW15XG4gICAgbGF5b3V0RWxlbWVudFVuYXNzaWduZWQ6IExheW91dEVsZW1lbnRVbmFzc2lnbmVkXG5cbiAgICBjb25zdHJ1Y3Rvcihjb250aW5lbnRhbG5lc3NlczogW3N0cmluZywgQ2xpbWF0ZS5QYXJhbV1bXSwgZXJvc2lvbnM6IFtzdHJpbmcsQ2xpbWF0ZS5QYXJhbV1bXSwgd2VpcmRuZXNzZXM6IFtzdHJpbmcsQ2xpbWF0ZS5QYXJhbV1bXSwgdGVtcGVyYXR1cmVzOiBbc3RyaW5nLENsaW1hdGUuUGFyYW1dW10sIGh1bWlkaXRpZXM6IFtzdHJpbmcsQ2xpbWF0ZS5QYXJhbV1bXSl7XG4gICAgICAgIHRoaXMuY29udGluZW50YWxuZXNzZXMgPSBjb250aW5lbnRhbG5lc3Nlc1xuICAgICAgICB0aGlzLmVyb3Npb25zID0gZXJvc2lvbnNcbiAgICAgICAgdGhpcy53ZWlyZG5lc3NlcyA9IHdlaXJkbmVzc2VzLm1hcCh3ID0+IFt3WzBdLCB3WzFdLCBcInVuYXNzaWduZWRcIiwgXCJBXCJdKVxuICAgICAgICB0aGlzLnRlbXBlcmF0dXJlcyA9IHRlbXBlcmF0dXJlc1xuICAgICAgICB0aGlzLmh1bWlkaXRpZXMgPSBodW1pZGl0aWVzXG5cbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIExheW91dEVsZW1lbnQgfCBTbGljZT4oKTtcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBMYXlvdXRFbGVtZW50PigpO1xuICAgICAgICB0aGlzLnZhbmlsbGFCaW9tZXMgPSBuZXcgTWFwPHN0cmluZywgQmlvbWU+KCk7XG4gICAgICAgIHRoaXMuc2xpY2VzID0gW11cbiAgICAgICAgdGhpcy5sYXlvdXRzID0gW11cbiAgICAgICAgdGhpcy5iaW9tZXMgPSBbXVxuXG4gICAgICAgIFxuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnREdW1teSA9IExheW91dEVsZW1lbnREdW1teS5jcmVhdGUodGhpcylcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50VW5hc3NpZ25lZCA9IExheW91dEVsZW1lbnRVbmFzc2lnbmVkLmNyZWF0ZSh0aGlzKVxuICAgIH1cblxuICAgIGxvYWRKU09OKGpzb246IGFueSl7XG5cbiAgICAgICAgdGhpcy5jb250aW5lbnRhbG5lc3NlcyA9IGpzb24uY29udGluZW50YWxuZXNzZXNcbiAgICAgICAgdGhpcy5lcm9zaW9ucyA9IGpzb24uZXJvc2lvbnNcbiAgICAgICAgdGhpcy53ZWlyZG5lc3NlcyA9IGpzb24ud2VpcmRuZXNzZXNcbiAgICAgICAgdGhpcy50ZW1wZXJhdHVyZXMgPSBqc29uLnRlbXBlcmF0dXJlc1xuICAgICAgICB0aGlzLmh1bWlkaXRpZXMgPSBqc29uLmh1bWlkaXRpZXNcblxuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmNsZWFyKClcbiAgICAgICAgdGhpcy5sYXlvdXRzID0gW11cbiAgICAgICAgdGhpcy5iaW9tZXMgPSBbXVxuICAgICAgICB0aGlzLnNsaWNlcyA9IFtdXG5cbiAgICAgICAgVmFuaWxsYUJpb21lcy5yZWdpc3RlclZhbmlsbGFCaW9tZXModGhpcylcbiAgICAgICAgdGhpcy5yZWdpc3RlckxheW91dEVsZW1lbnQodGhpcy5sYXlvdXRFbGVtZW50RHVtbXkpXG4gICAgICAgIHRoaXMucmVnaXN0ZXJMYXlvdXRFbGVtZW50KHRoaXMubGF5b3V0RWxlbWVudFVuYXNzaWduZWQpXG5cbiAgICAgICAganNvbi5zbGljZXM/LmZvckVhY2goKHNsaWNlIDogYW55KSA9PiB7XG4gICAgICAgICAgICBTbGljZS5mcm9tSlNPTih0aGlzLCBzbGljZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAganNvbi5sYXlvdXRzPy5mb3JFYWNoKChsYXlvdXQgOiBhbnkpID0+IHtcbiAgICAgICAgICAgIExheW91dC5mcm9tSlNPTih0aGlzLCBsYXlvdXQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGpzb24uYmlvbWVzPy5mb3JFYWNoKChiaW9tZSA6IGFueSkgPT4ge1xuICAgICAgICAgICAgQmlvbWUuZnJvbUpTT04odGhpcywgYmlvbWUpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvSlNPTigpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGluZW50YWxuZXNzZXM6IHRoaXMuY29udGluZW50YWxuZXNzZXMsXG4gICAgICAgICAgICBlcm9zaW9uczogdGhpcy5lcm9zaW9ucyxcbiAgICAgICAgICAgIHdlaXJkbmVzc2VzOiB0aGlzLndlaXJkbmVzc2VzLm1hcCh3ZWlyZG5lc3MgPT4ge1xuICAgICAgICAgICAgICAgIHdlaXJkbmVzc1syXSA9IHRoaXMuZ2V0U2xpY2Uod2VpcmRuZXNzWzJdKS5nZXRLZXkoKVxuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlyZG5lc3NcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGVtcGVyYXR1cmVzOiB0aGlzLnRlbXBlcmF0dXJlcyxcbiAgICAgICAgICAgIGh1bWlkaXRpZXM6IHRoaXMuaHVtaWRpdGllcyxcbiAgICAgICAgICAgIGxheW91dHM6IHRoaXMubGF5b3V0cyxcbiAgICAgICAgICAgIHNsaWNlczogdGhpcy5zbGljZXMsXG4gICAgICAgICAgICBiaW9tZXM6IHRoaXMuYmlvbWVzXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldFNsaWNlKG5hbWU6IHN0cmluZyl7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkRWxlbWVudHMuZ2V0KG5hbWUpID8/IHRoaXMubGF5b3V0RWxlbWVudFVuYXNzaWduZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlbmRlcmVkRWxlbWVudChuYW1lOiBzdHJpbmcpOiBMYXlvdXRFbGVtZW50IHwgU2xpY2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZEVsZW1lbnRzLmdldChuYW1lKSA/PyB0aGlzLmxheW91dEVsZW1lbnRVbmFzc2lnbmVkXG4gICAgfVxuXG4gICAgcHVibGljIGdldExheW91dEVsZW1lbnQobmFtZTogc3RyaW5nKTogTGF5b3V0RWxlbWVudHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmxheW91dEVsZW1lbnRzLmdldChuYW1lKVxuICAgICAgICAvKlxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIHRoaXMudmFuaWxsYUJpb21lcy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMudmFuaWxsYUJpb21lcy5nZXQobmFtZSlcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJMYXlvdXRFbGVtZW50KGVsZW1lbnQpXG4gICAgICAgIH0qL1xuXG4gICAgICAgIFxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGNvbnN0IGJpb21lS2V5cyA9IG5hbWUuc3BsaXQoJy8nKVxuICAgICAgICAgICAgaWYgKGJpb21lS2V5cy5sZW5ndGggIT09IDIpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEVsZW1lbnRVbmFzc2lnbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJpb21lQSA6IEJpb21lID0gdGhpcy5nZXRMYXlvdXRFbGVtZW50KGJpb21lS2V5c1swXSkgYXMgQmlvbWVcbiAgICAgICAgICAgIGNvbnN0IGJpb21lQiA6IEJpb21lICA9IHRoaXMuZ2V0TGF5b3V0RWxlbWVudChiaW9tZUtleXNbMV0pIGFzIEJpb21lXG5cbiAgICAgICAgICAgIHJldHVybiBBQkVsZW1lbnQuY3JlYXRlKHRoaXMsIGJpb21lQS5nZXRLZXkoKSwgYmlvbWVCLmdldEtleSgpKVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHJlZ2lzdGVyU2xpY2Uoc2xpY2U6IFNsaWNlKXtcbiAgICAgICAgdGhpcy5zbGljZXMucHVzaChzbGljZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50cy5zZXQoc2xpY2UuZ2V0S2V5KCksIHNsaWNlKVxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVTbGljZShzbGljZTogU2xpY2Upe1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2xpY2VzLmluZGV4T2Yoc2xpY2UpXG4gICAgICAgIGlmIChpbmRleCA+IC0xKXtcbiAgICAgICAgICAgIHRoaXMuc2xpY2VzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudHMuZGVsZXRlKHNsaWNlLmdldEtleSgpKVxuICAgIH1cblxuICAgIHB1YmxpYyByZWdpc3RlclZhbmlsbGFCaW9tZShiaW9tZTogQmlvbWUpe1xuICAgICAgICB0aGlzLnZhbmlsbGFCaW9tZXMuc2V0KGJpb21lLmdldEtleSgpLCBiaW9tZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50cy5zZXQoYmlvbWUuZ2V0S2V5KCksIGJpb21lKVxuICAgIH1cblxuICAgIHB1YmxpYyByZWdpc3RlckxheW91dEVsZW1lbnQoZWxlbWVudDogTGF5b3V0RWxlbWVudCl7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuc2V0KGVsZW1lbnQuZ2V0S2V5KCksIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudHMuc2V0KGVsZW1lbnQuZ2V0S2V5KCksIGVsZW1lbnQpXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KXtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0cy5wdXNoKGVsZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCaW9tZSl7XG4gICAgICAgICAgICB0aGlzLmJpb21lcy5wdXNoKGVsZW1lbnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGF5b3V0RWxlbWVudChlbGVtZW50OiBMYXlvdXRFbGVtZW50KXtcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5kZWxldGUoZWxlbWVudC5nZXRLZXkoKSlcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnRzLmRlbGV0ZShlbGVtZW50LmdldEtleSgpKVxuXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KXtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sYXlvdXRzLmluZGV4T2YoZWxlbWVudClcbiAgICAgICAgICAgIHRoaXMubGF5b3V0cy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCaW9tZSl7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYmlvbWVzLmluZGV4T2YoZWxlbWVudClcbiAgICAgICAgICAgIHRoaXMuYmlvbWVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE51bVRlbXBlcmF0dXJlcygpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wZXJhdHVyZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgZ2V0TnVtSHVtaWRpdGllcygpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wZXJhdHVyZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgZ2V0TnVtQ29udGluZW50YWxuZXNzZXMoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGluZW50YWxuZXNzZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgZ2V0TnVtRXJvc2lvbnMoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJvc2lvbnMubGVuZ3RoXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmlvbWUgfSBmcm9tIFwiLi9CaW9tZVwiO1xuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSBcIi4vQmlvbWVCdWlsZGVyXCI7XG5pbXBvcnQgeyBMYXlvdXRFbGVtZW50VW5hc3NpZ25lZCB9IGZyb20gXCIuL0xheW91dEVsZW1lbnRVbmFzc2lnbmVkXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgRXhwb3J0ZXIge1xuICAgIHByaXZhdGUgYnVpbGRlcjogQmlvbWVCdWlsZGVyXG5cbiAgICBjb25zdHJ1Y3RvcihidWlsZGVyOiBCaW9tZUJ1aWxkZXIpIHtcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlclxuICAgIH1cblxuICAgIHB1YmxpYyBleHBvcnQoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgYXJyYXk6IHsgYmlvbWU6IHN0cmluZywgZG9uZTogYm9vbGVhbiB9W11bXVtdW11bXSA9IFtdXG5cbiAgICAgICAgZm9yIChsZXQgd19pZHggPSAwOyB3X2lkeCA8IHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlcy5sZW5ndGg7IHdfaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gdGhpcy5idWlsZGVyLmdldFNsaWNlKHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlc1t3X2lkeF1bMl0pXG4gICAgICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW3dfaWR4XVszXVxuXG4gICAgICAgICAgICBhcnJheVt3X2lkeF0gPSBbXVxuXG4gICAgICAgICAgICBmb3IgKGxldCBjX2lkeCA9IDA7IGNfaWR4IDwgdGhpcy5idWlsZGVyLmNvbnRpbmVudGFsbmVzc2VzLmxlbmd0aDsgY19pZHgrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W3dfaWR4XVtjX2lkeF0gPSBbXVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVfaWR4ID0gMDsgZV9pZHggPCB0aGlzLmJ1aWxkZXIuZXJvc2lvbnMubGVuZ3RoOyBlX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3dfaWR4XVtjX2lkeF1bZV9pZHhdID0gW11cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gc2xpY2U/Lmxvb2t1cChjX2lkeCwgZV9pZHgpXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdF9pZHggPSAwOyB0X2lkeCA8IHRoaXMuYnVpbGRlci50ZW1wZXJhdHVyZXMubGVuZ3RoOyB0X2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt3X2lkeF1bY19pZHhdW2VfaWR4XVt0X2lkeF0gPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaF9pZHggPSAwOyBoX2lkeCA8IHRoaXMuYnVpbGRlci5odW1pZGl0aWVzLmxlbmd0aDsgaF9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpb21lID0gbGF5b3V0Py5sb29rdXBSZWN1cnNpdmUodF9pZHgsIGhfaWR4LCBtb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW9tZSA9PT0gdW5kZWZpbmVkIHx8IGJpb21lIGluc3RhbmNlb2YgTGF5b3V0RWxlbWVudFVuYXNzaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbd19pZHhdW2NfaWR4XVtlX2lkeF1bdF9pZHhdW2hfaWR4XSA9IHsgYmlvbWU6IFwiXCIsIGRvbmU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmlvbWUgaW5zdGFuY2VvZiBCaW9tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt3X2lkeF1bY19pZHhdW2VfaWR4XVt0X2lkeF1baF9pZHhdID0geyBiaW9tZTogYmlvbWUubmFtZSwgZG9uZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRhdGEgc3RydWN0dXJlIGNvcnJ1cHRpb24gYXQgdzogXCIgKyB3X2lkeCwgKyBcIiBjOiBcIiArIGNfaWR4ICsgXCIgZTogXCIgKyBlX2lkeCArIFwiIHQ6IFwiICsgdF9pZHggKyBcIiBoOiBcIiArIGhfaWR4ICsgXCIgLSBGb3VuZCBlbGVtZW50IG9mIHR5cGUgXCIgKyBiaW9tZS5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJpb21lczogeyBwYXJhbWV0ZXJzOiB7IHdlaXJkbmVzczogW251bWJlciwgbnVtYmVyXSwgY29udGluZW50YWxuZXNzOiBbbnVtYmVyLCBudW1iZXJdLCBlcm9zaW9uOiBbbnVtYmVyLCBudW1iZXJdLCB0ZW1wZXJhdHVyZTogW251bWJlciwgbnVtYmVyXSwgaHVtaWRpdHk6IFtudW1iZXIsIG51bWJlcl0sIGRlcHRoOiBudW1iZXIsIG9mZnNldDogbnVtYmVyIH0sIGJpb21lOiBzdHJpbmcgfVtdID0gW11cblxuICAgICAgICBmb3IgKGxldCB3X2lkeCA9IDA7IHdfaWR4IDwgdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzLmxlbmd0aDsgd19pZHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY19pZHggPSAwOyBjX2lkeCA8IHRoaXMuYnVpbGRlci5jb250aW5lbnRhbG5lc3Nlcy5sZW5ndGg7IGNfaWR4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlX2lkeCA9IDA7IGVfaWR4IDwgdGhpcy5idWlsZGVyLmVyb3Npb25zLmxlbmd0aDsgZV9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0X2lkeCA9IDA7IHRfaWR4IDwgdGhpcy5idWlsZGVyLnRlbXBlcmF0dXJlcy5sZW5ndGg7IHRfaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGhfaWR4ID0gMDsgaF9pZHggPCB0aGlzLmJ1aWxkZXIuaHVtaWRpdGllcy5sZW5ndGg7IGhfaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlbd19pZHhdW2NfaWR4XVtlX2lkeF1bdF9pZHhdW2hfaWR4XS5kb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heF9lX2lkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobWF4X2VfaWR4ID0gZV9pZHg7IG1heF9lX2lkeCA8IHRoaXMuYnVpbGRlci5lcm9zaW9ucy5sZW5ndGg7IG1heF9lX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1JhbmdlKGFycmF5LCB3X2lkeCwgY19pZHgsIGVfaWR4LCB0X2lkeCwgaF9pZHgsIHdfaWR4LCBjX2lkeCwgbWF4X2VfaWR4LCB0X2lkeCwgaF9pZHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4X2VfaWR4LS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhfd19pZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG1heF93X2lkeCA9IHdfaWR4OyBtYXhfd19pZHggPCB0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXMubGVuZ3RoOyBtYXhfd19pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tSYW5nZShhcnJheSwgd19pZHgsIGNfaWR4LCBlX2lkeCwgdF9pZHgsIGhfaWR4LCBtYXhfd19pZHgsIGNfaWR4LCBtYXhfZV9pZHgsIHRfaWR4LCBoX2lkeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfd19pZHgtLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heF9jX2lkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobWF4X2NfaWR4ID0gY19pZHg7IG1heF9jX2lkeCA8IHRoaXMuYnVpbGRlci5jb250aW5lbnRhbG5lc3Nlcy5sZW5ndGg7IG1heF9jX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1JhbmdlKGFycmF5LCB3X2lkeCwgY19pZHgsIGVfaWR4LCB0X2lkeCwgaF9pZHgsIG1heF93X2lkeCwgbWF4X2NfaWR4LCBtYXhfZV9pZHgsIHRfaWR4LCBoX2lkeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfY19pZHgtLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heF9oX2lkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobWF4X2hfaWR4ID0gaF9pZHg7IG1heF9oX2lkeCA8IHRoaXMuYnVpbGRlci5odW1pZGl0aWVzLmxlbmd0aDsgbWF4X2hfaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrUmFuZ2UoYXJyYXksIHdfaWR4LCBjX2lkeCwgZV9pZHgsIHRfaWR4LCBoX2lkeCwgbWF4X3dfaWR4LCBtYXhfY19pZHgsIG1heF9lX2lkeCwgdF9pZHgsIG1heF9oX2lkeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfaF9pZHgtLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heF90X2lkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobWF4X3RfaWR4ID0gdF9pZHg7IG1heF90X2lkeCA8IHRoaXMuYnVpbGRlci50ZW1wZXJhdHVyZXMubGVuZ3RoOyBtYXhfdF9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tSYW5nZShhcnJheSwgd19pZHgsIGNfaWR4LCBlX2lkeCwgdF9pZHgsIGhfaWR4LCBtYXhfd19pZHgsIG1heF9jX2lkeCwgbWF4X2VfaWR4LCBtYXhfdF9pZHgsIG1heF9oX2lkeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfdF9pZHgtLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKGFycmF5LCB3X2lkeCwgY19pZHgsIGVfaWR4LCB0X2lkeCwgaF9pZHgsIG1heF93X2lkeCwgbWF4X2NfaWR4LCBtYXhfZV9pZHgsIG1heF90X2lkeCwgbWF4X2hfaWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpb21lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpcmRuZXNzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW3dfaWR4XVsxXS5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW21heF93X2lkeF1bMV0ubWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGluZW50YWxuZXNzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmNvbnRpbmVudGFsbmVzc2VzW2NfaWR4XVsxXS5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmNvbnRpbmVudGFsbmVzc2VzW21heF9jX2lkeF1bMV0ubWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJvc2lvbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lcm9zaW9uc1tlX2lkeF1bMV0ubWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lcm9zaW9uc1ttYXhfZV9pZHhdWzFdLm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLnRlbXBlcmF0dXJlc1t0X2lkeF1bMV0ubWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci50ZW1wZXJhdHVyZXNbbWF4X3RfaWR4XVsxXS5tYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodW1pZGl0eTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5odW1pZGl0aWVzW2hfaWR4XVsxXS5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmh1bWlkaXRpZXNbbWF4X2hfaWR4XVsxXS5tYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aDogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlvbWU6IGFycmF5W3dfaWR4XVtjX2lkeF1bZV9pZHhdW3RfaWR4XVtoX2lkeF0uYmlvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlvbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlyZG5lc3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXNbd19pZHhdWzFdLm1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXNbbWF4X3dfaWR4XVsxXS5tYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW5lbnRhbG5lc3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuY29udGluZW50YWxuZXNzZXNbY19pZHhdWzFdLm1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuY29udGluZW50YWxuZXNzZXNbbWF4X2NfaWR4XVsxXS5tYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcm9zaW9uOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmVyb3Npb25zW2VfaWR4XVsxXS5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmVyb3Npb25zW21heF9lX2lkeF1bMV0ubWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIudGVtcGVyYXR1cmVzW3RfaWR4XVsxXS5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLnRlbXBlcmF0dXJlc1ttYXhfdF9pZHhdWzFdLm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bWlkaXR5OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmh1bWlkaXRpZXNbaF9pZHhdWzFdLm1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuaHVtaWRpdGllc1ttYXhfaF9pZHhdWzFdLm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAuMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW9tZTogYXJyYXlbd19pZHhdW2NfaWR4XVtlX2lkeF1bdF9pZHhdW2hfaWR4XS5iaW9tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgICAgICAgICAgdHlwZTogXCJtaW5lY3JhZnQ6b3ZlcndvcmxkXCIsXG4gICAgICAgICAgICBnZW5lcmF0b3I6IHtcbiAgICAgICAgICAgICAgICBiaW9tZV9zb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgYmlvbWVzOiBiaW9tZXMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibWluZWNyYWZ0Om11bHRpX25vaXNlXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlZWQ6IDAsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IFwibWluZWNyYWZ0Om92ZXJ3b3JsZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwibWluZWNyYWZ0Om5vaXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRW1taXRlZCBcIiArIGJpb21lcy5sZW5ndGggKyBcIiBCaW9tZSBzZXR0aW5ncy4uLlwiKVxuXG4gICAgICAgIHJldHVybiAoSlNPTi5zdHJpbmdpZnkoZGltZW5zaW9uKSlcbiAgICB9XG5cblxuICAgIHByaXZhdGUgY2hlY2tSYW5nZShhcnJheTogeyBiaW9tZTogc3RyaW5nLCBkb25lOiBib29sZWFuIH1bXVtdW11bXVtdLCBtaW5fd19pZHg6IG51bWJlciwgbWluX2NfaWR4OiBudW1iZXIsIG1pbl9lX2lkeDogbnVtYmVyLCBtaW5fdF9pZHg6IG51bWJlciwgbWluX2hfaWR4OiBudW1iZXIsIG1heF93X2lkeDogbnVtYmVyLCBtYXhfY19pZHg6IG51bWJlciwgbWF4X2VfaWR4OiBudW1iZXIsIG1heF90X2lkeDogbnVtYmVyLCBtYXhfaF9pZHg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBiaW9tZSA9IGFycmF5W21pbl93X2lkeF1bbWluX2NfaWR4XVttaW5fZV9pZHhdW21pbl90X2lkeF1bbWluX2hfaWR4XS5iaW9tZVxuICAgICAgICBmb3IgKGxldCB3X2lkeCA9IG1pbl93X2lkeDsgd19pZHggPD0gbWF4X3dfaWR4OyB3X2lkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjX2lkeCA9IG1pbl9jX2lkeDsgY19pZHggPD0gbWF4X2NfaWR4OyBjX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZV9pZHggPSBtaW5fZV9pZHg7IGVfaWR4IDw9IG1heF9lX2lkeDsgZV9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0X2lkeCA9IG1pbl90X2lkeDsgdF9pZHggPD0gbWF4X3RfaWR4OyB0X2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBoX2lkeCA9IG1pbl9oX2lkeDsgaF9pZHggPD0gbWF4X2hfaWR4OyBoX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbF9iaW9tZSA9IGFycmF5W3dfaWR4XT8uW2NfaWR4XT8uW2VfaWR4XT8uW3RfaWR4XT8uW2hfaWR4XT8uYmlvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbF9iaW9tZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuZGVmaW5lZCBlbGVtZW50IGF0IHc6IFwiICsgd19pZHggKyBcIiBjOiBcIiArIGNfaWR4ICsgXCIgZTogXCIgKyBlX2lkeCArIFwiIHQ6IFwiICsgdF9pZHggKyBcIiBoOiBcIiArIGhfaWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlbd19pZHhdPy5bY19pZHhdPy5bZV9pZHhdPy5bdF9pZHhdPy5baF9pZHhdPy5iaW9tZSAhPT0gYmlvbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0RG9uZShhcnJheTogeyBiaW9tZTogc3RyaW5nLCBkb25lOiBib29sZWFuIH1bXVtdW11bXVtdLCBtaW5fd19pZHg6IG51bWJlciwgbWluX2NfaWR4OiBudW1iZXIsIG1pbl9lX2lkeDogbnVtYmVyLCBtaW5fdF9pZHg6IG51bWJlciwgbWluX2hfaWR4OiBudW1iZXIsIG1heF93X2lkeDogbnVtYmVyLCBtYXhfY19pZHg6IG51bWJlciwgbWF4X2VfaWR4OiBudW1iZXIsIG1heF90X2lkeDogbnVtYmVyLCBtYXhfaF9pZHg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCB3X2lkeCA9IG1pbl93X2lkeDsgd19pZHggPD0gbWF4X3dfaWR4OyB3X2lkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjX2lkeCA9IG1pbl9jX2lkeDsgY19pZHggPD0gbWF4X2NfaWR4OyBjX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZV9pZHggPSBtaW5fZV9pZHg7IGVfaWR4IDw9IG1heF9lX2lkeDsgZV9pZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0X2lkeCA9IG1pbl90X2lkeDsgdF9pZHggPD0gbWF4X3RfaWR4OyB0X2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBoX2lkeCA9IG1pbl9oX2lkeDsgaF9pZHggPD0gbWF4X2hfaWR4OyBoX2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbd19pZHhdW2NfaWR4XVtlX2lkeF1bdF9pZHhdW2hfaWR4XS5kb25lID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBFbGVtZW50UmVuZGVyZXIgfSBmcm9tIFwiLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyXCI7XG5pbXBvcnQgeyBMYXlvdXRHcmlkUmVuZGVyZXIgfSBmcm9tIFwiLi4vVUkvUmVuZGVyZXIvTGF5b3V0R3JpZFJlbmRlcmVyXCI7XG5pbXBvcnQgeyBBQkVsZW1lbnQgfSBmcm9tIFwiLi9BQkJpb21lXCI7XG5pbXBvcnQgeyBCaW9tZSB9IGZyb20gXCIuL0Jpb21lXCI7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tIFwiLi9CaW9tZUJ1aWxkZXJcIjtcbmltcG9ydCB7IExheW91dEVsZW1lbnQsIE1vZGV9IGZyb20gXCIuL0xheW91dEVsZW1lbnRcIjtcbmltcG9ydCAqIGFzIHVuaXFpZCBmcm9tICd1bmlxaWQnO1xuXG5leHBvcnQgY2xhc3MgTGF5b3V0IGltcGxlbWVudHMgTGF5b3V0RWxlbWVudCB7XG4gICAgYWxsb3dFZGl0OiBib29sZWFuID0gdHJ1ZVxuICAgIG5hbWU6IHN0cmluZztcblxuICAgIHByaXZhdGUgYXJyYXk6IHN0cmluZ1tdW11cbiAgICBwcml2YXRlIGJ1aWxkZXI6IEJpb21lQnVpbGRlclxuICAgIHByaXZhdGUgcmVuZGVyZXI6IExheW91dEdyaWRSZW5kZXJlclxuXG4gICAgcHJpdmF0ZSB1bmRvQWN0aW9uczoge3RfaWQ6IG51bWJlciwgaF9pZDogbnVtYmVyLCB2YWx1ZTogc3RyaW5nfVtdXG5cbiAgICBwcml2YXRlIGtleTogc3RyaW5nXG4gICAgXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihidWlsZGVyOiBCaW9tZUJ1aWxkZXIsIG5hbWU6IHN0cmluZywgYXJyYXk/OiBzdHJpbmdbXVtdLCBrZXk/OiBzdHJpbmcpe1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheSA/PyBuZXcgQXJyYXkoYnVpbGRlci5nZXROdW1UZW1wZXJhdHVyZXMoKSkuZmlsbCgwKS5tYXAoKCkgPT4gbmV3IEFycmF5KGJ1aWxkZXIuZ2V0TnVtSHVtaWRpdGllcygpKS5maWxsKFwidW5hc3NpZ25lZFwiKSlcblxuICAgICAgICB0aGlzLmtleSA9IGtleSA/PyB1bmlxaWQoJ2xheW91dF8nKVxuICAgICAgICB0aGlzLnVuZG9BY3Rpb25zID0gW11cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKGJ1aWxkZXI6IEJpb21lQnVpbGRlciwgbmFtZTogc3RyaW5nLCBhcnJheT86IHN0cmluZ1tdW10sIGtleT86IHN0cmluZyk6IExheW91dHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IExheW91dChidWlsZGVyLCBuYW1lLCBhcnJheSwga2V5KVxuICAgICAgICBidWlsZGVyLnJlZ2lzdGVyTGF5b3V0RWxlbWVudChsYXlvdXQpO1xuICAgICAgICByZXR1cm4gbGF5b3V0XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21KU09OKGJ1aWxkZXI6IEJpb21lQnVpbGRlciwganNvbjogYW55KXtcbiAgICAgICAgcmV0dXJuIExheW91dC5jcmVhdGUoYnVpbGRlciwganNvbi5uYW1lLCBqc29uLmFycmF5LCBqc29uLmtleSlcbiAgICB9XG5cbiAgICB0b0pTT04oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBhcnJheTogdGhpcy5hcnJheS5tYXAocm93ID0+IHJvdy5tYXAoZSA9PiB0aGlzLmJ1aWxkZXIuZ2V0TGF5b3V0RWxlbWVudChlKS5nZXRLZXkoKSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQodGVtcGVyYXR1cmVJbmRleDogbnVtYmVyLCBodW1pZGl0eUluZGV4OiBudW1iZXIsIGVsZW1lbnQ6IHN0cmluZywgcmVjb3JkVW5kbzogYm9vbGVhbiA9IHRydWUpe1xuICAgICAgICBpZiAodGhpcy5hcnJheVt0ZW1wZXJhdHVyZUluZGV4XVtodW1pZGl0eUluZGV4XSA9PT0gZWxlbWVudClcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGlmIChyZWNvcmRVbmRvKVxuICAgICAgICAgICAgdGhpcy51bmRvQWN0aW9ucy5wdXNoKHt0X2lkOiB0ZW1wZXJhdHVyZUluZGV4LCBoX2lkOiBodW1pZGl0eUluZGV4LCB2YWx1ZTogdGhpcy5hcnJheVt0ZW1wZXJhdHVyZUluZGV4XVtodW1pZGl0eUluZGV4XX0pXG5cbiAgICAgICAgdGhpcy5hcnJheVt0ZW1wZXJhdHVyZUluZGV4XVtodW1pZGl0eUluZGV4XSA9IGVsZW1lbnRcbiAgICB9XG5cbiAgICB1bmRvKCl7XG4gICAgICAgIGlmICh0aGlzLnVuZG9BY3Rpb25zLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy51bmRvQWN0aW9ucy5wb3AoKVxuICAgICAgICAgICAgdGhpcy5hcnJheVthY3Rpb24udF9pZF1bYWN0aW9uLmhfaWRdID0gYWN0aW9uLnZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb29rdXBLZXkodGVtcGVyYXR1cmVJbmRleDogbnVtYmVyLCBodW1pZGl0eUluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVt0ZW1wZXJhdHVyZUluZGV4XVtodW1pZGl0eUluZGV4XVxuICAgIH1cblxuICAgIGxvb2t1cCh0ZW1wZXJhdHVyZUluZGV4OiBudW1iZXIsIGh1bWlkaXR5SW5kZXg6IG51bWJlcik6IExheW91dEVsZW1lbnR7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMubG9va3VwS2V5KHRlbXBlcmF0dXJlSW5kZXgsIGh1bWlkaXR5SW5kZXgpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5idWlsZGVyLmdldExheW91dEVsZW1lbnQoa2V5KVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuXG4gICAgbG9va3VwUmVjdXJzaXZlKHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyLCBtb2RlOiBNb2RlKTogTGF5b3V0RWxlbWVudHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubG9va3VwKHRlbXBlcmF0dXJlSW5kZXgsIGh1bWlkaXR5SW5kZXgpXG4gICAgICAgIHJldHVybiBlbGVtZW50Lmxvb2t1cFJlY3Vyc2l2ZSh0ZW1wZXJhdHVyZUluZGV4LCBodW1pZGl0eUluZGV4LCBtb2RlKTtcbiAgICB9XG5cbiAgICBnZXRTaXplKCk6IFtudW1iZXIsIG51bWJlcl17XG4gICAgICAgIHJldHVybiBbdGhpcy5idWlsZGVyLmdldE51bVRlbXBlcmF0dXJlcygpLCB0aGlzLmJ1aWxkZXIuZ2V0TnVtSHVtaWRpdGllcygpXVxuICAgIH1cblxuICAgIGdldFJlbmRlcmVyKCk6IEVsZW1lbnRSZW5kZXJlciB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IExheW91dEdyaWRSZW5kZXJlcih0aGlzKVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXG4gICAgfVxuXG4gICAgZ2V0S2V5KCl7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVxuICAgIH1cbn0iLCJpbXBvcnQgeyBFbGVtZW50UmVuZGVyZXIgfSBmcm9tIFwiLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyXCI7XG5pbXBvcnQgeyBBQkVsZW1lbnQgfSBmcm9tIFwiLi9BQkJpb21lXCI7XG5pbXBvcnQgeyBCaW9tZSB9IGZyb20gXCIuL0Jpb21lXCI7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tIFwiLi9CaW9tZUJ1aWxkZXJcIjtcbmltcG9ydCB7IExheW91dEVsZW1lbnQsIE1vZGUgfSBmcm9tIFwiLi9MYXlvdXRFbGVtZW50XCI7XG5cblxuZXhwb3J0IGNsYXNzIExheW91dEVsZW1lbnREdW1teSBpbXBsZW1lbnRzIExheW91dEVsZW1lbnR7XG4gICAgYWxsb3dFZGl0OiBib29sZWFuID0gZmFsc2VcbiAgICBuYW1lOiBzdHJpbmcgPSBcIl9fZHVtbXlfX1wiO1xuXG4gICAgc3RhdGljIGNyZWF0ZShidWlsZGVyOiBCaW9tZUJ1aWxkZXIpOiBMYXlvdXRFbGVtZW50RHVtbXl7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbmV3IExheW91dEVsZW1lbnREdW1teSgpXG4gICAgICAgIGJ1aWxkZXIucmVnaXN0ZXJMYXlvdXRFbGVtZW50KGR1bW15KTtcbiAgICAgICAgcmV0dXJuIGR1bW15XG4gICAgfVxuXG4gICAgbG9va3VwS2V5KHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiX19kdW1teV9fXCJcbiAgICB9XG5cbiAgICBsb29rdXAodGVtcGVyYXR1cmVJbmRleDogbnVtYmVyLCBodW1pZGl0eUluZGV4OiBudW1iZXIpOiBMYXlvdXRFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBsb29rdXBSZWN1cnNpdmUodGVtcGVyYXR1cmVJbmRleDogbnVtYmVyLCBodW1pZGl0eUluZGV4OiBudW1iZXIsIG1vZGU6IE1vZGUpOiBMYXlvdXRFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJlcigpOiBFbGVtZW50UmVuZGVyZXIge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgZ2V0S2V5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcIl9fZHVtbXlfX1wiXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmlvbWVSZW5kZXJlciwgRWxlbWVudFJlbmRlcmVyLCBVbmFzc2lnbmVkUmVuZGVyZXIgfSBmcm9tIFwiLi4vVUkvUmVuZGVyZXIvRWxlbWVudFJlbmRlcmVyXCI7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tIFwiLi9CaW9tZUJ1aWxkZXJcIjtcbmltcG9ydCB7IExheW91dEVsZW1lbnQsIE1vZGUgfSBmcm9tIFwiLi9MYXlvdXRFbGVtZW50XCI7XG5cblxuXG5leHBvcnQgY2xhc3MgTGF5b3V0RWxlbWVudFVuYXNzaWduZWQgaW1wbGVtZW50cyBMYXlvdXRFbGVtZW50e1xuICAgIGFsbG93RWRpdDogYm9vbGVhbiA9IGZhbHNlXG4gICAgbmFtZTogc3RyaW5nID0gXCItIFVuYXNzaWduZWQgLVwiO1xuICAgIHJlbmRlcmVyOiBVbmFzc2lnbmVkUmVuZGVyZXI7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKGJ1aWxkZXI6IEJpb21lQnVpbGRlcil7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgTGF5b3V0RWxlbWVudFVuYXNzaWduZWQoKVxuICAgICAgICBidWlsZGVyLnJlZ2lzdGVyTGF5b3V0RWxlbWVudChlbGVtZW50KVxuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGxvb2t1cEtleSh0ZW1wZXJhdHVyZUluZGV4OiBudW1iZXIsIGh1bWlkaXR5SW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpXG4gICAgfVxuXG4gICAgbG9va3VwKHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyKTogTGF5b3V0RWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgbG9va3VwUmVjdXJzaXZlKHRlbXBlcmF0dXJlSW5kZXg6IG51bWJlciwgaHVtaWRpdHlJbmRleDogbnVtYmVyLCBtb2RlOiBNb2RlKTogTGF5b3V0RWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyZXIoKTogRWxlbWVudFJlbmRlcmVyIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVW5hc3NpZ25lZFJlbmRlcmVyKClcblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlclxuICAgIH1cbiAgICBcbiAgICBnZXRLZXkoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwidW5hc3NpZ25lZFwiXG4gICAgfVxufSIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHVuaXFpZCBmcm9tICd1bmlxaWQnO1xuaW1wb3J0IHsgU2xpY2VHcmlkUmVuZGVyZXIgfSBmcm9tICcuLi9VSS9SZW5kZXJlci9TbGljZUdyaWRSZW5kZXJlcic7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tICcuL0Jpb21lQnVpbGRlcic7XG5pbXBvcnQgeyBMYXlvdXRFbGVtZW50IH0gZnJvbSAnLi9MYXlvdXRFbGVtZW50JztcblxuZXhwb3J0IGNsYXNzIFNsaWNle1xuICAgIGFsbG93RWRpdDogYm9vbGVhbiA9IHRydWVcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBhcnJheTogc3RyaW5nW11bXVxuICAgIHByaXZhdGUgYnVpbGRlcjogQmlvbWVCdWlsZGVyXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogU2xpY2VHcmlkUmVuZGVyZXJcbiAgICBwcml2YXRlIGtleTogc3RyaW5nXG5cbiAgICBwcml2YXRlIHVuZG9BY3Rpb25zOiB7Y19pZDogbnVtYmVyLCBlX2lkOiBudW1iZXIsIHZhbHVlOiBzdHJpbmd9W11cblxuICAgIFxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoYnVpbGRlcjogQmlvbWVCdWlsZGVyLCBuYW1lOiBzdHJpbmcsIGFycmF5OiBzdHJpbmdbXVtdLCBrZXk/OiBzdHJpbmcpe1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXkgPz8gdW5pcWlkKCdzbGljZV8nKVxuICAgICAgICB0aGlzLnVuZG9BY3Rpb25zID0gW11cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKGJ1aWxkZXI6IEJpb21lQnVpbGRlciwgbmFtZTogc3RyaW5nLCBmaWxsOiBzdHJpbmcpOiBTbGljZXtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgU2xpY2UoYnVpbGRlciwgbmFtZSwgbmV3IEFycmF5KGJ1aWxkZXIuZ2V0TnVtQ29udGluZW50YWxuZXNzZXMoKSkuZmlsbCgwKS5tYXAoKCkgPT4gbmV3IEFycmF5KGJ1aWxkZXIuZ2V0TnVtRXJvc2lvbnMoKSkuZmlsbChmaWxsKSkpO1xuICAgICAgICBidWlsZGVyLnJlZ2lzdGVyU2xpY2Uoc2xpY2UpO1xuICAgICAgICByZXR1cm4gc2xpY2VcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUpTT04oYnVpbGRlcjogQmlvbWVCdWlsZGVyLCBqc29uOiBhbnkpe1xuICAgICAgICBjb25zdCBzbGljZSA9IG5ldyBTbGljZShidWlsZGVyLCBqc29uLm5hbWUsIGpzb24uYXJyYXksIGpzb24ua2V5KVxuICAgICAgICBidWlsZGVyLnJlZ2lzdGVyU2xpY2Uoc2xpY2UpO1xuICAgICAgICByZXR1cm4gc2xpY2VcbiAgICB9XG5cbiAgICB0b0pTT04oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBhcnJheTogdGhpcy5hcnJheS5tYXAocm93ID0+IHJvdy5tYXAoZSA9PiB0aGlzLmJ1aWxkZXIuZ2V0TGF5b3V0RWxlbWVudChlKS5nZXRLZXkoKSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTaXplKCk6IFtudW1iZXIsIG51bWJlcl17XG4gICAgICAgIHJldHVybiBbdGhpcy5idWlsZGVyLmdldE51bUNvbnRpbmVudGFsbmVzc2VzKCksIHRoaXMuYnVpbGRlci5nZXROdW1Fcm9zaW9ucygpXVxuICAgIH1cblxuICAgIHNldChjb250aW5lbnRhbG5lc3NJbmRleDogbnVtYmVyLCBlcm9zaW9uSW5kZXg6IG51bWJlciwgZWxlbWVudDogc3RyaW5nKXtcbiAgICAgICAgaWYgKHRoaXMuYXJyYXlbY29udGluZW50YWxuZXNzSW5kZXhdW2Vyb3Npb25JbmRleF0gPT09IGVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICB0aGlzLnVuZG9BY3Rpb25zLnB1c2goe2NfaWQ6IGNvbnRpbmVudGFsbmVzc0luZGV4LCBlX2lkOiBlcm9zaW9uSW5kZXgsIHZhbHVlOiB0aGlzLmFycmF5W2NvbnRpbmVudGFsbmVzc0luZGV4XVtlcm9zaW9uSW5kZXhdfSlcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYXJyYXlbY29udGluZW50YWxuZXNzSW5kZXhdW2Vyb3Npb25JbmRleF0gPSBlbGVtZW50XG4gICAgfVxuXG4gICAgdW5kbygpe1xuICAgICAgICBpZiAodGhpcy51bmRvQWN0aW9ucy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMudW5kb0FjdGlvbnMucG9wKClcbiAgICAgICAgICAgIHRoaXMuYXJyYXlbYWN0aW9uLmNfaWRdW2FjdGlvbi5lX2lkXSA9IGFjdGlvbi52YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9va3VwS2V5KGNvbnRpbmVudGFsbmVzc0luZGV4OiBudW1iZXIsIGVyb3Npb25JbmRleDogbnVtYmVyKTogc3RyaW5ne1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVtjb250aW5lbnRhbG5lc3NJbmRleF1bZXJvc2lvbkluZGV4XVxuICAgIH1cblxuICAgIGxvb2t1cChjb250aW5lbnRhbG5lc3NJbmRleDogbnVtYmVyLCBlcm9zaW9uSW5kZXg6IG51bWJlcik6IExheW91dEVsZW1lbnR7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMubG9va3VwS2V5KGNvbnRpbmVudGFsbmVzc0luZGV4LCBlcm9zaW9uSW5kZXgpXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkZXIuZ2V0TGF5b3V0RWxlbWVudChrZXkpXG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyZXIoKTogU2xpY2VHcmlkUmVuZGVyZXIge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBTbGljZUdyaWRSZW5kZXJlcih0aGlzKVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXG4gICAgfVxuXG4gICAgZ2V0S2V5KCl7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVxuICAgIH1cbn0iLCJpbXBvcnQgeyBzbGljZSB9IGZyb20gXCJsb2Rhc2hcIlxuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0Jpb21lQnVpbGRlclwiXG5pbXBvcnQgeyBVSSB9IGZyb20gXCIuL1VJXCJcblxuXG5leHBvcnQgY2xhc3MgQXNzaWduU2xpY2VzTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBidWlsZGVyOiBCaW9tZUJ1aWxkZXJcbiAgICBwcml2YXRlIHRpdGxlOiBIVE1MSW5wdXRFbGVtZW50XG4gICAgcHJpdmF0ZSBkaXY6IEhUTUxFbGVtZW50XG4gICAgcHJpdmF0ZSBzcGxpbmVDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG5cbiAgICBwcml2YXRlIHVuZG9BY3Rpb25zOiB7d19pZHg6IG51bWJlciwgdmFsdWU6IHN0cmluZ31bXVxuXG4gICAgY29uc3RydWN0b3IoYnVpbGRlcjogQmlvbWVCdWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcblxuICAgICAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXlvdXROYW1lXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgICAgdGhpcy5kaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFzc2lnblNsaWNlc1wiKVxuICAgICAgICB0aGlzLnNwbGluZUNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3BsaW5lRGlzcGxheUNhbnZhc1wiKSBhcyBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAgICB0aGlzLnVuZG9BY3Rpb25zID0gW11cblxuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIFVJLmdldEluc3RhbmNlKCkuc3BsaW5lRGlzcGxheU1hbmFnZXIuc2V0UG9zKHVuZGVmaW5lZClcblxuICAgICAgICB0aGlzLnRpdGxlLnJlYWRPbmx5ID0gdHJ1ZVxuICAgICAgICB0aGlzLnRpdGxlLnZhbHVlID0gXCJBc3NpZ24gU2xpY2VzXCJcbiAgICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKVxuICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpXG4gICAgICAgIHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlcy5mb3JFYWNoKCh3ZWlyZG5lc3MsIHdfaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5idWlsZGVyLmdldFJlbmRlcmVkRWxlbWVudCh3ZWlyZG5lc3NbMl0pXG5cbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKVxuXG4gICAgICAgICAgICBjb25zdCBuYW1lX2NvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKVxuICAgICAgICAgICAgbmFtZV9jb2wuaW5uZXJIVE1MID0gd2VpcmRuZXNzWzBdICsgXCI6IFwiXG4gICAgICAgICAgICBuYW1lX2NvbC5jbGFzc0xpc3QuYWRkKFwid2VpcmRuZXNzX25hbWVcIilcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChuYW1lX2NvbClcblxuICAgICAgICAgICAgY29uc3Qgc2xpY2VfaWNvbl9jb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIilcbiAgICAgICAgICAgIHNsaWNlX2ljb25fY29sLmNsYXNzTGlzdC5hZGQoXCJzbGljZV9pY29uXCIpXG5cbiAgICAgICAgICAgIGNvbnN0IHNsaWNlX2ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICAgICAgICBzbGljZV9pY29uLndpZHRoID0gMTAwXG4gICAgICAgICAgICBzbGljZV9pY29uLmhlaWdodCA9IDEwMFxuICAgICAgICAgICAgZWxlbWVudC5nZXRSZW5kZXJlcigpLmRyYXcoc2xpY2VfaWNvbi5nZXRDb250ZXh0KCcyZCcpLCAwLCAwLCAxMDAsIDEwMCwgLTEsIC0xLCBmYWxzZSwgdHJ1ZSlcblxuICAgICAgICAgICAgc2xpY2VfaWNvbl9jb2wuYXBwZW5kQ2hpbGQoc2xpY2VfaWNvbilcblxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHNsaWNlX2ljb25fY29sKVxuXG4gICAgICAgICAgICBjb25zdCBzbGljZV9uYW1lX2NvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKVxuICAgICAgICAgICAgc2xpY2VfbmFtZV9jb2wuaW5uZXJIVE1MID0gZWxlbWVudC5uYW1lXG4gICAgICAgICAgICBzbGljZV9uYW1lX2NvbC5jbGFzc0xpc3QuYWRkKFwic2xpY2VfbmFtZVwiKVxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHNsaWNlX25hbWVfY29sKVxuXG4gICAgICAgICAgICBjb25zdCBzbGljZV9tb2RlX3NlbGVjdF9jb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIilcbiAgICAgICAgICAgIHNsaWNlX21vZGVfc2VsZWN0X2NvbC5jbGFzc0xpc3QuYWRkKFwic2xpY2VfbW9kZV9zZWxlY3RcIilcblxuICAgICAgICAgICAgY29uc3Qgc2xpY2VfbW9kZV9zZWxlY3RfaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSBhcyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBzbGljZV9tb2RlX3NlbGVjdF9pbWcuc3JjID0gXCJtb2RlX1wiICsgd2VpcmRuZXNzWzNdICsgXCIucG5nXCJcbiAgICAgICAgICAgIHNsaWNlX21vZGVfc2VsZWN0X2ltZy5vbmNsaWNrID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlc1t3X2lkeF1bM10gPSB3ZWlyZG5lc3NbM10gPT09IFwiQVwiID8gXCJCXCIgOiBcIkFcIlxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2VfbW9kZV9zZWxlY3RfY29sLmFwcGVuZENoaWxkKHNsaWNlX21vZGVfc2VsZWN0X2ltZylcblxuICAgICAgICAgICAgcm93Lm9uY2xpY2sgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zZWxlY3RlZEVsZW1lbnQgPSB0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXNbd19pZHhdWzJdXG4gICAgICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50ICE9PSBcIlwiICYmIHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlc1t3X2lkeF1bMl0gIT09IFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZG9BY3Rpb25zLnB1c2goe3dfaWR4OiB3X2lkeCwgdmFsdWU6IHRoaXMuYnVpbGRlci53ZWlyZG5lc3Nlc1t3X2lkeF1bMl19KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW3dfaWR4XVsyXSA9IFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cub25jb250ZXh0bWVudSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW3dfaWR4XVsyXSAhPT0gXCJ1bmFzc2lnbmVkXCIpe1xuICAgICAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLm9wZW5FbGVtZW50ID0gdGhpcy5idWlsZGVyLndlaXJkbmVzc2VzW3dfaWR4XVsyXVxuICAgICAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cub25tb3VzZW92ZXIgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5zZXRXZWlyZG5lc3Nlcyhbd2VpcmRuZXNzWzFdXSlcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNwbGluZURpc3BsYXlNYW5hZ2VyLnJlZnJlc2goKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoc2xpY2VfbW9kZV9zZWxlY3RfY29sKVxuXG5cbiAgICAgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHJvdylcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgdCA9IHRoaXNcbiAgICAgICAgdGFibGUub25tb3VzZW91dCA9IChldnQpID0+IHtcbiAgICAgICAgICAgIGlmICghdC5kaXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRkZW4nKSl7XG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5zZXRXZWlyZG5lc3NlcyhbXSlcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNwbGluZURpc3BsYXlNYW5hZ2VyLnJlZnJlc2goKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGFibGUpXG5cbiAgICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAxXG5cbiAgICAgICAgdGhpcy5kaXYuZm9jdXMoKVxuXG4gICAgICAgIHRoaXMuZGl2Lm9ua2V5ZG93biA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldnQua2V5ID09PSBcInpcIiAmJiBldnQuY3RybEtleSAmJiB0aGlzLnVuZG9BY3Rpb25zLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMudW5kb0FjdGlvbnMucG9wKClcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXNbYWN0aW9uLndfaWR4XVsyXSA9IGFjdGlvbi52YWx1ZVxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFNwbGluZSwgVGVycmFpblNoYXBlciB9IGZyb20gXCJkZWVwc2xhdGVcIjtcbmltcG9ydCB7IEFCRWxlbWVudCB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9BQkJpb21lXCI7XG5pbXBvcnQgeyBCaW9tZSB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9CaW9tZVwiO1xuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0Jpb21lQnVpbGRlclwiO1xuaW1wb3J0IHsgTGF5b3V0IH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0xheW91dFwiO1xuaW1wb3J0IHsgTGF5b3V0RWxlbWVudCB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9MYXlvdXRFbGVtZW50XCI7XG5pbXBvcnQgeyBMYXlvdXRFbGVtZW50VW5hc3NpZ25lZCB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9MYXlvdXRFbGVtZW50VW5hc3NpZ25lZFwiO1xuaW1wb3J0IHsgU2xpY2UgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvU2xpY2VcIjtcbmltcG9ydCB7IExheW91dEdyaWRSZW5kZXJlciB9IGZyb20gXCIuL1JlbmRlcmVyL0xheW91dEdyaWRSZW5kZXJlclwiO1xuaW1wb3J0IHsgVUkgfSBmcm9tIFwiLi9VSVwiO1xuXG5cbmZ1bmN0aW9uIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIGw6IG51bWJlcikge1xuICAgIHJldHVybiAoKDEgLSBsKSAqIGEgKyBsICogYilcbn1cbmV4cG9ydCBjbGFzcyBMYXlvdXRFZGl0b3Ige1xuICAgIHByaXZhdGUgYnVpbGRlcjogQmlvbWVCdWlsZGVyXG4gICAgcHJpdmF0ZSB0aXRsZTogSFRNTElucHV0RWxlbWVudFxuICAgIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuXG4gICAgcHJpdmF0ZSBtb3VzZV9wb3NpdGlvbjogeyBtb3VzZV94OiBudW1iZXIsIG1vdXNlX3k6IG51bWJlciB9XG4gICAgcHJpdmF0ZSBzcGxpbmVDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gICAgbGF5b3V0OiBMYXlvdXQgfCBTbGljZVxuXG4gICAgY29uc3RydWN0b3IoYnVpbGRlcjogQmlvbWVCdWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcblxuICAgICAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXlvdXROYW1lXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxheW91dEVkaXRvckNhbnZhc1wiKSBhcyBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAgICB0aGlzLnNwbGluZUNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3BsaW5lRGlzcGxheUNhbnZhc1wiKSBhcyBIVE1MQ2FudmFzRWxlbWVudFxuXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxheW91dEVkaXRvclRvb2x0aXBcIilcbiAgICAgICAgY29uc3QgdG9vbHRpcF9uYW1lID0gdG9vbHRpcC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibmFtZVwiKVswXSBhcyBIVE1MRWxlbWVudFxuXG4gICAgICAgIHRoaXMudGl0bGUub25jaGFuZ2UgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQubmFtZSA9IHRoaXMudGl0bGUudmFsdWVcbiAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5vbm1vdXNlbW92ZSA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmxheW91dC5nZXRSZW5kZXJlcigpIGFzIExheW91dEdyaWRSZW5kZXJlclxuICAgICAgICAgICAgdGhpcy5tb3VzZV9wb3NpdGlvbiA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpXG4gICAgICAgICAgICBjb25zdCBpZHMgPSByZW5kZXJlci5nZXRJZHNGcm9tUG9zaXRpb24oMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCwgdGhpcy5tb3VzZV9wb3NpdGlvbi5tb3VzZV94LCB0aGlzLm1vdXNlX3Bvc2l0aW9uLm1vdXNlX3kpXG4gICAgICAgICAgICBpZiAoaWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpbmVfY3R4ID0gdGhpcy5zcGxpbmVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgICAgIHNwbGluZV9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3BsaW5lQ2FudmFzLndpZHRoLCB0aGlzLnNwbGluZUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5mb2N1cygpXG5cbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUubGVmdCA9IChNYXRoLm1pbihldnQucGFnZVggKyAyMCwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCAtIHRvb2x0aXAuY2xpZW50V2lkdGgpKSArIFwicHhcIlxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZS50b3AgPSAoZXZ0LnBhZ2VZICsgMTUpICsgXCJweFwiXG4gICAgICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIilcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmxheW91dC5sb29rdXAoaWRzLnRfaWR4LCBpZHMuaF9pZHgpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIExheW91dCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQUJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmdldEVsZW1lbnQoaWRzLm1vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJpb21lKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcF9uYW1lLmlubmVySFRNTCA9IGVsZW1lbnQubmFtZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcF9uYW1lLmlubmVySFRNTCA9IFwiJmNyYXJyOyBcIiArIGVsZW1lbnQubmFtZSArIFwiIChMYXlvdXQpXCJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIExheW91dEVsZW1lbnRVbmFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcF9uYW1lLmlubmVySFRNTCA9IFwiVW5hc3NpZ25lZFwiXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnQgPSBidWlsZGVyLmNvbnRpbmVudGFsbmVzc2VzW2lkcy50X2lkeF1bMV1cbiAgICAgICAgICAgIGNvbnN0IGMgPSBsZXJwKGNvbnQubWluLCBjb250Lm1heCwgaWRzLmxvY2FsX3QpXG5cbiAgICAgICAgICAgIGNvbnN0IGVybyA9IGJ1aWxkZXIuZXJvc2lvbnNbaWRzLmhfaWR4XVsxXVxuICAgICAgICAgICAgY29uc3QgZSA9IGxlcnAoZXJvLm1pbiwgZXJvLm1heCwgaWRzLmxvY2FsX2gpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFNsaWNlKXtcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNwbGluZURpc3BsYXlNYW5hZ2VyLnNldFBvcyh7YzogYywgZTogZX0pXG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5yZWZyZXNoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLm9ubW91c2VsZWF2ZSA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKVxuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5zZXRQb3ModW5kZWZpbmVkKVxuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5yZWZyZXNoKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLm9uY2xpY2sgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMubGF5b3V0LmdldFJlbmRlcmVyKCkgYXMgTGF5b3V0R3JpZFJlbmRlcmVyXG4gICAgICAgICAgICBjb25zdCBtb3VzZV9wb3NpdGlvbiA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpXG4gICAgICAgICAgICBjb25zdCBpZHMgPSByZW5kZXJlci5nZXRJZHNGcm9tUG9zaXRpb24oMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCwgbW91c2VfcG9zaXRpb24ubW91c2VfeCwgbW91c2VfcG9zaXRpb24ubW91c2VfeSlcbiAgICAgICAgICAgIGlmIChpZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGlkcy50X2lkeCwgaWRzLmhfaWR4LCBpZHMubW9kZSwgZXZ0LmN0cmxLZXkgPyBcImFkZF9hbHRcIiA6IGV2dC5hbHRLZXkgPyBcInBpY2tcIiA6IFwiYWRkXCIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5vbmF1eGNsaWNrID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2dC5idXR0b24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMubGF5b3V0LmdldFJlbmRlcmVyKCkgYXMgTGF5b3V0R3JpZFJlbmRlcmVyXG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VfcG9zaXRpb24gPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkcyA9IHJlbmRlcmVyLmdldElkc0Zyb21Qb3NpdGlvbigwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0LCBtb3VzZV9wb3NpdGlvbi5tb3VzZV94LCBtb3VzZV9wb3NpdGlvbi5tb3VzZV95KVxuICAgICAgICAgICAgICAgIGlmIChpZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGlkcy50X2lkeCwgaWRzLmhfaWR4LCBpZHMubW9kZSwgXCJwaWNrXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cblxuICAgICAgICB0aGlzLmNhbnZhcy5vbmNvbnRleHRtZW51ID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmxheW91dC5nZXRSZW5kZXJlcigpIGFzIExheW91dEdyaWRSZW5kZXJlclxuICAgICAgICAgICAgY29uc3QgbW91c2VfcG9zaXRpb24gPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KVxuICAgICAgICAgICAgY29uc3QgaWRzID0gcmVuZGVyZXIuZ2V0SWRzRnJvbVBvc2l0aW9uKDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQsIG1vdXNlX3Bvc2l0aW9uLm1vdXNlX3gsIG1vdXNlX3Bvc2l0aW9uLm1vdXNlX3kpXG4gICAgICAgICAgICBpZiAoaWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbihpZHMudF9pZHgsIGlkcy5oX2lkeCwgaWRzLm1vZGUsIFwib3BlblwiKVxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLm9ua2V5ZG93biA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldnQua2V5ID09PSBcInpcIiAmJiBldnQuY3RybEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5kbygpXG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5yZWZyZXNoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLm9ua2V5dXAgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZ0LmtleSA9PT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5sYXlvdXQuZ2V0UmVuZGVyZXIoKSBhcyBMYXlvdXRHcmlkUmVuZGVyZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZV9wb3NpdGlvbiA9IHRoaXMubW91c2VfcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSByZW5kZXJlci5nZXRJZHNGcm9tUG9zaXRpb24oMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCwgbW91c2VfcG9zaXRpb24ubW91c2VfeCwgbW91c2VfcG9zaXRpb24ubW91c2VfeSlcbiAgICAgICAgICAgICAgICBpZiAoaWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbihpZHMudF9pZHgsIGlkcy5oX2lkeCwgaWRzLm1vZGUsIFwicmVtb3ZlXCIpXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRNb3VzZVBvc2l0aW9uKGV2dDogTW91c2VFdmVudCk6IHsgbW91c2VfeDogbnVtYmVyLCBtb3VzZV95OiBudW1iZXIgfSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBjb25zdCBzY2FsZVggPSB0aGlzLmNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGhcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHRcblxuICAgICAgICBjb25zdCBjYW52YXNNb3VzZVggPSAoZXZ0LmNsaWVudFggLSByZWN0LmxlZnQpICogc2NhbGVYXG4gICAgICAgIGNvbnN0IGNhbnZhc01vdXNlWSA9IChldnQuY2xpZW50WSAtIHJlY3QudG9wKSAqIHNjYWxlWVxuXG4gICAgICAgIHJldHVybiB7IG1vdXNlX3g6IGNhbnZhc01vdXNlWCwgbW91c2VfeTogY2FudmFzTW91c2VZIH1cbiAgICB9XG5cbiAgICBoYW5kbGVJbnRlcmFjdGlvbih0X2lkeDogbnVtYmVyLCBoX2lkeDogbnVtYmVyLCBtb2RlOiBcIkFcIiB8IFwiQlwiLCBhY3Rpb246IFwiYWRkXCIgfCBcImFkZF9hbHRcIiB8IFwicGlja1wiIHwgXCJvcGVuXCIgfCBcInJlbW92ZVwiKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxheW91dC5sb29rdXAodF9pZHgsIGhfaWR4KVxuXG4gICAgICAgIGxldCBleGFjdF9lbGVtZW50ID0gZWxlbWVudFxuICAgICAgICBpZiAoZXhhY3RfZWxlbWVudCBpbnN0YW5jZW9mIEFCRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiQVwiKSB7XG4gICAgICAgICAgICAgICAgZXhhY3RfZWxlbWVudCA9IHRoaXMuYnVpbGRlci5nZXRMYXlvdXRFbGVtZW50KGV4YWN0X2VsZW1lbnQuZWxlbWVudEEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4YWN0X2VsZW1lbnQgPSB0aGlzLmJ1aWxkZXIuZ2V0TGF5b3V0RWxlbWVudChleGFjdF9lbGVtZW50LmVsZW1lbnRCKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkRWxlbWVudCA9IFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50O1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IFwidW5hc3NpZ25lZFwiXG4gICAgICAgICAgICBhY3Rpb24gPSBcImFkZFwiXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uID09PSBcInBpY2tcIikge1xuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zZWxlY3RlZEVsZW1lbnQgPSBleGFjdF9lbGVtZW50LmdldEtleSgpXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICB9IGVsc2UgaWYgKChhY3Rpb24gPT09IFwiYWRkXCIgfHwgYWN0aW9uID09PSBcImFkZF9hbHRcIikgJiYgc2VsZWN0ZWRFbGVtZW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAvL0N5Y2xlIENoZWNrXG4gICAgICAgICAgICBjb25zdCBzZSA9IHRoaXMuYnVpbGRlci5sYXlvdXRFbGVtZW50cy5nZXQoc2VsZWN0ZWRFbGVtZW50KVxuICAgICAgICAgICAgaWYgKHNlIGluc3RhbmNlb2YgTGF5b3V0ICYmIHRoaXMubGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgdGhpcy5idWlsZGVyLmxheW91dEVsZW1lbnREdW1teS5nZXRLZXkoKSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgaWYgKHNlLmxvb2t1cFJlY3Vyc2l2ZSh0X2lkeCwgaF9pZHgsIFwiQVwiKSA9PT0gdGhpcy5idWlsZGVyLmxheW91dEVsZW1lbnREdW1teSB8fCBzZS5sb29rdXBSZWN1cnNpdmUodF9pZHgsIGhfaWR4LCBcIkJcIikgPT09IHRoaXMuYnVpbGRlci5sYXlvdXRFbGVtZW50RHVtbXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9DeWNsZSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5zZXQodF9pZHgsIGhfaWR4LCBlbGVtZW50LmdldEtleSgpLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgZWxlbWVudC5nZXRLZXkoKSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlICYmIHRoaXMuYnVpbGRlci52YW5pbGxhQmlvbWVzLmhhcyhzZWxlY3RlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLnJlZ2lzdGVyTGF5b3V0RWxlbWVudCh0aGlzLmJ1aWxkZXIudmFuaWxsYUJpb21lcy5nZXQoc2VsZWN0ZWRFbGVtZW50KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJhZGRfYWx0XCIgJiYgIShlbGVtZW50IGluc3RhbmNlb2YgQUJFbGVtZW50KSAmJiB0aGlzLmxheW91dCBpbnN0YW5jZW9mIExheW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhbHRlcm5hdGVcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJBXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgc2VsZWN0ZWRFbGVtZW50ICsgXCIvXCIgKyBlbGVtZW50LmdldEtleSgpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnNldCh0X2lkeCwgaF9pZHgsIGVsZW1lbnQuZ2V0S2V5KCkgKyBcIi9cIiArIHNlbGVjdGVkRWxlbWVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQUJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBcIkFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCA9PT0gZWxlbWVudC5lbGVtZW50Qikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnNldCh0X2lkeCwgaF9pZHgsIHNlbGVjdGVkRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgc2VsZWN0ZWRFbGVtZW50ICsgXCIvXCIgKyBlbGVtZW50LmVsZW1lbnRCKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCA9PT0gZWxlbWVudC5lbGVtZW50QSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnNldCh0X2lkeCwgaF9pZHgsIHNlbGVjdGVkRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgZWxlbWVudC5lbGVtZW50QSArIFwiL1wiICsgc2VsZWN0ZWRFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0KHRfaWR4LCBoX2lkeCwgc2VsZWN0ZWRFbGVtZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgLy8gUmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICAgICAgICAvLyBvcGVuXG5cbiAgICAgICAgICAgIGlmIChleGFjdF9lbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5vcGVuRWxlbWVudCA9IGV4YWN0X2VsZW1lbnQuZ2V0S2V5KClcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5kbygpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQudW5kbygpXG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKVxuICAgICAgICB0aGlzLnRpdGxlLnJlYWRPbmx5ID0gZmFsc2VcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuYnVpbGRlci5nZXRSZW5kZXJlZEVsZW1lbnQoVUkuZ2V0SW5zdGFuY2UoKS5vcGVuRWxlbWVudClcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTbGljZSB8fCBlbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSBlbGVtZW50XG4gICAgICAgIHRoaXMudGl0bGUudmFsdWUgPSB0aGlzLmxheW91dC5uYW1lXG5cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgU2xpY2Upe1xuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5zZXRXZWlyZG5lc3Nlcyh0aGlzLmJ1aWxkZXIud2VpcmRuZXNzZXMuZmlsdGVyKHcgPT4gKHdbMl0gPT09IHRoaXMubGF5b3V0LmdldEtleSgpKSkubWFwKHcgPT4gd1sxXSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNwbGluZURpc3BsYXlNYW5hZ2VyLnNldFdlaXJkbmVzc2VzKFtdKVxuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zcGxpbmVEaXNwbGF5TWFuYWdlci5zZXRQb3ModW5kZWZpbmVkKSAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXlvdXQuZ2V0UmVuZGVyZXIoKS5kcmF3KHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQsIC0xLCAtMSwgdHJ1ZSwgZmFsc2UpXG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKVxuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyByZWFkIH0gZnJvbSBcImRlZXBzbGF0ZVwiXG5pbXBvcnQgeyBFeHBvcnRlciB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9FeHBvcnRlclwiXG5pbXBvcnQgeyBVSSB9IGZyb20gXCIuL1VJXCJcblxuXG5cbmV4cG9ydCBjbGFzcyBNZW51TWFuYWdlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZFZhbmlsbGFCdXR0b246IEhUTUxFbGVtZW50XG4gICAgcHJpdmF0ZSBzdGF0aWMgb3BlbkJ1dHRvbjogSFRNTEVsZW1lbnRcbiAgICBwcml2YXRlIHN0YXRpYyBzYXZlQnV0dG9uOiBIVE1MRWxlbWVudFxuICAgIHByaXZhdGUgc3RhdGljIGV4cG9ydEJ1dHRvbjogSFRNTEVsZW1lbnRcblxuICAgIHN0YXRpYyBjcmVhdGVDbGlja0hhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmxvYWRWYW5pbGxhQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRWYW5pbGxhQnV0dG9uJylcbiAgICAgICAgdGhpcy5vcGVuQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29wZW5CdXR0b24nKVxuICAgICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZUJ1dHRvbicpXG4gICAgICAgIHRoaXMuZXhwb3J0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydEJ1dHRvbicpXG5cbiAgICAgICAgdGhpcy5sb2FkVmFuaWxsYUJ1dHRvbi5vbmNsaWNrID0gKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGZldGNoKCd2YW5pbGxhX292ZXJ3b3JsZF9iaW9tZV9idWlsZGVyLmpzb24nKS50aGVuKCByID0+IHIudGV4dCgpKS50aGVuKGpzb25TdHJpbmcgPT4ge1xuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkuYnVpbGRlci5sb2FkSlNPTihKU09OLnBhcnNlKGpzb25TdHJpbmcpKVxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkub3BlbkVsZW1lbnQgPSBcImFzc2lnbl9zbGljZXNcIlxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcGVuQnV0dG9uLm9uY2xpY2sgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnZmlsZSdcblxuICAgICAgICAgICAgaW5wdXQub25jaGFuZ2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmZpbGVzWzBdXG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUsICdVVEYtOCcpXG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKGV2dDogUHJvZ3Jlc3NFdmVudDxGaWxlUmVhZGVyPikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gZXZ0LnRhcmdldC5yZXN1bHQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkuYnVpbGRlci5sb2FkSlNPTihKU09OLnBhcnNlKGpzb25TdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLm9wZW5FbGVtZW50ID0gXCJhc3NpZ25fc2xpY2VzXCJcbiAgICAgICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5yZWZyZXNoKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dC5jbGljaygpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShVSS5nZXRJbnN0YW5jZSgpLmJ1aWxkZXIudG9KU09OKCkpXG4gICAgICAgICAgICBjb25zdCBiYiA9IG5ldyBCbG9iKFtqc29uU3RyaW5nXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pXG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgICAgICBhLmRvd25sb2FkID0gJ2Jpb21lX2J1aWxkZXIuanNvbidcbiAgICAgICAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJiKVxuICAgICAgICAgICAgYS5jbGljaygpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV4cG9ydEJ1dHRvbi5vbmNsaWNrID0gKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IEV4cG9ydGVyKFVJLmdldEluc3RhbmNlKCkuYnVpbGRlcilcbiAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBleHBvcnRlci5leHBvcnQoKVxuICAgICAgICAgICAgY29uc3QgYmIgPSBuZXcgQmxvYihbanNvblN0cmluZ10sIHt0eXBlOiAndGV4dC9wbGFpbid9KVxuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAgICAgYS5kb3dubG9hZCA9ICdkaW1lbnNpb24uanNvbidcbiAgICAgICAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJiKVxuICAgICAgICAgICAgYS5jbGljaygpXG4gICAgICAgIH1cblxuICAgIH1cbn0iLCJpbXBvcnQgeyBBQkVsZW1lbnQgfSBmcm9tIFwiLi4vLi4vQnVpbGRlckRhdGEvQUJCaW9tZVwiO1xuaW1wb3J0IHsgQmlvbWUgfSBmcm9tIFwiLi4vLi4vQnVpbGRlckRhdGEvQmlvbWVcIjtcbmltcG9ydCB7IExheW91dCB9IGZyb20gXCIuLi8uLi9CdWlsZGVyRGF0YS9MYXlvdXRcIjtcbmltcG9ydCB7IExheW91dEVsZW1lbnRVbmFzc2lnbmVkIH0gZnJvbSBcIi4uLy4uL0J1aWxkZXJEYXRhL0xheW91dEVsZW1lbnRVbmFzc2lnbmVkXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50UmVuZGVyZXJ7XG4gICAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbWluWDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIHRfaWR4OiBudW1iZXIsIGhfaWR4OiBudW1iZXIsIGluZGljYXRlUmVjdXJzaXZlOiBib29sZWFuLCBpc0ljb246IGJvb2xlYW4pOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgQmlvbWVSZW5kZXJlciBpbXBsZW1lbnRzIEVsZW1lbnRSZW5kZXJlcntcbiAgICBiaW9tZTogQmlvbWVcblxuICAgIGNvbnN0cnVjdG9yKGJpb21lOiBCaW9tZSl7XG4gICAgICAgIHRoaXMuYmlvbWUgPSBiaW9tZVxuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBtaW5YOiBudW1iZXIsIG1pblk6IG51bWJlciwgc2l6ZVg6IG51bWJlciwgc2l6ZVk6IG51bWJlciwgdF9pZHg6IG51bWJlciwgaF9pZHg6IG51bWJlciwgaW5kaWNhdGVSZWN1cnNpdmU6IGJvb2xlYW4gPSB0cnVlLCBpc0ljb246IGJvb2xlYW4gPSBmYWxzZSl7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJpb21lLmNvbG9yXG4gICAgICAgIGN0eC5maWxsUmVjdChtaW5YLCBtaW5ZLCBzaXplWCwgc2l6ZVkpXG4gICAgfVxuXG4gICAgcHVibGljIGdldElkc0Zyb21Qb3NpdGlvbihtaW5YOiBudW1iZXIsIG1pblk6IG51bWJlciwgc2l6ZVg6IG51bWJlciwgc2l6ZVk6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpOiB7dF9pZHg6IG51bWJlciwgaF9pZHg6IG51bWJlciwgbW9kZTogXCJBXCJ8XCJCXCJ9IHwgdW5kZWZpbmVke1xuICAgICAgICByZXR1cm4ge3RfaWR4OiAtMSwgaF9pZHg6IC0xLCBtb2RlOlwiQVwifVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuYXNzaWduZWRSZW5kZXJlciBpbXBsZW1lbnRzIEVsZW1lbnRSZW5kZXJlcntcbiAgICBwdWJsaWMgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbWluWDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIHRfaWR4OiBudW1iZXIsIGhfaWR4OiBudW1iZXIsIGluZGljYXRlUmVjdXJzaXZlOiBib29sZWFuID0gdHJ1ZSwgaXNJY29uOiBib29sZWFuID0gZmFsc2Upe1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJncmF5XCJcbiAgICAgICAgY3R4LmZpbGxSZWN0KG1pblgsIG1pblksIHNpemVYLCBzaXplWSlcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgIGN0eC5mb250ID0gKHNpemVYKjAuNzUpICsgJ3B4IHNlcmlmJ1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIlxuICAgICAgICBjdHguZmlsbFRleHQoXCI/XCIsIG1pblggKyBzaXplWCAqIDAuNSwgbWluWSArIHNpemVZICogMC41NSlcbiAgICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIEFCQmlvbWVSZW5kZXJlciBpbXBsZW1lbnRzIEVsZW1lbnRSZW5kZXJlcntcbiAgICBhYl9iaW9tZTogQUJFbGVtZW50XG5cbiAgICBjb25zdHJ1Y3RvcihhYl9iaW9tZTogQUJFbGVtZW50KXtcbiAgICAgICAgdGhpcy5hYl9iaW9tZSA9IGFiX2Jpb21lXG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG1pblg6IG51bWJlciwgbWluWTogbnVtYmVyLCBzaXplWDogbnVtYmVyLCBzaXplWTogbnVtYmVyLCB0X2lkeDogbnVtYmVyLCBoX2lkeDogbnVtYmVyLCBpbmRpY2F0ZVJlY3Vyc2l2ZTogYm9vbGVhbiA9IHRydWUsIGlzSWNvbjogYm9vbGVhbiA9IGZhbHNlKXtcbiAgICAgICAgY29uc3QgaXNBUmVjdXJzaXZlID0gdGhpcy5hYl9iaW9tZS5nZXRFbGVtZW50KFwiQVwiKSBpbnN0YW5jZW9mIExheW91dFxuICAgICAgICBjb25zdCBpc0JSZWN1cnNpdmUgPSB0aGlzLmFiX2Jpb21lLmdldEVsZW1lbnQoXCJCXCIpIGluc3RhbmNlb2YgTGF5b3V0XG5cbiAgICAgICAgY29uc3QgZWxlbWVudEEgPSB0aGlzLmFiX2Jpb21lLmxvb2t1cFJlY3Vyc2l2ZSh0X2lkeCwgaF9pZHgsIFwiQVwiKVxuXG4gICAgICAgIGlmIChlbGVtZW50QSBpbnN0YW5jZW9mIEJpb21lKVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IChlbGVtZW50QSBhcyBCaW9tZSkuY29sb3JcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudEEgaW5zdGFuY2VvZiBMYXlvdXRFbGVtZW50VW5hc3NpZ25lZClcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImdyYXlcIlxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHgubW92ZVRvKG1pblgsIG1pblkpXG4gICAgICAgIGN0eC5saW5lVG8obWluWCArIHNpemVYLCBtaW5ZKVxuICAgICAgICBjdHgubGluZVRvKG1pblgsIG1pblkgKyBzaXplWSlcbiAgICAgICAgY3R4LmZpbGwoKVxuXG4gICAgICAgIGlmIChlbGVtZW50QSBpbnN0YW5jZW9mIExheW91dEVsZW1lbnRVbmFzc2lnbmVkKXtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCJcbiAgICAgICAgICAgIGN0eC5mb250ID0gKHNpemVYKjAuNSkgKyAncHggc2VyaWYnXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIj9cIiwgbWluWCArIHNpemVYICogMC4zLCBtaW5ZICsgc2l6ZVkgKiAwLjQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kaWNhdGVSZWN1cnNpdmUgJiYgaXNBUmVjdXJzaXZlKXtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigyNTUsMjU1LDI1NSwwLjgpXCJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhtaW5YLCBtaW5ZKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhtaW5YICsgc2l6ZVgsIG1pblkpXG4gICAgICAgICAgICBjdHgubGluZVRvKG1pblgsIG1pblkgKyBzaXplWSlcbiAgICAgICAgICAgIGN0eC5maWxsKClcblxuICAgICAgICAgICAgaWYgKCFpc0ljb24pe1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigwLDAsMCwxKVwiXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAnMTEwcHggc2VyaWYnO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoJ+KGtScsIG1pblggKyAwLjI1ICogc2l6ZVgsIG1pblkgKyAwLjMzICogc2l6ZVkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbGVtZW50QiA9IHRoaXMuYWJfYmlvbWUubG9va3VwUmVjdXJzaXZlKHRfaWR4LCBoX2lkeCwgXCJCXCIpXG5cbiAgICAgICAgaWYgKGVsZW1lbnRCIGluc3RhbmNlb2YgQmlvbWUpXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gKGVsZW1lbnRCIGFzIEJpb21lKS5jb2xvclxuICAgICAgICBlbHNlIGlmIChlbGVtZW50QiBpbnN0YW5jZW9mIExheW91dEVsZW1lbnRVbmFzc2lnbmVkKVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiZ3JheVwiXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHgubW92ZVRvKG1pblggKyBzaXplWCwgbWluWSlcbiAgICAgICAgY3R4LmxpbmVUbyhtaW5YICsgc2l6ZVgsIG1pblkgKyBzaXplWSlcbiAgICAgICAgY3R4LmxpbmVUbyhtaW5YLCBtaW5ZICsgc2l6ZVkpXG4gICAgICAgIGN0eC5maWxsKClcblxuICAgICAgICBpZiAoZWxlbWVudEIgaW5zdGFuY2VvZiBMYXlvdXRFbGVtZW50VW5hc3NpZ25lZCl7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgICAgICBjdHguZm9udCA9IChzaXplWCowLjUpICsgJ3B4IHNlcmlmJ1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCJcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXCI/XCIsIG1pblggKyBzaXplWCAqIDAuNzIsIG1pblkgKyBzaXplWSAqIDAuNzUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kaWNhdGVSZWN1cnNpdmUgJiYgaXNCUmVjdXJzaXZlKXtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigyNTUsMjU1LDI1NSwwLjgpXCJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhtaW5YICsgc2l6ZVgsIG1pblkpXG4gICAgICAgICAgICBjdHgubGluZVRvKG1pblggKyBzaXplWCwgbWluWSArIHNpemVZKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhtaW5YLCBtaW5ZICsgc2l6ZVkpXG4gICAgICAgICAgICBjdHguZmlsbCgpXG5cbiAgICAgICAgICAgIGlmICghaXNJY29uKXtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoMCwwLDAsMSlcIlxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gJzExMHB4IHNlcmlmJztcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCfihrUnLCBtaW5YICsgMC43MiAqIHNpemVYLCBtaW5ZICsgMC44ICogc2l6ZVkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHNpemVYIC8gMzBcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5tb3ZlVG8obWluWCArIHNpemVYLCBtaW5ZKVxuICAgICAgICBjdHgubGluZVRvKG1pblgsIG1pblkgKyBzaXplWSlcbiAgICAgICAgY3R4LnN0cm9rZSgpXG5cbiAgICB9XG59IiwiaW1wb3J0IHsgbGFzdCB9IGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IExheW91dCB9IGZyb20gXCIuLi8uLi9CdWlsZGVyRGF0YS9MYXlvdXRcIlxuaW1wb3J0IHsgRWxlbWVudFJlbmRlcmVyIH0gZnJvbSBcIi4vRWxlbWVudFJlbmRlcmVyXCJcblxuZXhwb3J0IGNsYXNzIExheW91dEdyaWRSZW5kZXJlciBpbXBsZW1lbnRzIEVsZW1lbnRSZW5kZXJlcntcbiAgICBwcml2YXRlIGxheW91dDogTGF5b3V0XG5cbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQ6IExheW91dCl7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG1pblg6IG51bWJlciwgbWluWTogbnVtYmVyLCBzaXplWDogbnVtYmVyLCBzaXplWTogbnVtYmVyLCBfdF9pZHg6IG51bWJlciA9IC0xLCBfaF9pZHg6IG51bWJlciA9IC0xLCBpbmRpY2F0ZVJlY3Vyc2l2ZTogYm9vbGVhbiA9IHRydWUsIGlzSWNvbjogYm9vbGVhbiA9IGZhbHNlKXtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubGF5b3V0LmdldFNpemUoKVxuXG4gICAgICAgIGNvbnN0IG1heEVsZW1lbnRTaXplWCA9IHNpemVYIC8gc2l6ZVsxXVxuICAgICAgICBjb25zdCBtYXhFbGVtZW50U2l6ZVkgPSBzaXplWSAvIHNpemVbMF1cblxuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IE1hdGgubWluKG1heEVsZW1lbnRTaXplWCwgbWF4RWxlbWVudFNpemVZKVxuXG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSAoZWxlbWVudFNpemUgKiBzaXplWzFdIC0gc2l6ZVgpLzIgKyBtaW5YXG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSAoZWxlbWVudFNpemUgKiBzaXplWzBdIC0gc2l6ZVkpLzIgKyBtaW5ZXG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdChtaW5YLCBtaW5ZLCBzaXplWCwgc2l6ZVkpXG5cbiAgICAgICAgZm9yICh2YXIgdF9pZHggPSAwIDsgdF9pZHggPCBzaXplWzBdIDsgdF9pZHgrKyl7XG4gICAgICAgICAgICBmb3IgKHZhciBoX2lkeCA9IDAgOyBoX2lkeCA8IHNpemVbMV0gOyBoX2lkeCsrKXtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMubGF5b3V0Lmxvb2t1cCh0X2lkeCwgaF9pZHgpXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmRlZmluZWQgYXQ6IFwiICsgdF9pZHggKyBcIiwgXCIgKyBoX2lkeClcbiAgICAgICAgICAgICAgICB2YXIgaXNSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIExheW91dCl7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lmxvb2t1cFJlY3Vyc2l2ZSh0X2lkeCwgaF9pZHgsIFwiQW55XCIpXG4gICAgICAgICAgICAgICAgICAgIGlzUmVjdXJzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmdldFJlbmRlcmVyKCkuZHJhdyhjdHgsIHhPZmZzZXQgKyBoX2lkeCAqIGVsZW1lbnRTaXplLCB5T2Zmc2V0ICsgdF9pZHggKiBlbGVtZW50U2l6ZSwgZWxlbWVudFNpemUsIGVsZW1lbnRTaXplLCB0X2lkeCwgaF9pZHgsIGluZGljYXRlUmVjdXJzaXZlLCBpc0ljb24pXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZWN1cnNpdmUgJiYgaW5kaWNhdGVSZWN1cnNpdmUpe1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoMjU1LDI1NSwyNTUsMC44KVwiXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4T2Zmc2V0ICsgaF9pZHggKiBlbGVtZW50U2l6ZSwgeU9mZnNldCArIHRfaWR4ICogZWxlbWVudFNpemUsIGVsZW1lbnRTaXplLCBlbGVtZW50U2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNJY29uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigwLDAsMCwxKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9ICcxNDBweCBzZXJpZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCgn4oa1JywgeE9mZnNldCArIChoX2lkeCswLjUpICogZWxlbWVudFNpemUsIHlPZmZzZXQgKyAodF9pZHgrMC42KSAqIGVsZW1lbnRTaXplKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGVsZW1lbnRTaXplIC8gMzBcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4T2Zmc2V0ICsgaF9pZHggKiBlbGVtZW50U2l6ZSwgeU9mZnNldCArIHRfaWR4ICogZWxlbWVudFNpemUsIGVsZW1lbnRTaXplLCBlbGVtZW50U2l6ZSlcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJZHNGcm9tUG9zaXRpb24obWluWDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKToge3RfaWR4OiBudW1iZXIsIGhfaWR4OiBudW1iZXIsIGxvY2FsX3Q6IG51bWJlciwgbG9jYWxfaDogbnVtYmVyLCBtb2RlOiBcIkFcInxcIkJcIn0gfCB1bmRlZmluZWR7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxheW91dC5nZXRTaXplKClcblxuICAgICAgICBjb25zdCBtYXhFbGVtZW50U2l6ZVggPSBzaXplWCAvIHNpemVbMV1cbiAgICAgICAgY29uc3QgbWF4RWxlbWVudFNpemVZID0gc2l6ZVkgLyBzaXplWzBdXG5cbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBNYXRoLm1pbihtYXhFbGVtZW50U2l6ZVgsIG1heEVsZW1lbnRTaXplWSlcblxuICAgICAgICBpZiAoeCA8IG1pblggfHwgeSA8IG1pblkgfHwgeCA+IG1pblggKyBzaXplWzFdICogZWxlbWVudFNpemUgfHwgeSA+IG1pblkgKyBzaXplWzBdICogZWxlbWVudFNpemUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgICAgY29uc3QgdF9pZHggPSBNYXRoLmZsb29yKCh5IC0gbWluWSkgLyBlbGVtZW50U2l6ZSlcbiAgICAgICAgY29uc3QgaF9pZHggPSBNYXRoLmZsb29yKCh4IC0gbWluWCkgLyBlbGVtZW50U2l6ZSlcblxuICAgICAgICBjb25zdCBsb2NhbFggPSB4IC0gbWluWCAtICh0X2lkeCAqIGVsZW1lbnRTaXplKVxuICAgICAgICBjb25zdCBsb2NhbFkgPSB5IC0gbWluWSAtIChoX2lkeCAqIGVsZW1lbnRTaXplKVxuICAgICAgICBjb25zdCBtb2RlID0gbG9jYWxYID4gZWxlbWVudFNpemUgLSBsb2NhbFkgPyBcIkJcIiA6IFwiQVwiXG5cbiAgICAgICAgcmV0dXJuIHt0X2lkeDogdF9pZHgsIGhfaWR4OiBoX2lkeCwgbG9jYWxfdDogbG9jYWxYIC8gZWxlbWVudFNpemUsIGxvY2FsX2g6IGxvY2FsWSAvIGVsZW1lbnRTaXplLCBtb2RlOiBtb2RlfVxuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgbGFzdCB9IGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IExheW91dCB9IGZyb20gXCIuLi8uLi9CdWlsZGVyRGF0YS9MYXlvdXRcIlxuaW1wb3J0IHsgU2xpY2UgfSBmcm9tIFwiLi4vLi4vQnVpbGRlckRhdGEvU2xpY2VcIjtcbmltcG9ydCB7IEVsZW1lbnRSZW5kZXJlciB9IGZyb20gXCIuL0VsZW1lbnRSZW5kZXJlclwiXG5cbmV4cG9ydCBjbGFzcyBTbGljZUdyaWRSZW5kZXJlciB7XG4gICAgcHJpdmF0ZSBzbGljZTogU2xpY2VcblxuICAgIGNvbnN0cnVjdG9yKHNsaWNlOiBTbGljZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2VcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbWluWDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIF90X2lkeDogbnVtYmVyID0gLTEsIF9oX2lkeDogbnVtYmVyID0gLTEsIGluZGljYXRlUmVjdXJzaXZlOiBib29sZWFuID0gdHJ1ZSwgaXNJY29uOiBib29sZWFuID0gZmFsc2Upe1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zbGljZS5nZXRTaXplKClcblxuICAgICAgICBjb25zdCBtYXhFbGVtZW50U2l6ZVggPSBzaXplWCAvIHNpemVbMV1cbiAgICAgICAgY29uc3QgbWF4RWxlbWVudFNpemVZID0gc2l6ZVkgLyBzaXplWzBdXG5cbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBNYXRoLm1pbihtYXhFbGVtZW50U2l6ZVgsIG1heEVsZW1lbnRTaXplWSlcblxuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gKGVsZW1lbnRTaXplICogc2l6ZVsxXSAtIHNpemVYKSAvIDIgKyBtaW5YXG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSAoZWxlbWVudFNpemUgKiBzaXplWzBdIC0gc2l6ZVkpIC8gMiArIG1pbllcblxuICAgICAgICBjdHguY2xlYXJSZWN0KG1pblgsIG1pblksIHNpemVYLCBzaXplWSlcblxuICAgICAgICBmb3IgKHZhciB0X2lkeCA9IDA7IHRfaWR4IDwgc2l6ZVswXTsgdF9pZHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaF9pZHggPSAwOyBoX2lkeCA8IHNpemVbMV07IGhfaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuc2xpY2UubG9va3VwKHRfaWR4LCBoX2lkeClcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVuZGVmaW5lZCBhdDogXCIgKyB0X2lkeCArIFwiLCBcIiArIGhfaWR4KVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBMYXlvdXQgJiYgIWlzSWNvbilcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRSZW5kZXJlcigpLmRyYXcoY3R4LCB4T2Zmc2V0ICsgKGhfaWR4ICsgMC4xKSAqIGVsZW1lbnRTaXplLCB5T2Zmc2V0ICsgKHRfaWR4ICsgMC4xKSAqIGVsZW1lbnRTaXplLCBlbGVtZW50U2l6ZSAqIDAuOCwgZWxlbWVudFNpemUgKiAwLjgsIHRfaWR4LCBoX2lkeCwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmdldFJlbmRlcmVyKCkuZHJhdyhjdHgsIHhPZmZzZXQgKyBoX2lkeCAqIGVsZW1lbnRTaXplLCB5T2Zmc2V0ICsgdF9pZHggKiBlbGVtZW50U2l6ZSwgZWxlbWVudFNpemUsIGVsZW1lbnRTaXplLCB0X2lkeCwgaF9pZHgsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIExheW91dCAmJiAhaXNJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigwLDAsMCwxKVwiXG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gJzYwcHggc2VyaWYnO1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoJ+KGtScsIHhPZmZzZXQgKyAoaF9pZHggKyAwLjUpICogZWxlbWVudFNpemUsIHlPZmZzZXQgKyAodF9pZHggKyAwLjYpICogZWxlbWVudFNpemUpXG4gICAgICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZWxlbWVudFNpemUgLyAzMFxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHhPZmZzZXQgKyBoX2lkeCAqIGVsZW1lbnRTaXplLCB5T2Zmc2V0ICsgdF9pZHggKiBlbGVtZW50U2l6ZSwgZWxlbWVudFNpemUsIGVsZW1lbnRTaXplKVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJZHNGcm9tUG9zaXRpb24obWluWDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKToge3RfaWR4OiBudW1iZXIsIGhfaWR4OiBudW1iZXIsIGxvY2FsX3Q6IG51bWJlciwgbG9jYWxfaDogbnVtYmVyLCBtb2RlOiBcIkFcInxcIkJcIn0gIHwgdW5kZWZpbmVke1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zbGljZS5nZXRTaXplKClcblxuICAgICAgICBjb25zdCBtYXhFbGVtZW50U2l6ZVggPSBzaXplWCAvIHNpemVbMV1cbiAgICAgICAgY29uc3QgbWF4RWxlbWVudFNpemVZID0gc2l6ZVkgLyBzaXplWzBdXG5cbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBNYXRoLm1pbihtYXhFbGVtZW50U2l6ZVgsIG1heEVsZW1lbnRTaXplWSlcblxuICAgICAgICBpZiAoeCA8IG1pblggfHwgeSA8IG1pblkgfHwgeCA+IG1pblggKyBzaXplWzFdICogZWxlbWVudFNpemUgfHwgeSA+IG1pblkgKyBzaXplWzBdICogZWxlbWVudFNpemUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgICAgY29uc3QgdF9pZHggPSBNYXRoLmZsb29yKCh5IC0gbWluWSkgLyBlbGVtZW50U2l6ZSlcbiAgICAgICAgY29uc3QgaF9pZHggPSBNYXRoLmZsb29yKCh4IC0gbWluWCkgLyBlbGVtZW50U2l6ZSlcblxuICAgICAgICBjb25zdCBsb2NhbFggPSB4IC0gbWluWCAtIChoX2lkeCAqIGVsZW1lbnRTaXplKVxuICAgICAgICBjb25zdCBsb2NhbFkgPSB5IC0gbWluWSAtICh0X2lkeCAqIGVsZW1lbnRTaXplKVxuICAgICAgICBjb25zdCBtb2RlID0gbG9jYWxYID4gZWxlbWVudFNpemUgLSBsb2NhbFkgPyBcIkJcIiA6IFwiQVwiXG5cbiAgICAgICAgcmV0dXJuIHt0X2lkeDogdF9pZHgsIGhfaWR4OiBoX2lkeCwgbG9jYWxfaDogbG9jYWxYIC8gZWxlbWVudFNpemUsIGxvY2FsX3Q6IGxvY2FsWSAvIGVsZW1lbnRTaXplLCBtb2RlOiBtb2RlfVxuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgQmlvbWUgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvQmlvbWVcIlxuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0Jpb21lQnVpbGRlclwiXG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvTGF5b3V0XCJcbmltcG9ydCB7IExheW91dEVsZW1lbnQgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvTGF5b3V0RWxlbWVudFwiXG5pbXBvcnQgeyBTbGljZSB9IGZyb20gXCIuLi9CdWlsZGVyRGF0YS9TbGljZVwiXG5pbXBvcnQgeyBMYXlvdXRFZGl0b3IgfSBmcm9tIFwiLi9MYXlvdXRFZGl0b3JcIlxuaW1wb3J0IHsgVUkgfSBmcm9tIFwiLi9VSVwiXG5cblxuXG5leHBvcnQgY2xhc3MgU2lkZWJhck1hbmFnZXIge1xuICAgIHByaXZhdGUgc2lkZWJhcjogSFRNTEVsZW1lbnRcbiAgICBwcml2YXRlIGJ1aWxkZXI6IEJpb21lQnVpbGRlclxuXG4gICAgcHJpdmF0ZSBsYXlvdXRfZGl2czogSFRNTEVsZW1lbnRbXVxuICAgIHByaXZhdGUgYmlvbWVfZGl2czogSFRNTEVsZW1lbnRbXVxuICAgIHByaXZhdGUgYm90dG9tX3NwYWNlcjogSFRNTEVsZW1lbnRcbiAgICBwcml2YXRlIHNlYXJjaF9iYXI6IEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IEJpb21lQnVpbGRlcikge1xuICAgICAgICB0aGlzLnNpZGViYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpZGViYXJfbWVudVwiKVxuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyXG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3QgbGFzdFNlYXJjaCA9ICh0aGlzLnNpZGViYXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlYXJjaF9iYXJcIik/LlswXSBhcyBIVE1MSW5wdXRFbGVtZW50KT8udmFsdWUgPz8gXCJcIlxuXG4gICAgICAgIHRoaXMuc2lkZWJhci5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgIHRoaXMubGF5b3V0X2RpdnMgPSBbXVxuICAgICAgICB0aGlzLmJpb21lX2RpdnMgPSBbXVxuXG4gICAgICAgIC8vIEFkZCBBc3NpZ24gc3BsaWNlcyBCdXR0b25cbiAgICAgICAgY29uc3QgYXNzaWduU3BsaWNlc0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgYXNzaWduU3BsaWNlc0J1dHRvbi5jbGFzc0xpc3QuYWRkKFwic2lkZWJhcl9lbnRyeVwiKVxuICAgICAgICBhc3NpZ25TcGxpY2VzQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJhc3NpZ25fc2xpY2VzX2J1dHRvblwiKVxuICAgICAgICBpZiAoVUkuZ2V0SW5zdGFuY2UoKS5vcGVuRWxlbWVudCA9PT0gXCJhc3NpZ25fc2xpY2VzXCIpIHtcbiAgICAgICAgICAgIGFzc2lnblNwbGljZXNCdXR0b24uY2xhc3NMaXN0LmFkZChcIm9wZW5cIilcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25TcGxpY2VzQnV0dG9uLmlubmVySFRNTCA9IFwiQXNzaWduIFNsaWNlc1wiXG4gICAgICAgIGFzc2lnblNwbGljZXNCdXR0b24ub25jbGljayA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNlbGVjdGVkRWxlbWVudCA9IFwiXCJcbiAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkub3BlbkVsZW1lbnQgPSBcImFzc2lnbl9zbGljZXNcIlxuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5yZWZyZXNoKClcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduU3BsaWNlc0J1dHRvbi5vbmNvbnRleHRtZW51ID0gYXNzaWduU3BsaWNlc0J1dHRvbi5vbmNsaWNrXG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZChhc3NpZ25TcGxpY2VzQnV0dG9uKVxuXG4gICAgICAgIC8vIEFkZCBzcGFjZXJcbiAgICAgICAgY29uc3Qgc3BhY2VyMCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgc3BhY2VyMC5jbGFzc0xpc3QuYWRkKFwic3BhY2VyXCIpXG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZChzcGFjZXIwKVxuXG4gICAgICAgIC8vIEFkZCBBZGQgQnV0dG9uXG4gICAgICAgIGNvbnN0IGFkZFNsaWNlc0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgYWRkU2xpY2VzQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJzaWRlYmFyX2VudHJ5XCIpXG4gICAgICAgIGFkZFNsaWNlc0J1dHRvbi5jbGFzc0xpc3QuYWRkKFwiYWRkX2xheW91dF9idXR0b25cIilcbiAgICAgICAgYWRkU2xpY2VzQnV0dG9uLmlubmVySFRNTCA9IFwiKyBBZGQgU2xpY2VcIlxuICAgICAgICBhZGRTbGljZXNCdXR0b24ub25jbGljayA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IFNsaWNlLmNyZWF0ZSh0aGlzLmJ1aWxkZXIsIFwiTmV3IFNsaWNlXCIsIFwidW5hc3NpZ25lZFwiKVxuICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5vcGVuRWxlbWVudCA9IHNsaWNlLmdldEtleSgpXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgdGhpcy5zaWRlYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJvcGVuXCIpWzBdLnNjcm9sbEludG9WaWV3KGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZChhZGRTbGljZXNCdXR0b24pXG5cbiAgICAgICAgLy8gQWRkIFNsaWNlc1xuICAgICAgICB0aGlzLmJ1aWxkZXIuc2xpY2VzLmZvckVhY2goc2xpY2UgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRfZGl2cy5wdXNoKHRoaXMuY3JlYXRlRWxlbWVudERpdihzbGljZSwgXCJzbGljZVwiKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwYWNlclxuICAgICAgICBjb25zdCBzcGFjZXIxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICBzcGFjZXIxLmNsYXNzTGlzdC5hZGQoXCJzcGFjZXJcIilcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHNwYWNlcjEpXG5cbiAgICAgICAgLy8gQWRkIEFkZCBCdXR0b25cbiAgICAgICAgY29uc3QgYWRkTGF5b3V0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICBhZGRMYXlvdXRCdXR0b24uY2xhc3NMaXN0LmFkZChcInNpZGViYXJfZW50cnlcIilcbiAgICAgICAgYWRkTGF5b3V0QnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJhZGRfbGF5b3V0X2J1dHRvblwiKVxuICAgICAgICBhZGRMYXlvdXRCdXR0b24uaW5uZXJIVE1MID0gXCIrIEFkZCBMYXlvdXRcIlxuICAgICAgICBhZGRMYXlvdXRCdXR0b24ub25jbGljayA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSBMYXlvdXQuY3JlYXRlKHRoaXMuYnVpbGRlciwgXCJOZXcgTGF5b3V0XCIpXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLm9wZW5FbGVtZW50ID0gbGF5b3V0LmdldEtleSgpXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgdGhpcy5zaWRlYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJvcGVuXCIpWzBdLnNjcm9sbEludG9WaWV3KGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZChhZGRMYXlvdXRCdXR0b24pXG5cbiAgICAgICAgLy8gTGF5b3V0c1xuICAgICAgICB0aGlzLmJ1aWxkZXIubGF5b3V0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRfZGl2cy5wdXNoKHRoaXMuY3JlYXRlRWxlbWVudERpdihlbGVtZW50LCBcImxheW91dFwiKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwYWNlclxuICAgICAgICBjb25zdCBzcGFjZXIyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICBzcGFjZXIyLmNsYXNzTGlzdC5hZGQoXCJzcGFjZXJcIilcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHNwYWNlcjIpXG5cbiAgICAgICAgLy8gQWRkIEFkZCBCdXR0b25cbiAgICAgICAgY29uc3QgYWRkQmlvbWVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIGFkZEJpb21lQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJzaWRlYmFyX2VudHJ5XCIpXG4gICAgICAgIGFkZEJpb21lQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJhZGRfbGF5b3V0X2J1dHRvblwiKVxuICAgICAgICBhZGRCaW9tZUJ1dHRvbi5pbm5lckhUTUwgPSBcIisgQWRkIEJpb21lXCJcbiAgICAgICAgYWRkQmlvbWVCdXR0b24ub25jbGljayA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiaW9tZV9uYW1lID0gcHJvbXB0KFwiSW5wdXQgYmlvbWUgbmFtZTpcIiwgXCJuZXc6YmlvbWVcIilcbiAgICAgICAgICAgIGlmIChiaW9tZV9uYW1lID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgY29uc3QgYmlvbWUgPSBCaW9tZS5jcmVhdGUodGhpcy5idWlsZGVyLCBiaW9tZV9uYW1lLCBcIiM4ODg4ODhcIilcbiAgICAgICAgICAgIGlmIChVSS5nZXRJbnN0YW5jZSgpLm9wZW5FbGVtZW50ICE9PSBcImFzc2lnbl9zbGlzZXNcIilcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnNlbGVjdGVkRWxlbWVudCA9IGJpb21lLmdldEtleSgpXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZChhZGRCaW9tZUJ1dHRvbilcblxuICAgICAgICAvLyBBZGQgc2VhY2hCYXJcbiAgICAgICAgdGhpcy5zZWFyY2hfYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgICAgdGhpcy5zZWFyY2hfYmFyLnR5cGUgPSBcInRleHRcIlxuICAgICAgICB0aGlzLnNlYXJjaF9iYXIucGxhY2Vob2xkZXIgPSBcIlNlYWNoLi4uXCJcbiAgICAgICAgdGhpcy5zZWFyY2hfYmFyLnZhbHVlID0gbGFzdFNlYXJjaFxuICAgICAgICB0aGlzLnNlYXJjaF9iYXIuY2xhc3NMaXN0LmFkZChcInNlYXJjaF9iYXJcIilcbiAgICAgICAgdGhpcy5zZWFyY2hfYmFyLm9uaW5wdXQgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCaW9tZVNlYXJjaCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHRoaXMuc2VhcmNoX2JhcilcblxuICAgICAgICAvLyBCaW9tZXNcbiAgICAgICAgdGhpcy5idWlsZGVyLmJpb21lcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5jcmVhdGVFbGVtZW50RGl2KGVsZW1lbnQsIFwiYmlvbWVcIilcbiAgICAgICAgICAgIHRoaXMuYmlvbWVfZGl2cy5wdXNoKGRpdilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdmFuaWxsYV9sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgdmFuaWxsYV9sYWJlbC5pbm5lckhUTUwgPSBcIlVudXNlZCBWYW5pbGxhIEJpb21lc1wiXG4gICAgICAgIHZhbmlsbGFfbGFiZWwuY2xhc3NMaXN0LmFkZChcImxhYmVsXCIpXG4gICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZCh2YW5pbGxhX2xhYmVsKVxuXG4gICAgICAgIC8vIFZhbmlsbGEgQmlvbWVzXG4gICAgICAgIHRoaXMuYnVpbGRlci52YW5pbGxhQmlvbWVzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5idWlsZGVyLmxheW91dEVsZW1lbnRzLmhhcyhlbGVtZW50LmdldEtleSgpKSlcbiAgICAgICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5jcmVhdGVFbGVtZW50RGl2KGVsZW1lbnQsIFwidmFuaWxsYV9iaW9tZVwiKVxuICAgICAgICAgICAgdGhpcy5iaW9tZV9kaXZzLnB1c2goZGl2KVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIEFkZCBib3R0b20gc3BhY2VyXG4gICAgICAgIHRoaXMuYm90dG9tX3NwYWNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgdGhpcy5ib3R0b21fc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJzcGFjZXJcIilcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHRoaXMuYm90dG9tX3NwYWNlcilcblxuICAgICAgICB0aGlzLnNpZGViYXIub25zY3JvbGwgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm90dG9tX3NwYWNlcl9wb3MgPSB0aGlzLmJvdHRvbV9zcGFjZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5zaWRlYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAgICAgY29uc3QgYm90dG9tX3NwYWNlcl9oZWlnaHQgPSBNYXRoLm1heCgodGhpcy5zaWRlYmFyLmNsaWVudEhlaWdodCAtIGJvdHRvbV9zcGFjZXJfcG9zIC0gMjApLCAwKVxuICAgICAgICAgICAgdGhpcy5ib3R0b21fc3BhY2VyLnN0eWxlLmhlaWdodCA9IGJvdHRvbV9zcGFjZXJfaGVpZ2h0ICsgXCJweFwiXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUJpb21lU2VhcmNoKClcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUJpb21lU2VhcmNoKCkge1xuICAgICAgICB0aGlzLmJvdHRvbV9zcGFjZXIuc3R5bGUuaGVpZ2h0ID0gXCIxMDAwMHB0XCJcblxuICAgICAgICB0aGlzLmJpb21lX2RpdnMuZm9yRWFjaChkaXYgPT4ge1xuICAgICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoXCJrZXlcIikuaW5jbHVkZXModGhpcy5zZWFyY2hfYmFyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgYm90dG9tX3NwYWNlcl9wb3MgPSB0aGlzLmJvdHRvbV9zcGFjZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5zaWRlYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICBjb25zdCBib3R0b21fc3BhY2VyX2hlaWdodCA9IE1hdGgubWF4KCh0aGlzLnNpZGViYXIuY2xpZW50SGVpZ2h0IC0gYm90dG9tX3NwYWNlcl9wb3MgLSAyMCksIDApXG4gICAgICAgIHRoaXMuYm90dG9tX3NwYWNlci5zdHlsZS5oZWlnaHQgPSBib3R0b21fc3BhY2VyX2hlaWdodCArIFwicHhcIlxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVFbGVtZW50RGl2KGVsZW1lbnQ6IExheW91dEVsZW1lbnQgfCBTbGljZSwgYzogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdCBlbGVtZW50X2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LmFkZChcInNpZGViYXJfZW50cnlcIilcbiAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LmFkZChjKVxuICAgICAgICBlbGVtZW50X2Rpdi5kcmFnZ2FibGUgPSAoYyAhPT0gXCJ2YW5pbGxhX2Jpb21lXCIpXG5cbiAgICAgICAgaWYgKGVsZW1lbnQuZ2V0S2V5KCkgPT09IFVJLmdldEluc3RhbmNlKCk/LnNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5nZXRLZXkoKSA9PT0gVUkuZ2V0SW5zdGFuY2UoKT8ub3BlbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRfZGl2LmNsYXNzTGlzdC5hZGQoXCJvcGVuXCIpXG4gICAgICAgIH1cblxuXG4gICAgICAgIGVsZW1lbnRfZGl2LnNldEF0dHJpYnV0ZShcImtleVwiLCBlbGVtZW50Lm5hbWUpXG5cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCaW9tZSkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JfaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudFxuICAgICAgICAgICAgY29sb3JfaW5wdXQuY2xhc3NMaXN0LmFkZChcImNvbG9yX3NlbGVjdG9yXCIpXG4gICAgICAgICAgICBjb2xvcl9pbnB1dC50eXBlID0gXCJjb2xvclwiXG4gICAgICAgICAgICBjb2xvcl9pbnB1dC52YWx1ZSA9IGVsZW1lbnQuY29sb3JcbiAgICAgICAgICAgIC8vY29sb3JfaW5wdXQuZGlzYWJsZWQgPSAhZWxlbWVudC5hbGxvd0VkaXRcblxuICAgICAgICAgICAgY29sb3JfaW5wdXQub25jaGFuZ2UgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY29sb3IgPSBjb2xvcl9pbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50X2Rpdi5hcHBlbmRDaGlsZChjb2xvcl9pbnB1dClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICAgICAgICBsYXlvdXRfY2FudmFzLmNsYXNzTGlzdC5hZGQoXCJncmlkXCIpXG4gICAgICAgICAgICBsYXlvdXRfY2FudmFzLndpZHRoID0gMTAwXG4gICAgICAgICAgICBsYXlvdXRfY2FudmFzLmhlaWdodCA9IDEwMFxuICAgICAgICAgICAgZWxlbWVudC5nZXRSZW5kZXJlcigpLmRyYXcobGF5b3V0X2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIDAsIDAsIDEwMCwgMTAwLCAtMSwgLTEsIGZhbHNlLCB0cnVlKVxuICAgICAgICAgICAgZWxlbWVudF9kaXYuYXBwZW5kQ2hpbGQobGF5b3V0X2NhbnZhcylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxheW91dF9uYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgbGF5b3V0X25hbWUuaW5uZXJIVE1MID0gZWxlbWVudC5uYW1lXG4gICAgICAgIGxheW91dF9uYW1lLmNsYXNzTGlzdC5hZGQoXCJuYW1lXCIpXG4gICAgICAgIGVsZW1lbnRfZGl2LmFwcGVuZENoaWxkKGxheW91dF9uYW1lKVxuXG4gICAgICAgIGlmIChlbGVtZW50LmFsbG93RWRpdCkge1xuXG4gICAgICAgICAgICBjb25zdCBlZGl0X25hbWVfYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSBhcyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBlZGl0X25hbWVfYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJidXR0b25cIiwgXCJlZGl0XCIpXG4gICAgICAgICAgICBlZGl0X25hbWVfYnV0dG9uLnNyYyA9IFwiZWRpdC1wZW4uc3ZnXCJcbiAgICAgICAgICAgIGVkaXRfbmFtZV9idXR0b24ub25jbGljayA9IChldnQpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld19uYW1lID0gcHJvbXB0KFwiRWRpdCBuYW1lIG9mIFwiICsgZWxlbWVudC5jb25zdHJ1Y3Rvci5uYW1lLCBlbGVtZW50Lm5hbWUpXG4gICAgICAgICAgICAgICAgaWYgKG5ld19uYW1lID09PSBudWxsKSByZXR1cm5cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5hbWUgPSBuZXdfbmFtZTtcbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudF9kaXYuYXBwZW5kQ2hpbGQoZWRpdF9uYW1lX2J1dHRvbilcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgIT09IFwidmFuaWxsYV9iaW9tZVwiKXtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSBhcyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBkYi5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uXCIsIFwiZGVsZXRlXCIpXG4gICAgICAgICAgICBkYi5zcmMgPSBcInRyYXNoLWJpbi5zdmdcIlxuICAgICAgICAgICAgZGIub25jbGljayA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpcm0oXCJEZWxldGluZyBcIiArIGVsZW1lbnQuY29uc3RydWN0b3IubmFtZSArIFwiIFxcXCJcIiArIGVsZW1lbnQubmFtZSArIFwiXFxcIlwiKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTbGljZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIucmVtb3ZlU2xpY2UoZWxlbWVudClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIucmVtb3ZlTGF5b3V0RWxlbWVudChlbGVtZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudF9kaXYuYXBwZW5kQ2hpbGQoZGIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIExheW91dCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU2xpY2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnRfZGl2Lm9uY29udGV4dG1lbnUgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFVJLmdldEluc3RhbmNlKCkub3BlbkVsZW1lbnQgPT09IFwiYXNzaWduX3NsaWNlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50ID0gXCJcIlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkub3BlbkVsZW1lbnQgPSBlbGVtZW50LmdldEtleSgpXG5cbiAgICAgICAgICAgICAgICBpZiAoVUkuZ2V0SW5zdGFuY2UoKS5zZWxlY3RlZEVsZW1lbnQgPT09IGVsZW1lbnQuZ2V0S2V5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5zZWxlY3RlZEVsZW1lbnQgPSBcIlwiXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVUkuZ2V0SW5zdGFuY2UoKS5yZWZyZXNoKClcblxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnRfZGl2Lm9uZGJsY2xpY2sgPSBlbGVtZW50X2Rpdi5vbmNvbnRleHRtZW51XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJpb21lICYmIGVsZW1lbnQuYWxsb3dFZGl0KSB7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRfZGl2Lm9uY2xpY2sgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoKFVJLmdldEluc3RhbmNlKCkub3BlbkVsZW1lbnQgPT09IFwiYXNzaWduX3NsaWNlc1wiKSAhPT0gKGVsZW1lbnQgaW5zdGFuY2VvZiBTbGljZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudC5nZXRLZXkoKVxuXG4gICAgICAgICAgICBVSS5nZXRJbnN0YW5jZSgpLnJlZnJlc2goKVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHRoaXMubGF5b3V0X2RpdnMuZm9yRWFjaChkaXYgPT4ge1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwic2VsZWN0ZWRcIiwgZGl2LmdldEF0dHJpYnV0ZShcImtleVwiKSA9PT0gVUkuZ2V0SW5zdGFuY2UoKS5zZWxlY3RlZEVsZW1lbnQpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5iaW9tZV9kaXZzLmZvckVhY2goZGl2ID0+IHtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIGRpdi5nZXRBdHRyaWJ1dGUoXCJrZXlcIikgPT09IFVJLmdldEluc3RhbmNlKCkuc2VsZWN0ZWRFbGVtZW50KVxuICAgICAgICAgICAgfSk7Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRfZGl2Lm9uZHJhZ3N0YXJ0ID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidHlwZVwiLCBjKVxuICAgICAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwia2V5XCIsIGVsZW1lbnQuZ2V0S2V5KCkpXG4gICAgICAgICAgICBlbGVtZW50X2Rpdi5jbGFzc0xpc3QuYWRkKFwiZHJhZ2dlZFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudF9kaXYub25kcmFnZW5kID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LnJlbW92ZShcImRyYWdnZWRcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRfZGl2Lm9uZHJhZ292ZXIgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZ0LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidHlwZVwiKSA9PT0gYyAmJiBldnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJrZXlcIikgIT09IGVsZW1lbnQuZ2V0S2V5KCkpe1xuICAgICAgICAgICAgICAgIHZhciBzZWxmX2lkLCBvdGhlcl9pZFxuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTbGljZSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfaWQgPSB0aGlzLmJ1aWxkZXIuc2xpY2VzLmluZGV4T2YoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfaWQgPSB0aGlzLmJ1aWxkZXIuc2xpY2VzLmZpbmRJbmRleChlID0+IGUuZ2V0S2V5KCkgPT09IGV2dC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBMYXlvdXQpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmX2lkID0gdGhpcy5idWlsZGVyLmxheW91dHMuaW5kZXhPZihlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBvdGhlcl9pZCA9IHRoaXMuYnVpbGRlci5sYXlvdXRzLmZpbmRJbmRleChlID0+IGUuZ2V0S2V5KCkgPT09IGV2dC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCaW9tZSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfaWQgPSB0aGlzLmJ1aWxkZXIuYmlvbWVzLmluZGV4T2YoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfaWQgPSB0aGlzLmJ1aWxkZXIuYmlvbWVzLmZpbmRJbmRleChlID0+IGUuZ2V0S2V5KCkgPT09IGV2dC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZl9pZCA8IG90aGVyX2lkKXtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LmFkZChcImRyYWdvdmVyX3VwXCIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9kaXYuY2xhc3NMaXN0LmFkZChcImRyYWdvdmVyX2Rvd25cIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudF9kaXYub25kcmFnbGVhdmUgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50X2Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZHJhZ292ZXJfdXBcIixcImRyYWdvdmVyX2Rvd25cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRfZGl2Lm9uZHJvcCA9IChldnQpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnRfZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJkcmFnb3Zlcl91cFwiLFwiZHJhZ292ZXJfZG93blwiKVxuXG4gICAgICAgICAgICB2YXIgc2VsZl9pZCwgb3RoZXJfaWRcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTbGljZSl7XG4gICAgICAgICAgICAgICAgc2VsZl9pZCA9IHRoaXMuYnVpbGRlci5zbGljZXMuaW5kZXhPZihlbGVtZW50KVxuICAgICAgICAgICAgICAgIG90aGVyX2lkID0gdGhpcy5idWlsZGVyLnNsaWNlcy5maW5kSW5kZXgoZSA9PiBlLmdldEtleSgpID09PSBldnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLnNsaWNlcy5zcGxpY2Uoc2VsZl9pZCwgMCwgdGhpcy5idWlsZGVyLnNsaWNlcy5zcGxpY2Uob3RoZXJfaWQsIDEpWzBdKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGF5b3V0KXtcbiAgICAgICAgICAgICAgICBzZWxmX2lkID0gdGhpcy5idWlsZGVyLmxheW91dHMuaW5kZXhPZihlbGVtZW50KVxuICAgICAgICAgICAgICAgIG90aGVyX2lkID0gdGhpcy5idWlsZGVyLmxheW91dHMuZmluZEluZGV4KGUgPT4gZS5nZXRLZXkoKSA9PT0gZXZ0LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5sYXlvdXRzLnNwbGljZShzZWxmX2lkLCAwLCB0aGlzLmJ1aWxkZXIubGF5b3V0cy5zcGxpY2Uob3RoZXJfaWQsIDEpWzBdKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmlvbWUpe1xuICAgICAgICAgICAgICAgIHNlbGZfaWQgPSB0aGlzLmJ1aWxkZXIuYmlvbWVzLmluZGV4T2YoZWxlbWVudClcbiAgICAgICAgICAgICAgICBvdGhlcl9pZCA9IHRoaXMuYnVpbGRlci5iaW9tZXMuZmluZEluZGV4KGUgPT4gZS5nZXRLZXkoKSA9PT0gZXZ0LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5iaW9tZXMuc3BsaWNlKHNlbGZfaWQsIDAsIHRoaXMuYnVpbGRlci5iaW9tZXMuc3BsaWNlKG90aGVyX2lkLCAxKVswXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFVJLmdldEluc3RhbmNlKCkucmVmcmVzaCgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpZGViYXIuYXBwZW5kQ2hpbGQoZWxlbWVudF9kaXYpXG4gICAgICAgIHJldHVybiBlbGVtZW50X2RpdlxuICAgIH1cblxufSIsImltcG9ydCB7IENsaW1hdGUsIFRlcnJhaW5TaGFwZXIgfSBmcm9tIFwiZGVlcHNsYXRlXCI7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvQmlvbWVCdWlsZGVyXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgU3BsaW5lRGlzcGxheU1hbmFnZXIge1xuICAgIHByaXZhdGUgYnVpbGRlcjogQmlvbWVCdWlsZGVyXG4gICAgcHJpdmF0ZSBzcGxpbmVDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gICAgcHJpdmF0ZSBwb3M/OiB7IGM6IG51bWJlciwgZTogbnVtYmVyIH1cbiAgICBwcml2YXRlIHdlaXJkbmVzc2VzOiBDbGltYXRlLlBhcmFtW11cblxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IEJpb21lQnVpbGRlcikge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyXG4gICAgICAgIHRoaXMuc3BsaW5lQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGxpbmVEaXNwbGF5Q2FudmFzXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICAgIHRoaXMud2VpcmRuZXNzZXMgPSBbXVxuICAgIH1cblxuXG4gICAgc2V0UG9zKHBvcz86IHsgYzogbnVtYmVyLCBlOiBudW1iZXIgfSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvc1xuICAgIH1cblxuICAgIHNldFdlaXJkbmVzc2VzKHdlaXJkbmVzc2VzOiBDbGltYXRlLlBhcmFtW10pIHtcbiAgICAgICAgdGhpcy53ZWlyZG5lc3NlcyA9IHdlaXJkbmVzc2VzXG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3Qgc3BsaW5lX2N0eCA9IHRoaXMuc3BsaW5lQ2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgY29uc3Qgc2N3ID0gdGhpcy5zcGxpbmVDYW52YXMud2lkdGhcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5zcGxpbmVDYW52YXMuaGVpZ2h0XG5cbiAgICAgICAgc3BsaW5lX2N0eC5jbGVhclJlY3QoMCwgMCwgc2N3LCBzY2gpO1xuXG4gICAgICAgIGlmICh0aGlzLnBvcykge1xuICAgICAgICAgICAgc3BsaW5lX2N0eC5maWxsU3R5bGUgPSBcInJnYig5MiwgMTU0LCAyNTUpXCJcbiAgICAgICAgICAgIHNwbGluZV9jdHguZmlsbFJlY3QoMCwgMC44ICogc2NoLCBzY3csIDAuMiAqIHNjaClcblxuICAgICAgICAgICAgc3BsaW5lX2N0eC5maWxsU3R5bGUgPSBcInJnYig4MCw4MCw4MClcIlxuICAgICAgICAgICAgc3BsaW5lX2N0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgc3BsaW5lX2N0eC5tb3ZlVG8oMCwgc2NoKVxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IC0xOyB3IDwgMTsgdyArPSAwLjEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBUZXJyYWluU2hhcGVyLm9mZnNldChUZXJyYWluU2hhcGVyLnBvaW50KHRoaXMucG9zLmMsIHRoaXMucG9zLmUsIHcpKVxuICAgICAgICAgICAgICAgIHNwbGluZV9jdHgubGluZVRvKCh3ICsgMSkgKiAwLjUgKiBzY3csIC1vZmZzZXQgKiAwLjc1ICogc2NoICsgMC44ICogc2NoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaW5lX2N0eC5saW5lVG8oc2N3LCBzY2gpXG4gICAgICAgICAgICBzcGxpbmVfY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICBzcGxpbmVfY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2IoMjU1LDAsMClcIlxuICAgICAgICAgICAgc3BsaW5lX2N0eC5zZXRMaW5lRGFzaChbNSwgNV0pXG4gICAgICAgICAgICBzcGxpbmVfY3R4LmxpbmVXaWR0aCA9IDNcbiAgICAgICAgICAgIHNwbGluZV9jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGZvciAobGV0IHcgPSAtMTsgdyA8IDE7IHcgKz0gMC4xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gVGVycmFpblNoYXBlci5mYWN0b3IoVGVycmFpblNoYXBlci5wb2ludCh0aGlzLnBvcy5jLCB0aGlzLnBvcy5lLCB3KSlcbiAgICAgICAgICAgICAgICBzcGxpbmVfY3R4LmxpbmVUbygodyArIDEpICogMC41ICogc2N3LCAtKDEgLyBmYWN0b3IpICogNTAgKiBzY2ggKyBzY2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGxpbmVfY3R4LnN0cm9rZSgpXG5cbiAgICAgICAgICAgIHNwbGluZV9jdHguc3Ryb2tlU3R5bGUgPSBcInJnYigwLDAsMjU1KVwiXG4gICAgICAgICAgICBzcGxpbmVfY3R4LnNldExpbmVEYXNoKFs1LCA1XSlcbiAgICAgICAgICAgIHNwbGluZV9jdHgubGluZVdpZHRoID0gM1xuICAgICAgICAgICAgc3BsaW5lX2N0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IC0xOyB3IDwgMTsgdyArPSAwLjEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZWFrcyA9IFRlcnJhaW5TaGFwZXIucGVha3MoVGVycmFpblNoYXBlci5wb2ludCh0aGlzLnBvcy5jLCB0aGlzLnBvcy5lLCB3KSlcbiAgICAgICAgICAgICAgICBzcGxpbmVfY3R4LmxpbmVUbygodyArIDEpICogMC41ICogc2N3LCAtcGVha3MgLyAxMDAgKiBzY2ggKyBzY2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGxpbmVfY3R4LnN0cm9rZSgpXG4gICAgICAgIH1cblxuXG4gICAgICAgIHNwbGluZV9jdHguZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwyNTUsMCwwLjIpXCJcbiAgICAgICAgc3BsaW5lX2N0eC5zdHJva2VTdHlsZSA9IFwieWVsbG93XCJcbiAgICAgICAgc3BsaW5lX2N0eC5zZXRMaW5lRGFzaChbNSwgNV0pXG4gICAgICAgIHNwbGluZV9jdHgubGluZVdpZHRoID0gMVxuXG4gICAgICAgIHRoaXMud2VpcmRuZXNzZXMuZm9yRWFjaCh3ZWlyZG5lc3MgPT4ge1xuICAgICAgICAgICAgICAgIHNwbGluZV9jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBzcGxpbmVfY3R4LnJlY3QoKHdlaXJkbmVzcy5taW4gKyAxKSAqIDAuNSAqIHNjdywgLTIsICh3ZWlyZG5lc3MubWF4IC0gd2VpcmRuZXNzLm1pbikgKiAwLjUgKiBzY3csIHNjaCArIDQpXG4gICAgICAgICAgICAgICAgc3BsaW5lX2N0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIHNwbGluZV9jdHguZmlsbCgpXG4gICAgICAgIH0pXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0Jpb21lQnVpbGRlclwiO1xuaW1wb3J0IHsgQXNzaWduU2xpY2VzTWFuYWdlciB9IGZyb20gXCIuL0Fzc2lnblNsaWNlc01hbmFnZXJcIjtcbmltcG9ydCB7IExheW91dEVkaXRvciB9IGZyb20gXCIuL0xheW91dEVkaXRvclwiO1xuaW1wb3J0IHsgTWVudU1hbmFnZXIgfSBmcm9tIFwiLi9NZW51TWFuYWdlclwiO1xuaW1wb3J0IHsgU2lkZWJhck1hbmFnZXIgfSBmcm9tIFwiLi9TaWRlYmFyTWFuYWdlclwiO1xuaW1wb3J0IHsgU3BsaW5lRGlzcGxheU1hbmFnZXIgfSBmcm9tIFwiLi9TcGxpbmVEaXNwbGF5TWFuYWdlclwiO1xuXG5cblxuZXhwb3J0IGNsYXNzIFVJe1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBVSSA9IHVuZGVmaW5lZFxuXG4gICAgc3RhdGljIGNyZWF0ZShidWlsZGVyOiBCaW9tZUJ1aWxkZXIpe1xuICAgICAgICBpZiAoVUkuaW5zdGFuY2UgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVJIGluc3RhbmNlIGFscmVhZHkgZXhpc3RzXCIpXG4gICAgICAgIG5ldyBVSShidWlsZGVyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKXtcbiAgICAgICAgcmV0dXJuIFVJLmluc3RhbmNlO1xuICAgIH1cblxuICAgIHJlYWRvbmx5IHNpZGViYXJNYW5hZ2VyOiBTaWRlYmFyTWFuYWdlclxuICAgIHJlYWRvbmx5IGxheW91dEVkaXRvcjogTGF5b3V0RWRpdG9yXG4gICAgcmVhZG9ubHkgYXNzaWduU2xpY2VzRWRpdG9yOiBBc3NpZ25TbGljZXNNYW5hZ2VyXG4gICAgcmVhZG9ubHkgc3BsaW5lRGlzcGxheU1hbmFnZXI6IFNwbGluZURpc3BsYXlNYW5hZ2VyXG5cbiAgICByZWFkb25seSBidWlsZGVyOiBCaW9tZUJ1aWxkZXJcblxuICAgIHB1YmxpYyBzZWxlY3RlZEVsZW1lbnQ6IHN0cmluZyA9IFwiXCJcbiAgICBwdWJsaWMgb3BlbkVsZW1lbnQ6IHN0cmluZ1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihidWlsZGVyOiBCaW9tZUJ1aWxkZXIpe1xuICAgICAgICBVSS5pbnN0YW5jZSA9IHRoaXNcblxuICAgICAgICB0aGlzLm9wZW5FbGVtZW50ID0gXCJhc3NpZ25fc2xpY2VzXCJcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlclxuXG4gICAgICAgIHRoaXMubGF5b3V0RWRpdG9yID0gbmV3IExheW91dEVkaXRvcihidWlsZGVyKVxuICAgICAgICB0aGlzLnNpZGViYXJNYW5hZ2VyID0gbmV3IFNpZGViYXJNYW5hZ2VyKGJ1aWxkZXIpXG4gICAgICAgIHRoaXMuYXNzaWduU2xpY2VzRWRpdG9yID0gbmV3IEFzc2lnblNsaWNlc01hbmFnZXIoYnVpbGRlcilcbiAgICAgICAgdGhpcy5zcGxpbmVEaXNwbGF5TWFuYWdlciA9IG5ldyBTcGxpbmVEaXNwbGF5TWFuYWdlcihidWlsZGVyKVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpXG5cbiAgICAgICAgTWVudU1hbmFnZXIuY3JlYXRlQ2xpY2tIYW5kbGVycygpXG4gICAgfVxuXG4gICAgcmVmcmVzaCgpe1xuICAgICAgICB0aGlzLnNpZGViYXJNYW5hZ2VyLnJlZnJlc2goKVxuXG4gICAgICAgIGlmICh0aGlzLm9wZW5FbGVtZW50ID09PSBcImFzc2lnbl9zbGljZXNcIil7XG4gICAgICAgICAgICB0aGlzLmxheW91dEVkaXRvci5oaWRlKClcbiAgICAgICAgICAgIHRoaXMuYXNzaWduU2xpY2VzRWRpdG9yLnJlZnJlc2goKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ25TbGljZXNFZGl0b3IuaGlkZSgpXG4gICAgICAgICAgICB0aGlzLmxheW91dEVkaXRvci5yZWZyZXNoKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3BsaW5lRGlzcGxheU1hbmFnZXIucmVmcmVzaCgpXG4gICAgfVxufSIsImltcG9ydCB7IEJpb21lIH0gZnJvbSBcIi4uL0J1aWxkZXJEYXRhL0Jpb21lXCI7XG5pbXBvcnQgeyBCaW9tZUJ1aWxkZXIgfSBmcm9tIFwiLi4vQnVpbGRlckRhdGEvQmlvbWVCdWlsZGVyXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgVmFuaWxsYUJpb21lc3tcbiAgICBwcml2YXRlIHN0YXRpYyBiaW9tZXMgPSBbXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpvY2VhblwiLCByOiA1MCwgZzogNTAsIGI6IDI1NX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpwbGFpbnNcIiwgcjogNjEsIGc6IDE5NiwgYjogMTJ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZGVzZXJ0XCIsIHI6IDI0NywgZzogMjM3LCBiOiA0MH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpleHRyZW1lX2hpbGxzXCIsIHI6IDY2LCBnOiA2NiwgYjogNjZ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6Zm9yZXN0XCIsIHI6IDIxLCBnOiAxMDcsIGI6IDIzfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnRhaWdhXCIsIHI6IDEwNSwgZzogNjksIGI6IDE5fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnN3YW1wXCIsIHI6IDYwLCBnOiAxMzAsIGI6IDk2fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnJpdmVyXCIsIHI6IDUzLCBnOiAxMTYsIGI6IDIzMn0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpuZXRoZXJfd2FzdGVzXCIsIHI6IDE2MywgZzogNjIsIGI6IDYyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnRoZV9lbmRcIiwgcjogMjUyLCBnOiAyNDQsIGI6IDEyMX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpmcm96ZW5fb2NlYW5cIiwgcjogMjA5LCBnOiAyMzcsIGI6IDI1NX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpmcm96ZW5fcml2ZXJcIiwgcjogMTY2LCBnOiAyMTIsIGI6IDI1NX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpzbm93eV90dW5kcmFcIiwgcjogMjM5LCBnOiAyNTUsIGI6IDIzNX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpzbm93eV9tb3VudGFpbnNcIiwgcjogMjM5LCBnOiAyNTUsIGI6IDIzNX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDptdXNocm9vbV9maWVsZHNcIiwgcjogMjUwLCBnOiAxNDUsIGI6IDI0OH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDptdXNocm9vbV9maWVsZF9zaG9yZVwiLCByOiAyNDAsIGc6IDE4NywgYjogMjUyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmJlYWNoXCIsIHI6IDI1NSwgZzogMjQ5LCBiOiAxMzh9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZGVzZXJ0X2hpbGxzXCIsIHI6IDE4MSwgZzogMTc0LCBiOiAzM30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp3b29kZWRfaGlsbHNcIiwgcjogMTcsIGc6IDY5LCBiOiAxOH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp0YWlnYV9oaWxsc1wiLCByOiAzMCwgZzogNjksIGI6IDh9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6bW91bnRhaW5fZWRnZVwiLCByOiAxMTAsIGc6IDEwOSwgYjogMTA5fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Omp1bmdsZVwiLCByOiA0NSwgZzogMjI3LCBiOiA1fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Omp1bmdsZV9oaWxsc1wiLCByOiAzMywgZzogMTg0LCBiOiAwfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Omp1bmdsZV9lZGdlXCIsIHI6IDY2LCBnOiAyMDcsIGI6IDM1fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmRlZXBfb2NlYW5cIiwgcjogNSwgZzogMTAsIGI6IDgyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnN0b25lX3Nob3JlXCIsIHI6IDE2NiwgZzogMTY2LCBiOiAxNjZ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6c25vd3lfYmVhY2hcIiwgcjogMjExLCBnOiAyMTIsIGI6IDE5M30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpiaXJjaF9mb3Jlc3RcIiwgcjogMzEsIGc6IDE0NSwgYjogMzN9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6YmlyY2hfZm9yZXN0X2hpbGxzXCIsIHI6IDI4LCBnOiA5NywgYjogMjl9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZGFya19mb3Jlc3RcIiwgcjogNywgZzogNDYsIGI6IDd9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6c25vd3lfdGFpZ2FcIiwgcjogMTc5LCBnOiAyMDcsIGI6IDE2M30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpzbm93eV90YWlnYV9oaWxsc1wiLCByOiAxMDMsIGc6IDExNywgYjogOTV9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6Z2lhbnRfdHJlZV90YWlnYVwiLCByOiA0NiwgZzogMjMsIGI6IDZ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6Z2lhbnRfdHJlZV90YWlnYV9oaWxsc1wiLCByOiAyMywgZzogMTUsIGI6IDN9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6d29vZGVkX21vdW50YWluc1wiLCByOiAzNywgZzogNjQsIGI6IDM2fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnNhdmFubmFcIiwgcjogMTc5LCBnOiAyNDIsIGI6IDYxfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnNhdmFubmFfcGxhdGVhdVwiLCByOiAxMzIsIGc6IDE4MSwgYjogNDB9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6YmFkbGFuZHNcIiwgcjogMjEyLCBnOiA4MiwgYjogNDJ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6d29vZGVkX2JhZGxhbmRzX3BsYXRlYXVcIiwgcjogMjMwLCBnOiAxNzEsIGI6IDYyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmJhZGxhbmRzX3BsYXRlYXVcIiwgcjogMTIwLCBnOiA4MywgYjogNDJ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6c21hbGxfZW5kX2lzbGFuZHNcIiwgcjogMjM0LCBnOiAyNDcsIGI6IDUyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmVuZF9taWRsYW5kc1wiLCByOiAxNzAsIGc6IDE3OSwgYjogNTV9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZW5kX2hpZ2hsYW5kc1wiLCByOiAxMTIsIGc6IDExNywgYjogNDZ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZW5kX2JhcnJlbnNcIiwgcjogMTk5LCBnOiAyMDQsIGI6IDEzN30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp3YXJtX29jZWFuXCIsIHI6IDk1LCBnOiA3MCwgYjogMjI0fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Omx1a2V3YXJtX29jZWFuXCIsIHI6IDgwLCBnOiA0MCwgYjogMjEyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmNvbGRfb2NlYW5cIiwgcjogMTIwLCBnOiAxODgsIGI6IDIyMn0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpkZWVwX3dhcm1fb2NlYW5cIiwgcjogNjQsIGc6IDU0LCBiOiA5OX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpkZWVwX2x1a2V3YXJtX29jZWFuXCIsIHI6IDQ5LCBnOiAzNSwgYjogODd9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6ZGVlcF9jb2xkX29jZWFuXCIsIHI6IDU5LCBnOiA4NCwgYjogMTAyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmRlZXBfZnJvemVuX29jZWFuXCIsIHI6IDExNiwgZzogMTMzLCBiOiAxNDV9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6dGhlX3ZvaWRcIiwgcjogMCwgZzogMCwgYjogMH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpzdW5mbG93ZXJfcGxhaW5zXCIsIHI6IDE5OCwgZzogMjU1LCBiOiA5Mn0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpkZXNlcnRfbGFrZXNcIiwgcjogOTcsIGc6IDE3OSwgYjogMTg2fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmdyYXZlbGx5X2hpbGxzXCIsIHI6IDg1LCBnOiAxMDEsIGI6IDEwMn0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpmbG93ZXJfZm9yZXN0XCIsIHI6IDE3MiwgZzogMjUyLCBiOiAzM30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp0YWlnYV9tb3VudGFpbnNcIiwgcjogNDYsIGc6IDMwLCBiOiA4fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnN3YW1wX2hpbGxzXCIsIHI6IDMyLCBnOiA2NiwgYjogNTB9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6aWNlX3NwaWtlc1wiLCByOiAxOTQsIGc6IDIzNywgYjogMjU1fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Om1vZGlmaWVkX2p1bmdsZVwiLCByOiAxMSwgZzogMjI3LCBiOiAzN30sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDptb2RpZmllZF9qdW5nbGVfZWRnZVwiLCByOiA3MSwgZzogMjM3LCBiOiA5MX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp0YWxsX2JpcmNoX2ZvcmVzdFwiLCByOiAzMSwgZzogMTczLCBiOiAzNH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDp0YWxsX2JpcmNoX2hpbGxzXCIsIHI6IDQsIGc6IDc0LCBiOiA2fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmRhcmtfZm9yZXN0X2hpbGxzXCIsIHI6IDAsIGc6IDMxLCBiOiAxfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnNub3d5X3RhaWdhX21vdW50YWluc1wiLCByOiA3NCwgZzogOTksIGI6IDc0fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmdpYW50X3NwcnVjZV90YWlnYVwiLCByOiAyNSwgZzogNjEsIGI6IDE1fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmdpYW50X3NwcnVjZV90YWlnYV9oaWxsc1wiLCByOiAxMywgZzogMzYsIGI6IDd9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6bW9kaWZpZWRfZ3JhdmVsbHlfbW91bnRhaW5zXCIsIHI6IDgyLCBnOiA4OSwgYjogOTl9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6c2hhdHRlcmVkX3NhdmFubmFcIiwgcjogMTcxLCBnOiAyMTksIGI6IDgxfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnNoYXR0ZXJlZF9zYXZhbm5hX3BsYXRlYXVcIiwgcjogMTI0LCBnOiAxNTgsIGI6IDYwfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmVyb2RlZF9iYWRsYW5kc1wiLCByOiAxMTAsIGc6IDQ0LCBiOiAyNH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDptb2RpZmllZF93b29kZWRfYmFkbGFuZHNfcGxhdGVhdVwiLCByOiAxMjgsIGc6IDk4LCBiOiA1NH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDptb2RpZmllZF9iYWRsYW5kc19wbGF0ZWF1XCIsIHI6IDE0NSwgZzogMTAxLCBiOiA2MDB9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6YmFtYm9vX2p1bmdsZVwiLCByOiAxNTgsIGc6IDIyNCwgYjogODN9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6YmFtYm9vX2p1bmdsZV9oaWxsc1wiLCByOiA5OCwgZzogMTQwLCBiOiA0OX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpzb3VsX3NhbmRfdmFsbGV5XCIsIHI6IDE0MCwgZzogMTMyLCBiOiAxMDh9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6Y3JpbXNvbl9mb3Jlc3RcIiwgcjogNjgsIGc6IDE3MSwgYjogMTcxfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OndhcnBlZF9mb3Jlc3RcIiwgcjogMjE5LCBnOiA2MCwgYjogNDZ9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6YmFzYWx0X2RlbHRhc1wiLCByOiA3OSwgZzogNzMsIGI6IDY2fSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnNub3d5X3Nsb3Blc1wiLCByOiAxNDAsIGc6IDE5NSwgYjogMjIyfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OmxvZnR5X3BlYWtzXCIsIHI6IDE5NiwgZzogMTY4LCBiOiAxOTN9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6c25vd2NhcHBlZF9wZWFrc1wiLCByOiAyMDAsIGc6IDE5OCwgYjogMjAwfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0OnN0b255X3BlYWtzXCIsIHI6IDgyLCBnOiA5MiwgYjogMTAzfSxcbiAgICAgICAge25hbWU6IFwibWluZWNyYWZ0Omdyb3ZlXCIsIHI6IDE1MCwgZzogMTUwLCBiOiAxODl9LFxuICAgICAgICB7bmFtZTogXCJtaW5lY3JhZnQ6bWVhZG93XCIsIHI6IDE2OSwgZzogMTk3LCBiOiA4MH0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpsdXNoX2NhdmVzXCIsIHI6IDExMiwgZzogMjU1LCBiOiA3OX0sXG4gICAgICAgIHtuYW1lOiBcIm1pbmVjcmFmdDpkcmlwc3RvbmVfY2F2ZXNcIiwgcjogMTQwLCBnOiAxMjQsIGI6IDB9XG4gICAgXVxuXG4gICAgc3RhdGljIHJlZ2lzdGVyVmFuaWxsYUJpb21lcyhidWlsZGVyOiBCaW9tZUJ1aWxkZXIpe1xuICAgICAgICBmb3IgKGxldCBiaW9tZSBvZiBWYW5pbGxhQmlvbWVzLmJpb21lcykge1xuICAgICAgICAgICAgQmlvbWUuY3JlYXRlKGJ1aWxkZXIsIGJpb21lLm5hbWUsIHRoaXMuY29sb3JUb0hleChiaW9tZS5yLCBiaW9tZS5nLCBiaW9tZS5iKSwgdW5kZWZpbmVkLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb2xvclRvSGV4KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpe1xuICAgICAgICByZXR1cm4gJyMnICsgKHIgPDwgMTYgfCBnIDw8IDggfCBiKS50b1N0cmluZygxNikucGFkU3RhcnQoNiwgXCIwXCIpXG4gICAgfVxuXG59IiwiLyogXG4oVGhlIE1JVCBMaWNlbnNlKVxuQ29weXJpZ2h0IChjKSAyMDE0LTIwMjEgSGFsw6FzeiDDgWTDoW0gPGFkYW1AYWltZm9ybS5jb20+XG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vICBVbmlxdWUgSGV4YXRyaWRlY2ltYWwgSUQgR2VuZXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gIERlcGVuZGVuY2llc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgcGlkID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MucGlkID8gcHJvY2Vzcy5waWQudG9TdHJpbmcoMzYpIDogJycgO1xudmFyIGFkZHJlc3MgPSAnJztcbmlmKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyl7XG4gICAgdmFyIG1hYyA9ICcnLCBvcyA9IHJlcXVpcmUoJ29zJyk7IFxuICAgIGlmKG9zLm5ldHdvcmtJbnRlcmZhY2VzKSB2YXIgbmV0d29ya0ludGVyZmFjZXMgPSBvcy5uZXR3b3JrSW50ZXJmYWNlcygpO1xuICAgIGlmKG5ldHdvcmtJbnRlcmZhY2VzKXtcbiAgICAgICAgbG9vcDpcbiAgICAgICAgZm9yKGxldCBpbnRlcmZhY2Vfa2V5IGluIG5ldHdvcmtJbnRlcmZhY2VzKXtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtJbnRlcmZhY2UgPSBuZXR3b3JrSW50ZXJmYWNlc1tpbnRlcmZhY2Vfa2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG5ldHdvcmtJbnRlcmZhY2UubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZihuZXR3b3JrSW50ZXJmYWNlW2ldICE9PSB1bmRlZmluZWQgJiYgbmV0d29ya0ludGVyZmFjZVtpXS5tYWMgJiYgbmV0d29ya0ludGVyZmFjZVtpXS5tYWMgIT0gJzAwOjAwOjAwOjAwOjAwOjAwJyl7XG4gICAgICAgICAgICAgICAgICAgIG1hYyA9IG5ldHdvcmtJbnRlcmZhY2VbaV0ubWFjOyBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gbWFjID8gcGFyc2VJbnQobWFjLnJlcGxhY2UoL1xcOnxcXEQrL2dpLCAnJykpLnRvU3RyaW5nKDM2KSA6ICcnIDtcbiAgICB9XG59IFxuXG4vLyAgRXhwb3J0c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbihwcmVmaXgsIHN1ZmZpeCl7IHJldHVybiAocHJlZml4ID8gcHJlZml4IDogJycpICsgYWRkcmVzcyArIHBpZCArIG5vdygpLnRvU3RyaW5nKDM2KSArIChzdWZmaXggPyBzdWZmaXggOiAnJyk7IH1cbm1vZHVsZS5leHBvcnRzLnByb2Nlc3MgPSBmdW5jdGlvbihwcmVmaXgsIHN1ZmZpeCl7IHJldHVybiAocHJlZml4ID8gcHJlZml4IDogJycpICsgcGlkICsgbm93KCkudG9TdHJpbmcoMzYpICsgKHN1ZmZpeCA/IHN1ZmZpeCA6ICcnKTsgfVxubW9kdWxlLmV4cG9ydHMudGltZSAgICA9IGZ1bmN0aW9uKHByZWZpeCwgc3VmZml4KXsgcmV0dXJuIChwcmVmaXggPyBwcmVmaXggOiAnJykgKyBub3coKS50b1N0cmluZygzNikgKyAoc3VmZml4ID8gc3VmZml4IDogJycpOyB9XG5cbi8vICBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIG5vdygpe1xuICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbGFzdCA9IG5vdy5sYXN0IHx8IHRpbWU7XG4gICAgcmV0dXJuIG5vdy5sYXN0ID0gdGltZSA+IGxhc3QgPyB0aW1lIDogbGFzdCArIDE7XG59XG4iLCJcbi8qISBwYWtvIDIuMC40IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrbyBAbGljZW5zZSAoTUlUIEFORCBabGliKSAqL1xuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy9jb25zdCBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL2NvbnN0IFpfUkxFICAgICAgICAgICAgICAgPSAzO1xuY29uc3QgWl9GSVhFRCQxICAgICAgICAgICAgICAgPSA0O1xuLy9jb25zdCBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuY29uc3QgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbmNvbnN0IFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxuY29uc3QgWl9VTktOT1dOJDEgICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8kMShidWYpIHsgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG5jb25zdCBTVE9SRURfQkxPQ0sgPSAwO1xuY29uc3QgU1RBVElDX1RSRUVTID0gMTtcbmNvbnN0IERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG5jb25zdCBNSU5fTUFUQ0gkMSAgICA9IDM7XG5jb25zdCBNQVhfTUFUQ0gkMSAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxuY29uc3QgTEVOR1RIX0NPREVTJDEgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgTElURVJBTFMkMSAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbmNvbnN0IExfQ09ERVMkMSAgICAgICA9IExJVEVSQUxTJDEgKyAxICsgTEVOR1RIX0NPREVTJDE7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgRF9DT0RFUyQxICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxuY29uc3QgQkxfQ09ERVMkMSAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxuY29uc3QgSEVBUF9TSVpFJDEgICAgID0gMiAqIExfQ09ERVMkMSArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG5jb25zdCBNQVhfQklUUyQxICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbmNvbnN0IEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG5jb25zdCBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuY29uc3QgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0pO1xuXG5jb25zdCBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSk7XG5cbmNvbnN0IGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10pO1xuXG5jb25zdCBibF9vcmRlciA9XG4gIG5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSk7XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG5jb25zdCBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbmNvbnN0IHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMkMSArIDIpICogMik7XG56ZXJvJDEoc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxuY29uc3Qgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTJDEgKiAyKTtcbnplcm8kMShzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG5jb25zdCBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyQxKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxuY29uc3QgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0gkMSAtIE1JTl9NQVRDSCQxICsgMSk7XG56ZXJvJDEoX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMkMSk7XG56ZXJvJDEoYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTJDEpO1xuemVybyQxKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG5sZXQgc3RhdGljX2xfZGVzYztcbmxldCBzdGF0aWNfZF9kZXNjO1xubGV0IHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmNvbnN0IGRfY29kZSA9IChkaXN0KSA9PiB7XG5cbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5jb25zdCBwdXRfc2hvcnQgPSAocywgdykgPT4ge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5jb25zdCBzZW5kX2JpdHMgPSAocywgdmFsdWUsIGxlbmd0aCkgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn07XG5cblxuY29uc3Qgc2VuZF9jb2RlID0gKHMsIGMsIHRyZWUpID0+IHtcblxuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5jb25zdCBiaV9yZXZlcnNlID0gKGNvZGUsIGxlbikgPT4ge1xuXG4gIGxldCByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuY29uc3QgYmlfZmx1c2ggPSAocykgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5jb25zdCBnZW5fYml0bGVuID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIGNvbnN0IHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIGNvbnN0IGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIGNvbnN0IG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIGxldCBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICBsZXQgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgbGV0IHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIGxldCBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIGxldCBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFJDE7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5jb25zdCBnZW5fY29kZXMgPSAodHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSA9PlxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICBjb25zdCBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICBsZXQgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBsZXQgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuY29uc3QgdHJfc3RhdGljX2luaXQgPSAoKSA9PiB7XG5cbiAgbGV0IG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICBsZXQgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICBsZXQgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICBjb25zdCBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyQxICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTJDEgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVMkMTsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyQxICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUyQxOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyQxICsgMSwgTF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTJDEsIE1BWF9CSVRTJDEpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUyQxLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5jb25zdCBpbml0X2Jsb2NrID0gKHMpID0+IHtcblxuICBsZXQgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTJDE7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUyQxOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTJDE7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmNvbnN0IGJpX3dpbmR1cCA9IChzKSA9Plxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5jb25zdCBjb3B5X2Jsb2NrID0gKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICBzLnBlbmRpbmdfYnVmLnNldChzLndpbmRvdy5zdWJhcnJheShidWYsIGJ1ZiArIGxlbiksIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuY29uc3Qgc21hbGxlciA9ICh0cmVlLCBuLCBtLCBkZXB0aCkgPT4ge1xuXG4gIGNvbnN0IF9uMiA9IG4gKiAyO1xuICBjb25zdCBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmNvbnN0IHBxZG93bmhlYXAgPSAocywgdHJlZSwgaykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgY29uc3QgdiA9IHMuaGVhcFtrXTtcbiAgbGV0IGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufTtcblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyBjb25zdCBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmNvbnN0IGNvbXByZXNzX2Jsb2NrID0gKHMsIGx0cmVlLCBkdHJlZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICBsZXQgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIGxldCBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICBsZXQgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgbGV0IGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMkMSArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3Qgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICBsZXQgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgbGV0IG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICBsZXQgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRSQxO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuY29uc3Qgc2Nhbl90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmNvbnN0IHNlbmRfdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmNvbnN0IGJ1aWxkX2JsX3RyZWUgPSAocykgPT4ge1xuXG4gIGxldCBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyQxIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuY29uc3Qgc2VuZF9hbGxfdHJlZXMgPSAocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICBsZXQgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5jb25zdCBkZXRlY3RfZGF0YV90eXBlID0gKHMpID0+IHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICBsZXQgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIGxldCBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTJDE7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn07XG5cblxubGV0IHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmNvbnN0IF90cl9pbml0JDEgPSAocykgPT5cbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5jb25zdCBfdHJfc3RvcmVkX2Jsb2NrJDEgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuY29uc3QgX3RyX2FsaWduJDEgPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuY29uc3QgX3RyX2ZsdXNoX2Jsb2NrJDEgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgbGV0IG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOJDEpIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrJDEocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQkMSB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmNvbnN0IF90cl90YWxseSQxID0gKHMsIGRpc3QsIGxjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vbGV0IG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMkMSArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59O1xuXG52YXIgX3RyX2luaXRfMSAgPSBfdHJfaW5pdCQxO1xudmFyIF90cl9zdG9yZWRfYmxvY2tfMSA9IF90cl9zdG9yZWRfYmxvY2skMTtcbnZhciBfdHJfZmx1c2hfYmxvY2tfMSAgPSBfdHJfZmx1c2hfYmxvY2skMTtcbnZhciBfdHJfdGFsbHlfMSA9IF90cl90YWxseSQxO1xudmFyIF90cl9hbGlnbl8xID0gX3RyX2FsaWduJDE7XG5cbnZhciB0cmVlcyA9IHtcblx0X3RyX2luaXQ6IF90cl9pbml0XzEsXG5cdF90cl9zdG9yZWRfYmxvY2s6IF90cl9zdG9yZWRfYmxvY2tfMSxcblx0X3RyX2ZsdXNoX2Jsb2NrOiBfdHJfZmx1c2hfYmxvY2tfMSxcblx0X3RyX3RhbGx5OiBfdHJfdGFsbHlfMSxcblx0X3RyX2FsaWduOiBfdHJfYWxpZ25fMVxufTtcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiA9IChhZGxlciwgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBsZXQgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufTtcblxuXG52YXIgYWRsZXIzMl8xID0gYWRsZXIzMjtcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5jb25zdCBtYWtlVGFibGUgPSAoKSA9PiB7XG4gIGxldCBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTtcblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KG1ha2VUYWJsZSgpKTtcblxuXG5jb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgY29uc3QgdCA9IGNyY1RhYmxlO1xuICBjb25zdCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59O1xuXG5cbnZhciBjcmMzMl8xID0gY3JjMzI7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIG1lc3NhZ2VzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgY29uc3RhbnRzJDIgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQsIF90cl9zdG9yZWRfYmxvY2ssIF90cl9mbHVzaF9ibG9jaywgX3RyX3RhbGx5LCBfdHJfYWxpZ24gfSA9IHRyZWVzO1xuXG5cblxuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDIsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDMsIFpfQkxPQ0s6IFpfQkxPQ0skMSxcbiAgWl9PSzogWl9PSyQzLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQzLCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMiwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMiwgWl9CVUZfRVJST1I6IFpfQlVGX0VSUk9SJDEsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogWl9ERUZBVUxUX0NPTVBSRVNTSU9OJDEsXG4gIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRCwgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSxcbiAgWl9VTktOT1dOLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDJcbn0gPSBjb25zdGFudHMkMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xuY29uc3QgTUFYX1dCSVRTJDEgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggPSAzO1xuY29uc3QgTUFYX01BVENIID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxuY29uc3QgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG5jb25zdCBJTklUX1NUQVRFID0gNDI7XG5jb25zdCBFWFRSQV9TVEFURSA9IDY5O1xuY29uc3QgTkFNRV9TVEFURSA9IDczO1xuY29uc3QgQ09NTUVOVF9TVEFURSA9IDkxO1xuY29uc3QgSENSQ19TVEFURSA9IDEwMztcbmNvbnN0IEJVU1lfU1RBVEUgPSAxMTM7XG5jb25zdCBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbmNvbnN0IEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG5jb25zdCBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xuY29uc3QgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xuY29uc3QgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbmNvbnN0IE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5jb25zdCBlcnIgPSAoc3RybSwgZXJyb3JDb2RlKSA9PiB7XG4gIHN0cm0ubXNnID0gbWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn07XG5cbmNvbnN0IHJhbmsgPSAoZikgPT4ge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufTtcblxuY29uc3QgemVybyA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5sZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzaztcbi8vIFRoaXMgaGFzaCBjYXVzZXMgbGVzcyBjb2xsaXNpb25zLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vaXNzdWVzLzEzNVxuLy8gQnV0IGJyZWFrcyBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7XG5sZXQgSEFTSCA9IEhBU0hfWkxJQjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuY29uc3QgZmx1c2hfcGVuZGluZyA9IChzdHJtKSA9PiB7XG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIGxldCBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgc3RybS5vdXRwdXQuc2V0KHMucGVuZGluZ19idWYuc3ViYXJyYXkocy5wZW5kaW5nX291dCwgcy5wZW5kaW5nX291dCArIGxlbiksIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufTtcblxuXG5jb25zdCBwdXRfYnl0ZSA9IChzLCBiKSA9PiB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBwdXRTaG9ydE1TQiA9IChzLCBiKSA9PiB7XG5cbiAgLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmNvbnN0IHJlYWRfYnVmID0gKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpID0+IHtcblxuICBsZXQgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgYnVmLnNldChzdHJtLmlucHV0LnN1YmFycmF5KHN0cm0ubmV4dF9pbiwgc3RybS5uZXh0X2luICsgbGVuKSwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuY29uc3QgbG9uZ2VzdF9tYXRjaCA9IChzLCBjdXJfbWF0Y2gpID0+IHtcblxuICBsZXQgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICBsZXQgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIGxldCBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgbGV0IGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICBsZXQgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICBjb25zdCBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICBjb25zdCB3bWFzayA9IHMud19tYXNrO1xuICBjb25zdCBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICBjb25zdCBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICBsZXQgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5jb25zdCBmaWxsX3dpbmRvdyA9IChzKSA9PiB7XG5cbiAgY29uc3QgX3dfc2l6ZSA9IHMud19zaXplO1xuICBsZXQgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkoX3dfc2l6ZSwgX3dfc2l6ZSArIF93X3NpemUpLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyAxXSk7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgY29uc3QgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIGxldCBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zdG9yZWQgPSAocywgZmx1c2gpID0+IHtcblxuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIGxldCBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICBjb25zdCBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gkMykge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zbG93ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBsZXQgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgbGV0IHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICBsZXQgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuXG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG5jb25zdCBjb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmNvbnN0IGxtX2luaXQgPSAocykgPT4ge1xuXG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59O1xuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRCQyOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0gkMjtcbiAgX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LJDM7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgY29uc3QgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSyQzKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LJDM7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG4gIGxldCB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQkMiB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIGNvbnN0IHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyBVaW50MTZBcnJheShzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyBVaW50MTZBcnJheShzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59O1xuXG5jb25zdCBkZWZsYXRlSW5pdCA9IChzdHJtLCBsZXZlbCkgPT4ge1xuXG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQkMiwgTUFYX1dCSVRTJDEsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSQxKTtcbn07XG5cblxuY29uc3QgZGVmbGF0ZSQyID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyQxIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpIDogWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIJDMpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IkMSA6IFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIGNvbnN0IG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIGxldCBoZWFkZXIgPSAoWl9ERUZMQVRFRCQyICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgbGV0IGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gkMykge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQxKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIJDIgJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICBsZXQgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLJDEpIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCQxKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIJDMpIHsgcmV0dXJuIFpfT0skMzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORCQzOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0skMyA6IFpfU1RSRUFNX0VORCQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SJDIpIDogWl9PSyQzO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmNvbnN0IGRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcblxuICBsZXQgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgY29uc3Qgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyXzEoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICBsZXQgdG1wRGljdCA9IG5ldyBVaW50OEFycmF5KHMud19zaXplKTtcbiAgICB0bXBEaWN0LnNldChkaWN0aW9uYXJ5LnN1YmFycmF5KGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgZGljdExlbmd0aCksIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBjb25zdCBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIGNvbnN0IG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGNvbnN0IGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIGxldCBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIGxldCBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LJDM7XG59O1xuXG5cbnZhciBkZWZsYXRlSW5pdF8xID0gZGVmbGF0ZUluaXQ7XG52YXIgZGVmbGF0ZUluaXQyXzEgPSBkZWZsYXRlSW5pdDI7XG52YXIgZGVmbGF0ZVJlc2V0XzEgPSBkZWZsYXRlUmVzZXQ7XG52YXIgZGVmbGF0ZVJlc2V0S2VlcF8xID0gZGVmbGF0ZVJlc2V0S2VlcDtcbnZhciBkZWZsYXRlU2V0SGVhZGVyXzEgPSBkZWZsYXRlU2V0SGVhZGVyO1xudmFyIGRlZmxhdGVfMiQxID0gZGVmbGF0ZSQyO1xudmFyIGRlZmxhdGVFbmRfMSA9IGRlZmxhdGVFbmQ7XG52YXIgZGVmbGF0ZVNldERpY3Rpb25hcnlfMSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xudmFyIGRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cblxudmFyIGRlZmxhdGVfMSQyID0ge1xuXHRkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSxcblx0ZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSxcblx0ZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSxcblx0ZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLFxuXHRkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMiQxLFxuXHRkZWZsYXRlRW5kOiBkZWZsYXRlRW5kXzEsXG5cdGRlZmxhdGVTZXREaWN0aW9uYXJ5OiBkZWZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRkZWZsYXRlSW5mbzogZGVmbGF0ZUluZm9cbn07XG5cbmNvbnN0IF9oYXMgPSAob2JqLCBrZXkpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxudmFyIGZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY29tbW9uID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0ZmxhdHRlbkNodW5rczogZmxhdHRlbkNodW5rc1xufTtcblxuLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gKHN0cikgPT4ge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gIH1cblxuICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlclxuY29uc3QgYnVmMmJpbnN0cmluZyA9IChidWYsIGxlbikgPT4ge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmLmxlbmd0aCA9PT0gbGVuID8gYnVmIDogYnVmLnN1YmFycmF5KDAsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gKGJ1ZiwgbWF4KSA9PiB7XG4gIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmLnN1YmFycmF5KDAsIG1heCkpO1xuICB9XG5cbiAgbGV0IGksIG91dDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuXHRzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLFxuXHRidWYyc3RyaW5nOiBidWYyc3RyaW5nLFxuXHR1dGY4Ym9yZGVyOiB1dGY4Ym9yZGVyXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbnZhciB6c3RyZWFtID0gWlN0cmVhbTtcblxuY29uc3QgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMSwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNIOiBaX0ZJTklTSCQyLFxuICBaX09LOiBaX09LJDIsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDIsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDFcbn0gPSBjb25zdGFudHMkMjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUkMShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVEJDEsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3RcbiAqIGhhdmUgYGZsdXNoX21vZGVgIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZ1xuICogYnVmZmVycyBhbmQgY2FsbCBbW0RlZmxhdGUjb25FbmRdXS5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDIgOiBaX05PX0ZMVVNIJDE7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgLy8gRW5kZWQgPT4gZmx1c2ggYW5kIGZpbmlzaFxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCQyKSB7XG4gICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LJDI7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgb3V0IGJ1ZmZlciBmdWxsXG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiByZXF1ZXN0ZWQgYW5kIGhhcyBkYXRhXG4gICAgaWYgKF9mbHVzaF9tb2RlID4gMCAmJiBzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXkpOiBvdXRwdXQgZGF0YS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LJDIpIHtcbiAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmxhdG9yID0gbmV3IERlZmxhdGUkMShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXckMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG52YXIgRGVmbGF0ZV8xJDEgPSBEZWZsYXRlJDE7XG52YXIgZGVmbGF0ZV8yID0gZGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVSYXdfMSQxID0gZGVmbGF0ZVJhdyQxO1xudmFyIGd6aXBfMSQxID0gZ3ppcCQxO1xudmFyIGNvbnN0YW50cyQxID0gY29uc3RhbnRzJDI7XG5cbnZhciBkZWZsYXRlXzEkMSA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xJDEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMixcblx0ZGVmbGF0ZVJhdzogZGVmbGF0ZVJhd18xJDEsXG5cdGd6aXA6IGd6aXBfMSQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50cyQxXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEJDEgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgVFlQRSQxID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG52YXIgaW5mZmFzdCA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICBsZXQgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICBsZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIGxldCBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBsZXQgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICBsZXQgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIGxldCB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIGxldCB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgbGV0IHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgbGV0IGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICBsZXQgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICBsZXQgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIGxldCBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICBsZXQgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIGxldCBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICBsZXQgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG5cblxuICBsZXQgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBNQVhCSVRTID0gMTU7XG5jb25zdCBFTk9VR0hfTEVOUyQxID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTJDEgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyQxID0gMDtcbmNvbnN0IExFTlMkMSA9IDE7XG5jb25zdCBESVNUUyQxID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIGxldCBiYXNlX2luZGV4ID0gMDtcbi8vICBsZXQgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICBjb25zdCBjb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICBjb25zdCBvZmZzID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIGxldCBleHRyYSA9IG51bGw7XG4gIGxldCBleHRyYV9pbmRleCA9IDA7XG5cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTJDEgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTJDEpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMkMSkge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMkMSAmJiB1c2VkID4gRU5PVUdIX0xFTlMkMSkgfHxcbiAgICAodHlwZSA9PT0gRElTVFMkMSAmJiB1c2VkID4gRU5PVUdIX0RJU1RTJDEpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMkMSAmJiB1c2VkID4gRU5PVUdIX0xFTlMkMSkgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTJDEgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUyQxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG52YXIgaW5mdHJlZXMgPSBpbmZsYXRlX3RhYmxlO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cblxuXG5cblxuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9GSU5JU0g6IFpfRklOSVNIJDEsIFpfQkxPQ0ssIFpfVFJFRVMsXG4gIFpfT0s6IFpfT0skMSwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMSwgWl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNUJDEsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQxLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQxLCBaX01FTV9FUlJPUjogWl9NRU1fRVJST1IkMSwgWl9CVUZfRVJST1IsXG4gIFpfREVGTEFURURcbn0gPSBjb25zdGFudHMkMjtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG5jb25zdCAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbmNvbnN0ICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgVWludDE2QXJyYXkoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IEludDMyQXJyYXkoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuXG5jb25zdCBpbmZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0MiA9IChzdHJtLCB3aW5kb3dCaXRzKSA9PiB7XG4gIGxldCB3cmFwO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0MiA9IChzdHJtLCB3aW5kb3dCaXRzKSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIGNvbnN0IHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICBjb25zdCByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LJDEpIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQgPSAoc3RybSkgPT4ge1xuXG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn07XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xubGV0IHZpcmdpbiA9IHRydWU7XG5cbmxldCBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cblxuY29uc3QgZml4ZWR0YWJsZXMgPSAoc3RhdGUpID0+IHtcblxuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgbGVuZml4ID0gbmV3IEludDMyQXJyYXkoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IEludDMyQXJyYXkoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBsZXQgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mdHJlZXMoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZ0cmVlcyhESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn07XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4ge1xuXG4gIGxldCBkaXN0O1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgVWludDhBcnJheShzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBzdGF0ZS53c2l6ZSwgZW5kKSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kKSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZSQyID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgbGV0IG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgbGV0IHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIGxldCBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIGxldCBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIGxldCBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG4gIGxldCBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL2xldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgbGV0IGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIGxldCByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICBjb25zdCBoYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIGxldCBvcHRzO1xuXG4gIGxldCBuOyAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgZm9yIE5FRURfQklUU1xuXG4gIGNvbnN0IG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgbmV3IFVpbnQ4QXJyYXkoWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF0pO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0skMTtcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gISEhIHBha28gcGF0Y2guIEZvcmNlIHVzZSBgb3B0aW9ucy53aW5kb3dCaXRzYCBpZiBwYXNzZWQuXG4gICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgICAgICAvL3N0YXRlLmRtYXggPSAxIDw8IGxlbjtcblxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBVaW50OEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLnNldChcbiAgICAgICAgICAgICAgICBpbnB1dC5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgICAgbmV4dCArIGNvcHlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1QkMTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkobmV4dCwgbmV4dCArIGNvcHkpLCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORCQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SJDE7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1IkMTtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIJDEpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIDtcbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIJDEpICYmIHJldCA9PT0gWl9PSyQxKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG5jb25zdCBpbmZsYXRlR2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcbiAgY29uc3QgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGRpY3RpZDtcbiAgbGV0IHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzJfMShkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SJDE7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxudmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0O1xudmFyIGluZmxhdGVSZXNldDJfMSA9IGluZmxhdGVSZXNldDI7XG52YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDtcbnZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7XG52YXIgaW5mbGF0ZUluaXQyXzEgPSBpbmZsYXRlSW5pdDI7XG52YXIgaW5mbGF0ZV8yJDEgPSBpbmZsYXRlJDI7XG52YXIgaW5mbGF0ZUVuZF8xID0gaW5mbGF0ZUVuZDtcbnZhciBpbmZsYXRlR2V0SGVhZGVyXzEgPSBpbmZsYXRlR2V0SGVhZGVyO1xudmFyIGluZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG5cbnZhciBpbmZsYXRlXzEkMiA9IHtcblx0aW5mbGF0ZVJlc2V0OiBpbmZsYXRlUmVzZXRfMSxcblx0aW5mbGF0ZVJlc2V0MjogaW5mbGF0ZVJlc2V0Ml8xLFxuXHRpbmZsYXRlUmVzZXRLZWVwOiBpbmZsYXRlUmVzZXRLZWVwXzEsXG5cdGluZmxhdGVJbml0OiBpbmZsYXRlSW5pdF8xLFxuXHRpbmZsYXRlSW5pdDI6IGluZmxhdGVJbml0Ml8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIkMSxcblx0aW5mbGF0ZUVuZDogaW5mbGF0ZUVuZF8xLFxuXHRpbmZsYXRlR2V0SGVhZGVyOiBpbmZsYXRlR2V0SGVhZGVyXzEsXG5cdGluZmxhdGVTZXREaWN0aW9uYXJ5OiBpbmZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRpbmZsYXRlSW5mbzogaW5mbGF0ZUluZm9cbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbnZhciBnemhlYWRlciA9IEdaaGVhZGVyO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfRklOSVNILFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX01FTV9FUlJPUlxufSA9IGNvbnN0YW50cyQyO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogY29uc3QgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUkMShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTAyNCAqIDY0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgenN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICBsZXQgc3RhdHVzICA9IGluZmxhdGVfMSQyLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgZ3poZWFkZXIoKTtcblxuICBpbmZsYXRlXzEkMi5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChvcHQucmF3KSB7IC8vSW4gcmF3IG1vZGUgd2UgbmVlZCB0byBzZXQgdGhlIGRpY3Rpb25hcnkgZWFybHlcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YVxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFXG4gKiAgIGZsdXNoIG1vZGVzLiBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCxcbiAqICAgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gSWYgZW5kIG9mIHN0cmVhbSBkZXRlY3RlZCxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dIHdpbGwgYmUgY2FsbGVkLlxuICpcbiAqIGBmbHVzaF9tb2RlYCBpcyBub3QgbmVlZGVkIGZvciBub3JtYWwgb3BlcmF0aW9uLCBiZWNhdXNlIGVuZCBvZiBzdHJlYW1cbiAqIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkuIFlvdSBtYXkgdHJ5IHRvIHVzZSBpdCBmb3IgYWR2YW5jZWQgdGhpbmdzLCBidXRcbiAqIHRoaXMgZnVuY3Rpb25hbGl0eSB3YXMgbm90IHRlc3RlZC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZSQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgY29uc3QgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZSwgbGFzdF9hdmFpbF9vdXQ7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIGlmIChzdGF0dXMgPT09IFpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFpfREFUQV9FUlJPUikge1xuICAgICAgICAvLyBSZXBsYWNlIGNvZGUgd2l0aCBtb3JlIHZlcmJvc2VcbiAgICAgICAgc3RhdHVzID0gWl9ORUVEX0RJQ1Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzbnljIG1hcmtlcnMgaWYgbW9yZSBkYXRhIGZvbGxvd3MgYW5kIG5vdCByYXcgbW9kZVxuICAgIHdoaWxlIChzdHJtLmF2YWlsX2luID4gMCAmJlxuICAgICAgICAgICBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCAmJlxuICAgICAgICAgICBzdHJtLnN0YXRlLndyYXAgPiAwICYmXG4gICAgICAgICAgIGRhdGFbc3RybS5uZXh0X2luXSAhPT0gMClcbiAgICB7XG4gICAgICBpbmZsYXRlXzEkMi5pbmZsYXRlUmVzZXQoc3RybSk7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBaX1NUUkVBTV9FUlJPUjpcbiAgICAgIGNhc2UgWl9EQVRBX0VSUk9SOlxuICAgICAgY2FzZSBaX05FRURfRElDVDpcbiAgICAgIGNhc2UgWl9NRU1fRVJST1I6XG4gICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1lbWJlciByZWFsIGBhdmFpbF9vdXRgIHZhbHVlLCBiZWNhdXNlIHdlIG1heSBwYXRjaCBvdXQgYnVmZmVyIGNvbnRlbnRcbiAgICAvLyB0byBhbGlnbiB1dGY4IHN0cmluZ3MgYm91bmRhcmllcy5cbiAgICBsYXN0X2F2YWlsX291dCA9IHN0cm0uYXZhaWxfb3V0O1xuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBsZXQgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICBsZXQgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIGxldCB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbCAmIHJlYWxpZ24gY291bnRlcnNcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHN0cm0ub3V0cHV0LnNldChzdHJtLm91dHB1dC5zdWJhcnJheShuZXh0X291dF91dGY4LCBuZXh0X291dF91dGY4ICsgdGFpbCksIDApO1xuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5sZW5ndGggPT09IHN0cm0ubmV4dF9vdXQgPyBzdHJtLm91dHB1dCA6IHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE11c3QgcmVwZWF0IGl0ZXJhdGlvbiBpZiBvdXQgYnVmZmVyIGlzIGZ1bGxcbiAgICBpZiAoc3RhdHVzID09PSBaX09LICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC5cbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGVhY2ggY2h1bmsgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlJDEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlJDEucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gY29tbW9uLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKTtcbiAqIGNvbnN0IGlucHV0ID0gcGFrby5kZWZsYXRlKG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pKTtcbiAqIGxldCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycikge1xuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZSQxKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHRocm93IGluZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tpbmZsYXRvci5lcnJdO1xuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXckMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxudmFyIEluZmxhdGVfMSQxID0gSW5mbGF0ZSQxO1xudmFyIGluZmxhdGVfMiA9IGluZmxhdGUkMTtcbnZhciBpbmZsYXRlUmF3XzEkMSA9IGluZmxhdGVSYXckMTtcbnZhciB1bmd6aXAkMSA9IGluZmxhdGUkMTtcbnZhciBjb25zdGFudHMgPSBjb25zdGFudHMkMjtcblxudmFyIGluZmxhdGVfMSQxID0ge1xuXHRJbmZsYXRlOiBJbmZsYXRlXzEkMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8yLFxuXHRpbmZsYXRlUmF3OiBpbmZsYXRlUmF3XzEkMSxcblx0dW5nemlwOiB1bmd6aXAkMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHNcbn07XG5cbmNvbnN0IHsgRGVmbGF0ZSwgZGVmbGF0ZSwgZGVmbGF0ZVJhdywgZ3ppcCB9ID0gZGVmbGF0ZV8xJDE7XG5cbmNvbnN0IHsgSW5mbGF0ZSwgaW5mbGF0ZSwgaW5mbGF0ZVJhdywgdW5nemlwIH0gPSBpbmZsYXRlXzEkMTtcblxuXG5cbnZhciBEZWZsYXRlXzEgPSBEZWZsYXRlO1xudmFyIGRlZmxhdGVfMSA9IGRlZmxhdGU7XG52YXIgZGVmbGF0ZVJhd18xID0gZGVmbGF0ZVJhdztcbnZhciBnemlwXzEgPSBnemlwO1xudmFyIEluZmxhdGVfMSA9IEluZmxhdGU7XG52YXIgaW5mbGF0ZV8xID0gaW5mbGF0ZTtcbnZhciBpbmZsYXRlUmF3XzEgPSBpbmZsYXRlUmF3O1xudmFyIHVuZ3ppcF8xID0gdW5nemlwO1xudmFyIGNvbnN0YW50c18xID0gY29uc3RhbnRzJDI7XG5cbnZhciBwYWtvID0ge1xuXHREZWZsYXRlOiBEZWZsYXRlXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMSxcblx0ZGVmbGF0ZVJhdzogZGVmbGF0ZVJhd18xLFxuXHRnemlwOiBnemlwXzEsXG5cdEluZmxhdGU6IEluZmxhdGVfMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8xLFxuXHRpbmZsYXRlUmF3OiBpbmZsYXRlUmF3XzEsXG5cdHVuZ3ppcDogdW5nemlwXzEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzXzFcbn07XG5cbmV4cG9ydCB7IERlZmxhdGVfMSBhcyBEZWZsYXRlLCBJbmZsYXRlXzEgYXMgSW5mbGF0ZSwgY29uc3RhbnRzXzEgYXMgY29uc3RhbnRzLCBwYWtvIGFzIGRlZmF1bHQsIGRlZmxhdGVfMSBhcyBkZWZsYXRlLCBkZWZsYXRlUmF3XzEgYXMgZGVmbGF0ZVJhdywgZ3ppcF8xIGFzIGd6aXAsIGluZmxhdGVfMSBhcyBpbmZsYXRlLCBpbmZsYXRlUmF3XzEgYXMgaW5mbGF0ZVJhdywgdW5nemlwXzEgYXMgdW5nemlwIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBDbGltYXRlIH0gZnJvbSAnZGVlcHNsYXRlJztcblxuaW1wb3J0IHsgQmlvbWVCdWlsZGVyIH0gZnJvbSAnLi9CdWlsZGVyRGF0YS9CaW9tZUJ1aWxkZXInO1xuaW1wb3J0IHsgTGF5b3V0IH0gZnJvbSAnLi9CdWlsZGVyRGF0YS9MYXlvdXQnO1xuaW1wb3J0IHsgVmFuaWxsYUJpb21lcyB9IGZyb20gJy4vVmFuaWxsYS9WYW5pbGxhQmlvbWVzJztcbmltcG9ydCB7IFNpZGViYXJNYW5hZ2VyIH0gZnJvbSAnLi9VSS9TaWRlYmFyTWFuYWdlcic7XG5pbXBvcnQgeyBMYXlvdXRFZGl0b3IgfSBmcm9tICcuL1VJL0xheW91dEVkaXRvcic7XG5pbXBvcnQgeyBVSSB9IGZyb20gJy4vVUkvVUknO1xuaW1wb3J0IHsgU2xpY2UgfSBmcm9tICcuL0J1aWxkZXJEYXRhL1NsaWNlJztcbmltcG9ydCB7IExheW91dEVsZW1lbnRVbmFzc2lnbmVkIH0gZnJvbSAnLi9CdWlsZGVyRGF0YS9MYXlvdXRFbGVtZW50VW5hc3NpZ25lZCc7XG5cblxuY29uc3QgY2xvc2VfZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY2xvc2FibGVfdmVydGljYWxcIilcblxuZm9yIChsZXQgaSA9IDAgOyBpIDwgY2xvc2VfZWxlbWVudHMubGVuZ3RoIDsgaSsrKXtcbiAgICAoY2xvc2VfZWxlbWVudHNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImJ1dHRvblwiKVswXSBhcyBIVE1MRWxlbWVudCkub25jbGljayA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgIGNsb3NlX2VsZW1lbnRzW2ldLmNsYXNzTGlzdC50b2dnbGUoXCJjbG9zZWRcIilcbiAgICB9XG59XG5cblxuXG5cbmNvbnN0IGNvbnRpbmVudGFsbmVzc2VzOiBbc3RyaW5nLCBDbGltYXRlLlBhcmFtXVtdID0gW1xuICAgIFsnTXVzaHJvb20gRmllbGQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMS4yLCAtMS4wNSldLFxuICAgIFsnRGVlcCBPY2VhbicsIG5ldyBDbGltYXRlLlBhcmFtKC0xLjA1LCAtMC40NTUpXSxcbiAgICBbJ09jZWFuJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuNDU1LCAtMC4xOSldLFxuICAgIFsnQ29hc3QnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC4xOSwgLTAuMTEpXSxcbiAgICBbJ05lYXIgSW5sYW5kJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuMTEsIDAuMDMpXSxcbiAgICBbJ01pZCBJbmxhbmQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjAzLCAwLjMpXSxcbiAgICBbJ0ZhciBJbmxhbmQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjMsIDEuMCldXG5dXG5cbmNvbnN0IGVyb3Npb25zOiBbc3RyaW5nLCBDbGltYXRlLlBhcmFtXVtdID0gW1xuICAgIFsnMCcsIG5ldyBDbGltYXRlLlBhcmFtKC0xLjAsIC0wLjc4KV0sXG4gICAgWycxJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuNzgsIC0wLjM3NSldLFxuICAgIFsnMicsIG5ldyBDbGltYXRlLlBhcmFtKC0wLjM3NSwgLTAuMjIyNSldLFxuICAgIFsnMycsIG5ldyBDbGltYXRlLlBhcmFtKC0wLjIyMjUsIDAuMDUpXSxcbiAgICBbJzQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjA1LCAwLjQ1KV0sXG4gICAgWyc1JywgbmV3IENsaW1hdGUuUGFyYW0oMC40NSwgMC41NSldLFxuICAgIFsnNicsIG5ldyBDbGltYXRlLlBhcmFtKDAuNTUsIDEuMCldLFxuXVxuXG5jb25zdCB3ZWlyZG5lc3NlczogW3N0cmluZywgQ2xpbWF0ZS5QYXJhbV1bXSA9IFtcbiAgICBbJ01pZCBTbGljZSBBMicsIG5ldyBDbGltYXRlLlBhcmFtKC0xLjAsIC0wLjkzMzMzMzM0KV0sXG4gICAgWydIaWdoIFNsaWNlIEEyJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuOTMzMzMzMzQsIC0wLjc2NjY2NjcpXSxcbiAgICBbJ1BlYWtzIEEnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC43NjY2NjY3LCAtMC41NjY2NjY2NildLFxuICAgIFsnSGlnaCBTbGljZSBBJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuNTY2NjY2NjYsIC0wLjQpXSxcbiAgICBbJ01pZCBTbGljZSBBJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuNCwgLTAuMjY2NjY2NjgpXSxcbiAgICBbJ0xvdyBTbGljZSBBJywgbmV3IENsaW1hdGUuUGFyYW0oLTAuMjY2NjY2NjgsIC0wLjA1KV0sXG4gICAgWydWYWxsZXknLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC4wNSwgMC4wNSldLFxuICAgIFsnTG93IFNsaWNlIEInLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjA1LCAwLjI2NjY2NjY4KV0sXG4gICAgWydNaWQgU2xpY2UgQicsIG5ldyBDbGltYXRlLlBhcmFtKDAuMjY2NjY2NjgsIDAuNCldLFxuICAgIFsnSGlnaCBTbGljZSBCJywgbmV3IENsaW1hdGUuUGFyYW0oMC40LCAwLjU2NjY2NjY2KV0sXG4gICAgWydQZWFrcyBCJywgbmV3IENsaW1hdGUuUGFyYW0oMC41NjY2NjY2NiwgMC43NjY2NjY3KV0sXG4gICAgWydIaWdoIFNsaWNlIEIyJywgbmV3IENsaW1hdGUuUGFyYW0oMC43NjY2NjY3LCAwLjkzMzMzMzM0KV0sXG4gICAgWydNaWQgU2xpY2UgQjInLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjkzMzMzMzM0LCAxLjApXSxcbl1cblxuY29uc3QgdGVtcGVyYXR1cmVzOiBbc3RyaW5nLCBDbGltYXRlLlBhcmFtXVtdID0gW1xuICAgIFsnZm9yemVuJywgbmV3IENsaW1hdGUuUGFyYW0oLTEuMCwgLTAuNDUpXSxcbiAgICBbJ2NvbGQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC40NSwgLTAuMTUpXSxcbiAgICBbJ25vcm1hbCcsIG5ldyBDbGltYXRlLlBhcmFtKC0wLjE1LCAwLjIpXSxcbiAgICBbJ3dhcm0nLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjIsIDAuNTUpXSxcbiAgICBbJ2hvdCcsIG5ldyBDbGltYXRlLlBhcmFtKDAuNTUsIDEuMCldLFxuXVxuXG5jb25zdCBodW1pZGl0aWVzOiBbc3RyaW5nLCBDbGltYXRlLlBhcmFtXVtdID0gW1xuICAgIFsndmVyeSBkcnknLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMS4wLCAtMC4zKV0sXG4gICAgWydkcnknLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC4zLCAtMC4xKV0sXG4gICAgWydub3JtYWwnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgtMC4xLCAwLjEpXSxcbiAgICBbJ2h1bWlkJywgbmV3IENsaW1hdGUuUGFyYW0oMC4xLCAwLjMpXSxcbiAgICBbJ3ZlcnkgaHVtaWQnLCBuZXcgQ2xpbWF0ZS5QYXJhbSgwLjMsIDEuMCldLFxuXVxuXG5jb25zdCBidWlsZGVyID0gbmV3IEJpb21lQnVpbGRlcihjb250aW5lbnRhbG5lc3NlcywgZXJvc2lvbnMsIHdlaXJkbmVzc2VzLCB0ZW1wZXJhdHVyZXMsIGh1bWlkaXRpZXMpXG5cblZhbmlsbGFCaW9tZXMucmVnaXN0ZXJWYW5pbGxhQmlvbWVzKGJ1aWxkZXIpXG5cblVJLmNyZWF0ZShidWlsZGVyKVxuXG4vL2NvbnN0IHZhbGxleV9zbGljZSA9IFNsaWNlLmNyZWF0ZShidWlsZGVyLCBcIlZhbGxleVwiLCA2KVxuLy92YWxsZXlfc2xpY2Uuc2V0KDMsIDIsIFwiUml2ZXJcIilcbi8vdmFsbGV5X3NsaWNlLnNldCgzLCAzLCBcIk1pZGRsZVwiKVxuXG5cblxuLy9jb25zdCBzbGljZV9ncmlkID0gU2xpY2VHcmlkLmNyZWF0ZVNsaWNlR3JpZEhUTUwoYnVpbGRlciwgdmFsbGV5X3NsaWNlKVxuLy9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNsaWNlRWRpdG9yXCIpLmFwcGVuZENoaWxkKHNsaWNlX2dyaWQpXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==